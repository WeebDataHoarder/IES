/* vim:ts=4:sw=4:expandtab
 * (No tabs, indent level is 4 spaces) */
/*****************************************************************************
 * File:            fm10000_api_crm_state_machines.c
 * Creation Date:   June 1, 2015
 * Description:     Source file for the crm-level state machine
 * 
 *                  ------------------------------------------------------
 *                  THIS FILE IS AUTO-GENERATED BY THE BUILD SYSTEM, DO
 *                  NOT MODIFY THIS FILE.  MODIFY THE FOLLOWING INSTEAD
 *                  ------------------------------------------------------
 * 
 *                  1) fm10000_api_crm_state_machines.xml
 *                  2) templates/fm10000_api_crm_state_machines.c
 *
 * Copyright (c) 2015, Intel Corporation
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Intel Corporation nor the names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

#include <fm_sdk_fm10000_int.h>


/*****************************************************************************
 * Macros, Constants & Types
 *****************************************************************************/

/*****************************************************************************
 * Local function prototypes
 *****************************************************************************/

/* declaration of all action callbacks */
static fm_status CrmMaskInterrupts( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status CrmUpdateChecksum( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status CrmStartTimer( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status CrmCancelTimer( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status CrmUnmaskInterrupts( fm_smEventInfo *eventInfo, void *userInfo );



/* declaration of all condition callbacks */
static fm_status CrmDummy( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );


/* Declarations of transition callbacks for FM10000_BASIC_CRM_STATE_MACHINE */
static fm_status BasicStateMachineS1E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS2E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS3E3Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS5E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS5E4Callback( fm_smEventInfo *eventInfo, void *userInfo );


/*****************************************************************************
 * Global Variables
 *****************************************************************************/

/* array containing descriptive names for each of the CRM states */
fm_text fm10000CrmStatesMap[FM10000_CRM_STATE_MAX] =
{
    "CRM_STATE_IDLE",
    "CRM_STATE_ACTIVE",
    "CRM_STATE_UPDATING",
    "CRM_STATE_REPAIRING",
    "CRM_STATE_DUPLEX",
    "CRM_STATE_RESUMING"

};

/* array containing descriptive names for each of the crm events */
fm_text fm10000CrmEventsMap[FM10000_CRM_EVENT_MAX] =
{
    "CRM_EVENT_SUSPEND_REQ",
    "CRM_EVENT_RESUME_REQ",
    "CRM_EVENT_FAULT_IND",
    "CRM_EVENT_REPAIR_IND",
    "CRM_EVENT_TIMEOUT_IND"

};

/*****************************************************************************
 * Local Variables
 *****************************************************************************/

/*****************************************************************************
 * Local Functions
 *****************************************************************************/

/*****************************************************************************/
/** CrmMaskInterrupts
 * \ingroup intCrmStateMachine 
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status CrmMaskInterrupts( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int crmId = ((fm10000_crmUserInfo *)userInfo)->crmId;
    
    /* this log message can be modified once the crm-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_CRM,
                     crmId,
                     "Event %s occurred on FFU slice %d, executing MaskInterrupts\n", 
                     fm10000CrmEventsMap[eventInfo->eventId],
                     crmId );

    status = fm10000CrmMaskInterrupts( eventInfo, userInfo );

    return status;

}   /* end CrmMaskInterrupts */


/*****************************************************************************/
/** CrmUpdateChecksum
 * \ingroup intCrmStateMachine 
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status CrmUpdateChecksum( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int crmId = ((fm10000_crmUserInfo *)userInfo)->crmId;
    
    /* this log message can be modified once the crm-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_CRM,
                     crmId,
                     "Event %s occurred on FFU slice %d, executing UpdateChecksum\n", 
                     fm10000CrmEventsMap[eventInfo->eventId],
                     crmId );

    status = fm10000CrmUpdateChecksum( eventInfo, userInfo );

    return status;

}   /* end CrmUpdateChecksum */


/*****************************************************************************/
/** CrmStartTimer
 * \ingroup intCrmStateMachine 
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status CrmStartTimer( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int crmId = ((fm10000_crmUserInfo *)userInfo)->crmId;
    
    /* this log message can be modified once the crm-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_CRM,
                     crmId,
                     "Event %s occurred on FFU slice %d, executing StartTimer\n", 
                     fm10000CrmEventsMap[eventInfo->eventId],
                     crmId );

    status = fm10000CrmStartTimer( eventInfo, userInfo );

    return status;

}   /* end CrmStartTimer */


/*****************************************************************************/
/** CrmCancelTimer
 * \ingroup intCrmStateMachine 
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status CrmCancelTimer( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int crmId = ((fm10000_crmUserInfo *)userInfo)->crmId;
    
    /* this log message can be modified once the crm-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_CRM,
                     crmId,
                     "Event %s occurred on FFU slice %d, executing CancelTimer\n", 
                     fm10000CrmEventsMap[eventInfo->eventId],
                     crmId );

    status = fm10000CrmCancelTimer( eventInfo, userInfo );

    return status;

}   /* end CrmCancelTimer */


/*****************************************************************************/
/** CrmUnmaskInterrupts
 * \ingroup intCrmStateMachine 
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status CrmUnmaskInterrupts( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int crmId = ((fm10000_crmUserInfo *)userInfo)->crmId;
    
    /* this log message can be modified once the crm-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_CRM,
                     crmId,
                     "Event %s occurred on FFU slice %d, executing UnmaskInterrupts\n", 
                     fm10000CrmEventsMap[eventInfo->eventId],
                     crmId );

    status = fm10000CrmUnmaskInterrupts( eventInfo, userInfo );

    return status;

}   /* end CrmUnmaskInterrupts */


/*****************************************************************************/
/** CrmDummy
 * \ingroup intCrmStateMachine 
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status CrmDummy( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int crmId = ((fm10000_crmUserInfo *)userInfo)->crmId;
    
    /* this log message can be modified once the crm-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_CRM,
                     crmId,
                     "Event %s occurred on FFU slice %d, executing Dummy\n", 
                     fm10000CrmEventsMap[eventInfo->eventId],
                     crmId );

    status = fm10000CrmDummy( eventInfo, userInfo, nextState );

    return status;

}   /* end CrmDummy */




/******************************************************************************
 * Definitions of transition callbacks for FM10000_BASIC_CRM_STATE_MACHINE
 *****************************************************************************/

/*****************************************************************************/
/** BasicStateMachineS1E0Callback
 * \ingroup intCrmStateMachine
 *
 * \desc            Transition callback for CRM state machine type
 *                  ''FM10000_BASIC_CRM_STATE_MACHINE'', when event
 *                  ''FM10000_CRM_EVENT_SUSPEND_REQ'' occurs in state
 *                  ''FM10000_CRM_STATE_ACTIVE''.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status BasicStateMachineS1E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int crmId = ((fm10000_crmUserInfo *)userInfo)->crmId;
        
    status = CrmMaskInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_CRM, crmId, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS1E0Callback */

/*****************************************************************************/
/** BasicStateMachineS2E1Callback
 * \ingroup intCrmStateMachine
 *
 * \desc            Transition callback for CRM state machine type
 *                  ''FM10000_BASIC_CRM_STATE_MACHINE'', when event
 *                  ''FM10000_CRM_EVENT_RESUME_REQ'' occurs in state
 *                  ''FM10000_CRM_STATE_UPDATING''.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status BasicStateMachineS2E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int crmId = ((fm10000_crmUserInfo *)userInfo)->crmId;
        
    status = CrmUpdateChecksum( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_CRM, crmId, status );
            
    status = CrmStartTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_CRM, crmId, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS2E1Callback */

/*****************************************************************************/
/** BasicStateMachineS3E3Callback
 * \ingroup intCrmStateMachine
 *
 * \desc            Transition callback for CRM state machine type
 *                  ''FM10000_BASIC_CRM_STATE_MACHINE'', when event
 *                  ''FM10000_CRM_EVENT_REPAIR_IND'' occurs in state
 *                  ''FM10000_CRM_STATE_REPAIRING''.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status BasicStateMachineS3E3Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int crmId = ((fm10000_crmUserInfo *)userInfo)->crmId;
        
    status = CrmUpdateChecksum( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_CRM, crmId, status );
            
    status = CrmStartTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_CRM, crmId, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS3E3Callback */

/*****************************************************************************/
/** BasicStateMachineS5E0Callback
 * \ingroup intCrmStateMachine
 *
 * \desc            Transition callback for CRM state machine type
 *                  ''FM10000_BASIC_CRM_STATE_MACHINE'', when event
 *                  ''FM10000_CRM_EVENT_SUSPEND_REQ'' occurs in state
 *                  ''FM10000_CRM_STATE_RESUMING''.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status BasicStateMachineS5E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int crmId = ((fm10000_crmUserInfo *)userInfo)->crmId;
        
    status = CrmCancelTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_CRM, crmId, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS5E0Callback */

/*****************************************************************************/
/** BasicStateMachineS5E4Callback
 * \ingroup intCrmStateMachine
 *
 * \desc            Transition callback for CRM state machine type
 *                  ''FM10000_BASIC_CRM_STATE_MACHINE'', when event
 *                  ''FM10000_CRM_EVENT_TIMEOUT_IND'' occurs in state
 *                  ''FM10000_CRM_STATE_RESUMING''.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status BasicStateMachineS5E4Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int crmId = ((fm10000_crmUserInfo *)userInfo)->crmId;
        
    status = CrmUnmaskInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_CRM, crmId, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS5E4Callback */


/*****************************************************************************
 * Public Functions
 *****************************************************************************/


/*****************************************************************************/
/** fm10000RegisterBasicCrmStateMachine
 * \ingroup intCrmStateMachine
 *
 * \desc            This function registers with the Generic State Machine
 *                  Engine state machine type ''FM10000_BASIC_CRM_STATE_MACHINE''.
 * 
 * \return          FM_OK if the state machine was created successfully.
 * 
 * \return          FM_ERR_INVALID_ARGUMENT if one of the arguments is invalid.
 *
 * \return          FM_ERR_NO_MEM if there was a memory allocation failure
 *                  while creating one of the state machine internal structures.
 * 
 * \return          FM_ERR_STATE_MACHINE_TYPE if this state machine type is
 *                  already registered .
 *
 *****************************************************************************/
fm_status fm10000RegisterBasicCrmStateMachine( void )
{
    fm_int      i;
    fm_status   status;
    fm_smTransitionEntry  stt[FM10000_CRM_STATE_MAX][FM10000_CRM_EVENT_MAX];
    fm_smTransitionEntry *dynstt[FM10000_CRM_STATE_MAX];
    fm_smTransitionLogCallback logCallback;

    
    /* log callback for this type */
    logCallback = fm10000LogCrmTransition;
    

    /* clear out the temporary state transition table */
    FM_MEMSET_S( stt, sizeof(stt), 0, sizeof(stt));

    /* transition for state=CRM_STATE_IDLE(0), event=CRM_EVENT_SUSPEND_REQ(0) */
    stt[FM10000_CRM_STATE_IDLE]
       [FM10000_CRM_EVENT_SUSPEND_REQ].used = TRUE;
    stt[FM10000_CRM_STATE_IDLE]
       [FM10000_CRM_EVENT_SUSPEND_REQ].nextState = FM10000_CRM_STATE_IDLE;
    stt[FM10000_CRM_STATE_IDLE]
       [FM10000_CRM_EVENT_SUSPEND_REQ].conditionCallback = NULL;
    stt[FM10000_CRM_STATE_IDLE]
       [FM10000_CRM_EVENT_SUSPEND_REQ].transitionCallback = NULL;

    /* transition for state=CRM_STATE_IDLE(0), event=CRM_EVENT_RESUME_REQ(1) */
    stt[FM10000_CRM_STATE_IDLE]
       [FM10000_CRM_EVENT_RESUME_REQ].used = TRUE;
    stt[FM10000_CRM_STATE_IDLE]
       [FM10000_CRM_EVENT_RESUME_REQ].nextState = FM10000_CRM_STATE_IDLE;
    stt[FM10000_CRM_STATE_IDLE]
       [FM10000_CRM_EVENT_RESUME_REQ].conditionCallback = NULL;
    stt[FM10000_CRM_STATE_IDLE]
       [FM10000_CRM_EVENT_RESUME_REQ].transitionCallback = NULL;

    /* transition for state=CRM_STATE_IDLE(0), event=CRM_EVENT_FAULT_IND(2) */
    stt[FM10000_CRM_STATE_IDLE]
       [FM10000_CRM_EVENT_FAULT_IND].used = TRUE;
    stt[FM10000_CRM_STATE_IDLE]
       [FM10000_CRM_EVENT_FAULT_IND].nextState = FM10000_CRM_STATE_IDLE;
    stt[FM10000_CRM_STATE_IDLE]
       [FM10000_CRM_EVENT_FAULT_IND].conditionCallback = NULL;
    stt[FM10000_CRM_STATE_IDLE]
       [FM10000_CRM_EVENT_FAULT_IND].transitionCallback = NULL;

    /* transition for state=CRM_STATE_IDLE(0), event=CRM_EVENT_REPAIR_IND(3) */
    stt[FM10000_CRM_STATE_IDLE]
       [FM10000_CRM_EVENT_REPAIR_IND].used = TRUE;
    stt[FM10000_CRM_STATE_IDLE]
       [FM10000_CRM_EVENT_REPAIR_IND].nextState = FM10000_CRM_STATE_IDLE;
    stt[FM10000_CRM_STATE_IDLE]
       [FM10000_CRM_EVENT_REPAIR_IND].conditionCallback = NULL;
    stt[FM10000_CRM_STATE_IDLE]
       [FM10000_CRM_EVENT_REPAIR_IND].transitionCallback = NULL;

    /* transition for state=CRM_STATE_IDLE(0), event=CRM_EVENT_TIMEOUT_IND(4) */
    stt[FM10000_CRM_STATE_IDLE]
       [FM10000_CRM_EVENT_TIMEOUT_IND].used = TRUE;
    stt[FM10000_CRM_STATE_IDLE]
       [FM10000_CRM_EVENT_TIMEOUT_IND].nextState = FM10000_CRM_STATE_IDLE;
    stt[FM10000_CRM_STATE_IDLE]
       [FM10000_CRM_EVENT_TIMEOUT_IND].conditionCallback = NULL;
    stt[FM10000_CRM_STATE_IDLE]
       [FM10000_CRM_EVENT_TIMEOUT_IND].transitionCallback = NULL;

    /* transition for state=CRM_STATE_ACTIVE(1), event=CRM_EVENT_SUSPEND_REQ(0) */
    stt[FM10000_CRM_STATE_ACTIVE]
       [FM10000_CRM_EVENT_SUSPEND_REQ].used = TRUE;
    stt[FM10000_CRM_STATE_ACTIVE]
       [FM10000_CRM_EVENT_SUSPEND_REQ].nextState = FM10000_CRM_STATE_UPDATING;
    stt[FM10000_CRM_STATE_ACTIVE]
       [FM10000_CRM_EVENT_SUSPEND_REQ].conditionCallback = NULL;
    stt[FM10000_CRM_STATE_ACTIVE]
       [FM10000_CRM_EVENT_SUSPEND_REQ].transitionCallback = BasicStateMachineS1E0Callback;

    /* transition for state=CRM_STATE_ACTIVE(1), event=CRM_EVENT_RESUME_REQ(1) */
    stt[FM10000_CRM_STATE_ACTIVE]
       [FM10000_CRM_EVENT_RESUME_REQ].used = TRUE;
    stt[FM10000_CRM_STATE_ACTIVE]
       [FM10000_CRM_EVENT_RESUME_REQ].nextState = FM10000_CRM_STATE_ACTIVE;
    stt[FM10000_CRM_STATE_ACTIVE]
       [FM10000_CRM_EVENT_RESUME_REQ].conditionCallback = NULL;
    stt[FM10000_CRM_STATE_ACTIVE]
       [FM10000_CRM_EVENT_RESUME_REQ].transitionCallback = NULL;

    /* transition for state=CRM_STATE_ACTIVE(1), event=CRM_EVENT_FAULT_IND(2) */
    stt[FM10000_CRM_STATE_ACTIVE]
       [FM10000_CRM_EVENT_FAULT_IND].used = TRUE;
    stt[FM10000_CRM_STATE_ACTIVE]
       [FM10000_CRM_EVENT_FAULT_IND].nextState = FM10000_CRM_STATE_REPAIRING;
    stt[FM10000_CRM_STATE_ACTIVE]
       [FM10000_CRM_EVENT_FAULT_IND].conditionCallback = NULL;
    stt[FM10000_CRM_STATE_ACTIVE]
       [FM10000_CRM_EVENT_FAULT_IND].transitionCallback = NULL;

    /* transition for state=CRM_STATE_ACTIVE(1), event=CRM_EVENT_REPAIR_IND(3) */
    stt[FM10000_CRM_STATE_ACTIVE]
       [FM10000_CRM_EVENT_REPAIR_IND].used = TRUE;
    stt[FM10000_CRM_STATE_ACTIVE]
       [FM10000_CRM_EVENT_REPAIR_IND].nextState = FM10000_CRM_STATE_ACTIVE;
    stt[FM10000_CRM_STATE_ACTIVE]
       [FM10000_CRM_EVENT_REPAIR_IND].conditionCallback = NULL;
    stt[FM10000_CRM_STATE_ACTIVE]
       [FM10000_CRM_EVENT_REPAIR_IND].transitionCallback = NULL;

    /* transition for state=CRM_STATE_ACTIVE(1), event=CRM_EVENT_TIMEOUT_IND(4) */
    stt[FM10000_CRM_STATE_ACTIVE]
       [FM10000_CRM_EVENT_TIMEOUT_IND].used = TRUE;
    stt[FM10000_CRM_STATE_ACTIVE]
       [FM10000_CRM_EVENT_TIMEOUT_IND].nextState = FM10000_CRM_STATE_ACTIVE;
    stt[FM10000_CRM_STATE_ACTIVE]
       [FM10000_CRM_EVENT_TIMEOUT_IND].conditionCallback = NULL;
    stt[FM10000_CRM_STATE_ACTIVE]
       [FM10000_CRM_EVENT_TIMEOUT_IND].transitionCallback = NULL;

    /* transition for state=CRM_STATE_UPDATING(2), event=CRM_EVENT_SUSPEND_REQ(0) */
    stt[FM10000_CRM_STATE_UPDATING]
       [FM10000_CRM_EVENT_SUSPEND_REQ].used = TRUE;
    stt[FM10000_CRM_STATE_UPDATING]
       [FM10000_CRM_EVENT_SUSPEND_REQ].nextState = FM10000_CRM_STATE_UPDATING;
    stt[FM10000_CRM_STATE_UPDATING]
       [FM10000_CRM_EVENT_SUSPEND_REQ].conditionCallback = NULL;
    stt[FM10000_CRM_STATE_UPDATING]
       [FM10000_CRM_EVENT_SUSPEND_REQ].transitionCallback = NULL;

    /* transition for state=CRM_STATE_UPDATING(2), event=CRM_EVENT_RESUME_REQ(1) */
    stt[FM10000_CRM_STATE_UPDATING]
       [FM10000_CRM_EVENT_RESUME_REQ].used = TRUE;
    stt[FM10000_CRM_STATE_UPDATING]
       [FM10000_CRM_EVENT_RESUME_REQ].nextState = FM10000_CRM_STATE_RESUMING ;
    stt[FM10000_CRM_STATE_UPDATING]
       [FM10000_CRM_EVENT_RESUME_REQ].conditionCallback = NULL;
    stt[FM10000_CRM_STATE_UPDATING]
       [FM10000_CRM_EVENT_RESUME_REQ].transitionCallback = BasicStateMachineS2E1Callback;

    /* transition for state=CRM_STATE_UPDATING(2), event=CRM_EVENT_FAULT_IND(2) */
    stt[FM10000_CRM_STATE_UPDATING]
       [FM10000_CRM_EVENT_FAULT_IND].used = TRUE;
    stt[FM10000_CRM_STATE_UPDATING]
       [FM10000_CRM_EVENT_FAULT_IND].nextState = FM10000_CRM_STATE_UPDATING;
    stt[FM10000_CRM_STATE_UPDATING]
       [FM10000_CRM_EVENT_FAULT_IND].conditionCallback = NULL;
    stt[FM10000_CRM_STATE_UPDATING]
       [FM10000_CRM_EVENT_FAULT_IND].transitionCallback = NULL;

    /* transition for state=CRM_STATE_UPDATING(2), event=CRM_EVENT_REPAIR_IND(3) */
    stt[FM10000_CRM_STATE_UPDATING]
       [FM10000_CRM_EVENT_REPAIR_IND].used = TRUE;
    stt[FM10000_CRM_STATE_UPDATING]
       [FM10000_CRM_EVENT_REPAIR_IND].nextState = FM10000_CRM_STATE_UPDATING;
    stt[FM10000_CRM_STATE_UPDATING]
       [FM10000_CRM_EVENT_REPAIR_IND].conditionCallback = NULL;
    stt[FM10000_CRM_STATE_UPDATING]
       [FM10000_CRM_EVENT_REPAIR_IND].transitionCallback = NULL;

    /* transition for state=CRM_STATE_UPDATING(2), event=CRM_EVENT_TIMEOUT_IND(4) */
    stt[FM10000_CRM_STATE_UPDATING]
       [FM10000_CRM_EVENT_TIMEOUT_IND].used = TRUE;
    stt[FM10000_CRM_STATE_UPDATING]
       [FM10000_CRM_EVENT_TIMEOUT_IND].nextState = FM10000_CRM_STATE_UPDATING;
    stt[FM10000_CRM_STATE_UPDATING]
       [FM10000_CRM_EVENT_TIMEOUT_IND].conditionCallback = NULL;
    stt[FM10000_CRM_STATE_UPDATING]
       [FM10000_CRM_EVENT_TIMEOUT_IND].transitionCallback = NULL;

    /* transition for state=CRM_STATE_REPAIRING(3), event=CRM_EVENT_SUSPEND_REQ(0) */
    stt[FM10000_CRM_STATE_REPAIRING]
       [FM10000_CRM_EVENT_SUSPEND_REQ].used = TRUE;
    stt[FM10000_CRM_STATE_REPAIRING]
       [FM10000_CRM_EVENT_SUSPEND_REQ].nextState = FM10000_CRM_STATE_REPAIRING;
    stt[FM10000_CRM_STATE_REPAIRING]
       [FM10000_CRM_EVENT_SUSPEND_REQ].conditionCallback = NULL;
    stt[FM10000_CRM_STATE_REPAIRING]
       [FM10000_CRM_EVENT_SUSPEND_REQ].transitionCallback = NULL;

    /* transition for state=CRM_STATE_REPAIRING(3), event=CRM_EVENT_RESUME_REQ(1) */
    stt[FM10000_CRM_STATE_REPAIRING]
       [FM10000_CRM_EVENT_RESUME_REQ].used = TRUE;
    stt[FM10000_CRM_STATE_REPAIRING]
       [FM10000_CRM_EVENT_RESUME_REQ].nextState = FM10000_CRM_STATE_REPAIRING ;
    stt[FM10000_CRM_STATE_REPAIRING]
       [FM10000_CRM_EVENT_RESUME_REQ].conditionCallback = NULL;
    stt[FM10000_CRM_STATE_REPAIRING]
       [FM10000_CRM_EVENT_RESUME_REQ].transitionCallback = NULL;

    /* transition for state=CRM_STATE_REPAIRING(3), event=CRM_EVENT_FAULT_IND(2) */
    stt[FM10000_CRM_STATE_REPAIRING]
       [FM10000_CRM_EVENT_FAULT_IND].used = TRUE;
    stt[FM10000_CRM_STATE_REPAIRING]
       [FM10000_CRM_EVENT_FAULT_IND].nextState = FM10000_CRM_STATE_REPAIRING;
    stt[FM10000_CRM_STATE_REPAIRING]
       [FM10000_CRM_EVENT_FAULT_IND].conditionCallback = NULL;
    stt[FM10000_CRM_STATE_REPAIRING]
       [FM10000_CRM_EVENT_FAULT_IND].transitionCallback = NULL;

    /* transition for state=CRM_STATE_REPAIRING(3), event=CRM_EVENT_REPAIR_IND(3) */
    stt[FM10000_CRM_STATE_REPAIRING]
       [FM10000_CRM_EVENT_REPAIR_IND].used = TRUE;
    stt[FM10000_CRM_STATE_REPAIRING]
       [FM10000_CRM_EVENT_REPAIR_IND].nextState = FM10000_CRM_STATE_RESUMING;
    stt[FM10000_CRM_STATE_REPAIRING]
       [FM10000_CRM_EVENT_REPAIR_IND].conditionCallback = NULL;
    stt[FM10000_CRM_STATE_REPAIRING]
       [FM10000_CRM_EVENT_REPAIR_IND].transitionCallback = BasicStateMachineS3E3Callback;

    /* transition for state=CRM_STATE_REPAIRING(3), event=CRM_EVENT_TIMEOUT_IND(4) */
    stt[FM10000_CRM_STATE_REPAIRING]
       [FM10000_CRM_EVENT_TIMEOUT_IND].used = TRUE;
    stt[FM10000_CRM_STATE_REPAIRING]
       [FM10000_CRM_EVENT_TIMEOUT_IND].nextState = FM10000_CRM_STATE_REPAIRING;
    stt[FM10000_CRM_STATE_REPAIRING]
       [FM10000_CRM_EVENT_TIMEOUT_IND].conditionCallback = NULL;
    stt[FM10000_CRM_STATE_REPAIRING]
       [FM10000_CRM_EVENT_TIMEOUT_IND].transitionCallback = NULL;

    /* transition for state=CRM_STATE_DUPLEX(4), event=CRM_EVENT_SUSPEND_REQ(0) */
    stt[FM10000_CRM_STATE_DUPLEX]
       [FM10000_CRM_EVENT_SUSPEND_REQ].used = TRUE;
    stt[FM10000_CRM_STATE_DUPLEX]
       [FM10000_CRM_EVENT_SUSPEND_REQ].nextState = FM10000_CRM_STATE_DUPLEX;
    stt[FM10000_CRM_STATE_DUPLEX]
       [FM10000_CRM_EVENT_SUSPEND_REQ].conditionCallback = NULL;
    stt[FM10000_CRM_STATE_DUPLEX]
       [FM10000_CRM_EVENT_SUSPEND_REQ].transitionCallback = NULL;

    /* transition for state=CRM_STATE_DUPLEX(4), event=CRM_EVENT_RESUME_REQ(1) */
    stt[FM10000_CRM_STATE_DUPLEX]
       [FM10000_CRM_EVENT_RESUME_REQ].used = TRUE;
    stt[FM10000_CRM_STATE_DUPLEX]
       [FM10000_CRM_EVENT_RESUME_REQ].nextState = FM10000_CRM_STATE_REPAIRING ;
    stt[FM10000_CRM_STATE_DUPLEX]
       [FM10000_CRM_EVENT_RESUME_REQ].conditionCallback = NULL;
    stt[FM10000_CRM_STATE_DUPLEX]
       [FM10000_CRM_EVENT_RESUME_REQ].transitionCallback = NULL;

    /* transition for state=CRM_STATE_DUPLEX(4), event=CRM_EVENT_FAULT_IND(2) */
    stt[FM10000_CRM_STATE_DUPLEX]
       [FM10000_CRM_EVENT_FAULT_IND].used = TRUE;
    stt[FM10000_CRM_STATE_DUPLEX]
       [FM10000_CRM_EVENT_FAULT_IND].nextState = FM10000_CRM_STATE_DUPLEX;
    stt[FM10000_CRM_STATE_DUPLEX]
       [FM10000_CRM_EVENT_FAULT_IND].conditionCallback = NULL;
    stt[FM10000_CRM_STATE_DUPLEX]
       [FM10000_CRM_EVENT_FAULT_IND].transitionCallback = NULL;

    /* transition for state=CRM_STATE_DUPLEX(4), event=CRM_EVENT_REPAIR_IND(3) */
    stt[FM10000_CRM_STATE_DUPLEX]
       [FM10000_CRM_EVENT_REPAIR_IND].used = TRUE;
    stt[FM10000_CRM_STATE_DUPLEX]
       [FM10000_CRM_EVENT_REPAIR_IND].nextState = FM10000_CRM_STATE_UPDATING;
    stt[FM10000_CRM_STATE_DUPLEX]
       [FM10000_CRM_EVENT_REPAIR_IND].conditionCallback = NULL;
    stt[FM10000_CRM_STATE_DUPLEX]
       [FM10000_CRM_EVENT_REPAIR_IND].transitionCallback = NULL;

    /* transition for state=CRM_STATE_DUPLEX(4), event=CRM_EVENT_TIMEOUT_IND(4) */
    stt[FM10000_CRM_STATE_DUPLEX]
       [FM10000_CRM_EVENT_TIMEOUT_IND].used = TRUE;
    stt[FM10000_CRM_STATE_DUPLEX]
       [FM10000_CRM_EVENT_TIMEOUT_IND].nextState = FM10000_CRM_STATE_DUPLEX;
    stt[FM10000_CRM_STATE_DUPLEX]
       [FM10000_CRM_EVENT_TIMEOUT_IND].conditionCallback = NULL;
    stt[FM10000_CRM_STATE_DUPLEX]
       [FM10000_CRM_EVENT_TIMEOUT_IND].transitionCallback = NULL;

    /* transition for state=CRM_STATE_RESUMING(5), event=CRM_EVENT_SUSPEND_REQ(0) */
    stt[FM10000_CRM_STATE_RESUMING]
       [FM10000_CRM_EVENT_SUSPEND_REQ].used = TRUE;
    stt[FM10000_CRM_STATE_RESUMING]
       [FM10000_CRM_EVENT_SUSPEND_REQ].nextState = FM10000_CRM_STATE_UPDATING;
    stt[FM10000_CRM_STATE_RESUMING]
       [FM10000_CRM_EVENT_SUSPEND_REQ].conditionCallback = NULL;
    stt[FM10000_CRM_STATE_RESUMING]
       [FM10000_CRM_EVENT_SUSPEND_REQ].transitionCallback = BasicStateMachineS5E0Callback;

    /* transition for state=CRM_STATE_RESUMING(5), event=CRM_EVENT_RESUME_REQ(1) */
    stt[FM10000_CRM_STATE_RESUMING]
       [FM10000_CRM_EVENT_RESUME_REQ].used = TRUE;
    stt[FM10000_CRM_STATE_RESUMING]
       [FM10000_CRM_EVENT_RESUME_REQ].nextState = FM10000_CRM_STATE_RESUMING ;
    stt[FM10000_CRM_STATE_RESUMING]
       [FM10000_CRM_EVENT_RESUME_REQ].conditionCallback = NULL;
    stt[FM10000_CRM_STATE_RESUMING]
       [FM10000_CRM_EVENT_RESUME_REQ].transitionCallback = NULL;

    /* transition for state=CRM_STATE_RESUMING(5), event=CRM_EVENT_FAULT_IND(2) */
    stt[FM10000_CRM_STATE_RESUMING]
       [FM10000_CRM_EVENT_FAULT_IND].used = TRUE;
    stt[FM10000_CRM_STATE_RESUMING]
       [FM10000_CRM_EVENT_FAULT_IND].nextState = FM10000_CRM_STATE_RESUMING;
    stt[FM10000_CRM_STATE_RESUMING]
       [FM10000_CRM_EVENT_FAULT_IND].conditionCallback = NULL;
    stt[FM10000_CRM_STATE_RESUMING]
       [FM10000_CRM_EVENT_FAULT_IND].transitionCallback = NULL;

    /* transition for state=CRM_STATE_RESUMING(5), event=CRM_EVENT_REPAIR_IND(3) */
    stt[FM10000_CRM_STATE_RESUMING]
       [FM10000_CRM_EVENT_REPAIR_IND].used = TRUE;
    stt[FM10000_CRM_STATE_RESUMING]
       [FM10000_CRM_EVENT_REPAIR_IND].nextState = FM10000_CRM_STATE_RESUMING;
    stt[FM10000_CRM_STATE_RESUMING]
       [FM10000_CRM_EVENT_REPAIR_IND].conditionCallback = NULL;
    stt[FM10000_CRM_STATE_RESUMING]
       [FM10000_CRM_EVENT_REPAIR_IND].transitionCallback = NULL;

    /* transition for state=CRM_STATE_RESUMING(5), event=CRM_EVENT_TIMEOUT_IND(4) */
    stt[FM10000_CRM_STATE_RESUMING]
       [FM10000_CRM_EVENT_TIMEOUT_IND].used = TRUE;
    stt[FM10000_CRM_STATE_RESUMING]
       [FM10000_CRM_EVENT_TIMEOUT_IND].nextState = FM10000_CRM_STATE_ACTIVE;
    stt[FM10000_CRM_STATE_RESUMING]
       [FM10000_CRM_EVENT_TIMEOUT_IND].conditionCallback = NULL;
    stt[FM10000_CRM_STATE_RESUMING]
       [FM10000_CRM_EVENT_TIMEOUT_IND].transitionCallback = BasicStateMachineS5E4Callback;

    /* fill out the state transition table for this state machine type */
    for (i = 0 ; i < FM10000_CRM_STATE_MAX ; i++)
    {
        dynstt[i] = &stt[i][0];
    }

    /* register this state machine type */
    status = fmRegisterStateTransitionTable( FM10000_BASIC_CRM_STATE_MACHINE,
                                             FM10000_CRM_STATE_MAX,
                                             FM10000_CRM_EVENT_MAX,
                                             dynstt,
                                             logCallback,
                                             TRUE ); 
    return status;

}   /* end fm10000RegisterBasicCrmStateMachine */

