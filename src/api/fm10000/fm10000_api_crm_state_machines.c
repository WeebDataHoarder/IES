/* vim:ts=4:sw=4:expandtab
 * (No tabs, indent level is 4 spaces) */
/*****************************************************************************
 * File:            fm10000_api_crm_state_machines.c
 * Creation Date:   June 1, 2015
 * Description:     Source file for the crm-level state machine
 * 
 *                  ------------------------------------------------------
 *                  THIS FILE IS AUTO-GENERATED BY THE BUILD SYSTEM, DO
 *                  NOT MODIFY THIS FILE.  MODIFY THE FOLLOWING INSTEAD
 *                  ------------------------------------------------------
 * 
 *                  1) fm10000_api_crm_state_machines.xml
 *                  2) templates/fm10000_api_crm_state_machines.c
 *
 * Copyright (c) 2015, Intel Corporation
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Intel Corporation nor the names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

#include <fm_sdk_fm10000_int.h>


/*****************************************************************************
 * Macros, Constants & Types
 *****************************************************************************/

#define ST(s) FM10000_CRM_STATE_ ## s
#define EV(e) FM10000_CRM_EVENT_ ## e
#define TG(g) TransitionGroup ## g
#define FN(n) (genericFunction) n

typedef void (*genericFunction)(void);

/****************************************************************/
/** \ingroup intCrmStateMachine 
 * Definition of the State Machine Transition Table values.
 ****************************************************************/
typedef struct _fm_smTable
{
    /* callback for transition or condition */
    genericFunction         callback;
    
    /** current state identifier */
    fm_int                  current;

    /** event identifier */
    fm_int                  event;

    /** next state identifier */
    fm_int                  next;

} fm_smTable;


/*****************************************************************************
 * Local function prototypes
 *****************************************************************************/

/* declaration of all action callbacks */
static fm_status CrmMaskInterrupts( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status CrmUpdateChecksum( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status CrmStartTimer( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status CrmCancelTimer( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status CrmUnmaskInterrupts( fm_smEventInfo *eventInfo, void *userInfo );



/* declaration of all condition callbacks */
static fm_status CrmDummy( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );



/* declaration of transition group callbacks */
static fm_status TG(0)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(1)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(2)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(3)( fm_smEventInfo *eventInfo, void *userInfo );


/*****************************************************************************
 * Global Variables
 *****************************************************************************/

/* array containing descriptive names for each of the CRM states */
fm_text fm10000CrmStatesMap[FM10000_CRM_STATE_MAX] =
{
    "CRM_STATE_IDLE",
    "CRM_STATE_ACTIVE",
    "CRM_STATE_UPDATING",
    "CRM_STATE_REPAIRING",
    "CRM_STATE_DUPLEX",
    "CRM_STATE_RESUMING"

};

/* array containing descriptive names for each of the CRM events */
fm_text fm10000CrmEventsMap[FM10000_CRM_EVENT_MAX] =
{
    "CRM_EVENT_SUSPEND_REQ",
    "CRM_EVENT_RESUME_REQ",
    "CRM_EVENT_FAULT_IND",
    "CRM_EVENT_REPAIR_IND",
    "CRM_EVENT_TIMEOUT_IND"

};

/*****************************************************************************
 * Local Variables
 *****************************************************************************/


static const fm_smTable fm10000BasicSmTable[] = {
    { FN(TG(0)), ST(UPDATING) , EV(RESUME_REQ) , ST(RESUMING)  },
    { FN(TG(0)), ST(REPAIRING), EV(REPAIR_IND) , ST(RESUMING)  },
    { FN(TG(1)), ST(RESUMING) , EV(TIMEOUT_IND), ST(ACTIVE)    },
    { FN(TG(2)), ST(RESUMING) , EV(SUSPEND_REQ), ST(UPDATING)  },
    { NULL     , ST(ACTIVE)   , EV(FAULT_IND)  , ST(REPAIRING) },
    { NULL     , ST(DUPLEX)   , EV(RESUME_REQ) , ST(REPAIRING) },
    { NULL     , ST(DUPLEX)   , EV(REPAIR_IND) , ST(UPDATING)  },
    { FN(TG(3)), ST(ACTIVE)   , EV(SUSPEND_REQ), ST(UPDATING)  }
};



/*****************************************************************************
 * Local Functions
 *****************************************************************************/

/*****************************************************************************/
/* CrmMaskInterrupts
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status CrmMaskInterrupts( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int crmId = ((fm10000_crmUserInfo *)userInfo)->crmId;
    
    /* this log message can be modified once the crm-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_CRM,
                     crmId,
                     "Event %s occurred on FFU slice %d, executing MaskInterrupts\n", 
                     fm10000CrmEventsMap[eventInfo->eventId],
                     crmId );

    status = fm10000CrmMaskInterrupts( eventInfo, userInfo );

    return status;

}   /* end CrmMaskInterrupts */


/*****************************************************************************/
/* CrmUpdateChecksum
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status CrmUpdateChecksum( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int crmId = ((fm10000_crmUserInfo *)userInfo)->crmId;
    
    /* this log message can be modified once the crm-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_CRM,
                     crmId,
                     "Event %s occurred on FFU slice %d, executing UpdateChecksum\n", 
                     fm10000CrmEventsMap[eventInfo->eventId],
                     crmId );

    status = fm10000CrmUpdateChecksum( eventInfo, userInfo );

    return status;

}   /* end CrmUpdateChecksum */


/*****************************************************************************/
/* CrmStartTimer
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status CrmStartTimer( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int crmId = ((fm10000_crmUserInfo *)userInfo)->crmId;
    
    /* this log message can be modified once the crm-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_CRM,
                     crmId,
                     "Event %s occurred on FFU slice %d, executing StartTimer\n", 
                     fm10000CrmEventsMap[eventInfo->eventId],
                     crmId );

    status = fm10000CrmStartTimer( eventInfo, userInfo );

    return status;

}   /* end CrmStartTimer */


/*****************************************************************************/
/* CrmCancelTimer
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status CrmCancelTimer( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int crmId = ((fm10000_crmUserInfo *)userInfo)->crmId;
    
    /* this log message can be modified once the crm-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_CRM,
                     crmId,
                     "Event %s occurred on FFU slice %d, executing CancelTimer\n", 
                     fm10000CrmEventsMap[eventInfo->eventId],
                     crmId );

    status = fm10000CrmCancelTimer( eventInfo, userInfo );

    return status;

}   /* end CrmCancelTimer */


/*****************************************************************************/
/* CrmUnmaskInterrupts
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status CrmUnmaskInterrupts( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int crmId = ((fm10000_crmUserInfo *)userInfo)->crmId;
    
    /* this log message can be modified once the crm-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_CRM,
                     crmId,
                     "Event %s occurred on FFU slice %d, executing UnmaskInterrupts\n", 
                     fm10000CrmEventsMap[eventInfo->eventId],
                     crmId );

    status = fm10000CrmUnmaskInterrupts( eventInfo, userInfo );

    return status;

}   /* end CrmUnmaskInterrupts */


/*****************************************************************************/
/* CrmDummy
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status CrmDummy( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int crmId = ((fm10000_crmUserInfo *)userInfo)->crmId;
    
    /* this log message can be modified once the Crm-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_CRM,
                     crmId,
                     "Event %s occurred on FFU slice %d, executing Dummy\n", 
                     fm10000CrmEventsMap[eventInfo->eventId],
                     crmId );

    status = fm10000CrmDummy( eventInfo, userInfo, nextState );

    return status;

}   /* end CrmDummy */




/******************************************************************************
 * Definitions of transition group callbacks 
 *****************************************************************************/


/*****************************************************************************/
/* TransitionGroup0
 *
 * \desc            Transition callback for CRM state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(0)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int crmId = ((fm10000_crmUserInfo *)userInfo)->crmId;

    status = CrmUpdateChecksum( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_CRM, crmId, status );

    status = CrmStartTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_CRM, crmId, status );

ABORT:
    return status;

}   /* end TransitionGroup0 */


/*****************************************************************************/
/* TransitionGroup1
 *
 * \desc            Transition callback for CRM state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(1)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int crmId = ((fm10000_crmUserInfo *)userInfo)->crmId;

    status = CrmUnmaskInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_CRM, crmId, status );

ABORT:
    return status;

}   /* end TransitionGroup1 */


/*****************************************************************************/
/* TransitionGroup2
 *
 * \desc            Transition callback for CRM state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(2)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int crmId = ((fm10000_crmUserInfo *)userInfo)->crmId;

    status = CrmCancelTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_CRM, crmId, status );

ABORT:
    return status;

}   /* end TransitionGroup2 */


/*****************************************************************************/
/* TransitionGroup3
 *
 * \desc            Transition callback for CRM state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(3)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int crmId = ((fm10000_crmUserInfo *)userInfo)->crmId;

    status = CrmMaskInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_CRM, crmId, status );

ABORT:
    return status;

}   /* end TransitionGroup3 */


/*****************************************************************************
 * Public Functions
 *****************************************************************************/


/*****************************************************************************/
/* fm10000RegisterBasicCrmStateMachine
 *
 * \desc            This function registers with the Generic State Machine
 *                  Engine state machine type ''FM10000_BASIC_CRM_STATE_MACHINE''.
 * 
 * \return          FM_OK if the state machine was created successfully.
 * 
 * \return          FM_ERR_INVALID_ARGUMENT if one of the arguments is invalid.
 *
 * \return          FM_ERR_NO_MEM if there was a memory allocation failure
 *                  while creating one of the state machine internal structures.
 * 
 * \return          FM_ERR_STATE_MACHINE_TYPE if this state machine type is
 *                  already registered .
 *
 *****************************************************************************/
fm_status fm10000RegisterBasicCrmStateMachine( void )
{
    fm_uint     i;
    fm_status   status;
    fm_smTransitionEntry  stt[FM10000_CRM_STATE_MAX][FM10000_CRM_EVENT_MAX];
    fm_smTransitionEntry *dynstt[FM10000_CRM_STATE_MAX];
    fm_smTransitionLogCallback logCallback;

    
    /* log callback for this type */
    logCallback = fm10000LogCrmTransition;
    

    /* clear out the temporary state transition table */
    FM_MEMSET_S( stt, sizeof(stt), 0, sizeof(stt));

    for (i = 0 ; 
         i < (sizeof(fm10000BasicSmTable) / sizeof(fm_smTable)); 
         i++)
    {
        stt[fm10000BasicSmTable[i].current]
           [fm10000BasicSmTable[i].event].used = TRUE;

        stt[fm10000BasicSmTable[i].current]
           [fm10000BasicSmTable[i].event].nextState = 
               fm10000BasicSmTable[i].next;

        if (fm10000BasicSmTable[i].next == FM_STATE_UNSPECIFIED)
        {
            stt[fm10000BasicSmTable[i].current]
               [fm10000BasicSmTable[i].event].conditionCallback = 
                   (fm_smConditionCallback) fm10000BasicSmTable[i].callback;

            stt[fm10000BasicSmTable[i].current]
               [fm10000BasicSmTable[i].event].transitionCallback = NULL;
        }
        else
        {
            stt[fm10000BasicSmTable[i].current]
               [fm10000BasicSmTable[i].event].conditionCallback = NULL;

            stt[fm10000BasicSmTable[i].current]
               [fm10000BasicSmTable[i].event].transitionCallback = 
                   (fm_smTransitionCallback) fm10000BasicSmTable[i].callback;
        }
    }

    /* fill out the state transition table for this state machine type */
    for (i = 0 ; i < FM10000_CRM_STATE_MAX ; i++)
    {
        dynstt[i] = &stt[i][0];
    }

    /* register this state machine type */
    status = fmRegisterStateTransitionTable( FM10000_BASIC_CRM_STATE_MACHINE,
                                             FM10000_CRM_STATE_MAX,
                                             FM10000_CRM_EVENT_MAX,
                                             dynstt,
                                             logCallback,
                                             TRUE ); 
    return status;

}   /* end fm10000RegisterBasicCrmStateMachine */


