/* vim:ts=4:sw=4:expandtab
 * (No tabs, indent level is 4 spaces) */
/*****************************************************************************
 * File:            fm10000_api_port_state_machines.c
 * Creation Date:   October 30, 2013
 * Description:     Source file for the port-level state machine
 * 
 *                  ------------------------------------------------------
 *                  THIS FILE IS AUTO-GENERATED BY THE BUILD SYSTEM, DO
 *                  NOT MODIFY THIS FILE.  MODIFY THE FOLLOWING INSTEAD
 *                  ------------------------------------------------------
 * 
 *                  1) fm10000_api_port_state_machine.xml
 *                  2) templates/fm10000_api_port_state_machine.c
 *
 * Copyright (c) 2007 - 2015, Intel Corporation
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Intel Corporation nor the names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

#include <fm_sdk_fm10000_int.h>


/*****************************************************************************
 * Macros, Constants & Types
 *****************************************************************************/

/*****************************************************************************
 * Local function prototypes
 *****************************************************************************/

/* declaration of all action callbacks */
static fm_status PowerUpLane( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PowerUpLaneRx( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PowerUpLaneTx( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PowerDownLane( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PowerDownLaneRx( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PowerDownLaneTx( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status ReleaseSchedBw( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status UpdateSchedBw( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status ConfigureLane( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status ConfigureLaneForAn73( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status NotifyApiPortUp( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status NotifyApiPortDown( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status ConfigureLoopback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status RestoreTxFaultMode( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SetTxFaultMode( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SetTxFaultModeToNormal( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status InitPcs( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Init1000BaseX( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Init10GBaseR( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status InitMlBaseR( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status InitAn73( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status WriteEplCfgA( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status WriteEplCfgB( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status WriteMac( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status EnableDrainMode( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status DisableDrainMode( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status EnablePhy( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status DisablePhy( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status EnableLinkInterrupts( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status DisableLinkInterrupts( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status ResetPortModuleState( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status EnableLoopback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status DisableLoopback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status EnableFabricLoopback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status DisableFabricLoopback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status ClearEplFifo( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status EnableBistMode( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status DisableBistMode( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Restart100gSyncDetection( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status StartDeferralTimer( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status StopDeferralTimer( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status FlagError( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status ConfigureDfe( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status LinkPortToLanes( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status UnlinkPortFromLanes( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status UpdatePcieModeAndSpeed( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status UpdatePcieLanePolarity( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status UpdatePcieLaneReversal( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status EnablePcieInterrupts( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status DisablePcieInterrupts( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStart( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStop( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status ReconfigurePortForAn( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status RestoreDfe( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status ReconfigureScheduler( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status ConfigureFarLoopback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status EnableLowPowerIdle( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status InitPepMailbox( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status EnablePepLoopback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status DisablePepLoopback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status NotifyEthModeChange( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status EnablePhyAutoneg( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status DisablePhyAutoneg( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status StartAnWatchDogTimer( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status StopAnWatchDogTimer( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status StartDeferredLpiTimer( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status StopDeferredLpiTimer( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status DeferredLpiMode( fm_smEventInfo *eventInfo, void *userInfo );



/* declaration of all condition callbacks */
static fm_status CheckLanesReady( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status ProcessDeferralTimer( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status ProcessDeferralTimerWithAn( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status ConfigureDeviceAndCheckState( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status CheckPortStatus( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status AnRestart( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status EnterNegotiatedMode( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status SetupAdminModeUp( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status ExitBistMode( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status ExitAdminFaultMode( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status ProcessDisableFabricLoopback( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );


/* Declarations of transition callbacks for FM10000_AN_PORT_STATE_MACHINE */
static fm_status AnStateMachineS0E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS1E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS2E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS2E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS2E4Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS2E5Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS2E7Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS2E8Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS2E9Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS3E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS3E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS3E6Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS3E18Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS4E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS4E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS4E6Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS5E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS5E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS5E2Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS5E3Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS5E6Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS5E22Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS5E23Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS6E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS6E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS6E5Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS6E6Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS6E7Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS6E8Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS6E9Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS6E23Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS7E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS7E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS7E5Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS7E6Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS7E7Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS7E8Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS7E9Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS7E23Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS7E20Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS8E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS8E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS8E5Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS8E6Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS8E7Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS8E8Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS8E9Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS8E23Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS8E20Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS9E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS9E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS9E5Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS9E6Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS9E7Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS9E8Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS9E9Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS9E23Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS11E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS11E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS11E5Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS11E6Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS11E7Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS11E8Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS11E9Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS11E23Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS11E11Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS11E12Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS11E28Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStateMachineS11E21Callback( fm_smEventInfo *eventInfo, void *userInfo );

/* Declarations of transition callbacks for FM10000_BASIC_PORT_STATE_MACHINE */
static fm_status BasicStateMachineS0E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS1E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS2E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS2E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS2E4Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS2E5Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS2E7Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS2E8Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS2E9Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS3E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS3E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS3E2Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS3E3Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS3E4Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS3E5Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS3E6Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS3E7Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS3E8Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS3E9Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS3E10Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS3E18Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS4E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS4E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS4E2Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS4E3Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS4E4Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS4E5Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS4E6Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS4E7Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS4E8Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS4E9Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS4E10Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS4E18Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS6E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS6E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS6E5Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS6E6Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS6E7Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS6E8Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS6E9Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS6E10Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS7E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS7E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS7E2Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS7E3Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS7E26Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS7E5Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS7E6Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS7E7Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS7E8Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS7E9Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS7E10Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS7E11Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS7E20Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS8E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS8E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS8E2Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS8E3Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS8E26Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS8E5Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS8E6Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS8E7Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS8E8Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS8E9Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS8E10Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS8E20Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS9E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS9E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS9E2Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS9E3Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS9E5Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS9E6Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS9E7Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS9E8Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS9E9Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS9E10Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS11E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS11E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS11E2Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS11E3Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS11E26Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS11E5Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS11E6Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS11E7Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS11E8Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS11E9Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS11E10Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS11E11Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS11E12Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS11E28Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status BasicStateMachineS11E21Callback( fm_smEventInfo *eventInfo, void *userInfo );

/* Declarations of transition callbacks for FM10000_PCIE_PORT_STATE_MACHINE */
static fm_status PcieStateMachineS0E20Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS0E19Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS0E2Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS0E3Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS0E4Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS0E5Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS0E6Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS0E7Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS0E8Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS0E9Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS0E11Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS0E12Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS0E13Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS0E14Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS0E15Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS0E16Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS0E17Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS0E18Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS0E21Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS10E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS10E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS10E20Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS10E19Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS10E2Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS10E3Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS10E4Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS10E5Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS10E6Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS10E7Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS10E8Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS10E9Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS10E11Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS10E12Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS10E13Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS10E14Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS10E15Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS10E16Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS10E17Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS10E18Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS10E21Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS10E26Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS10E27Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS11E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS11E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS11E20Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS11E19Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS11E2Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS11E3Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS11E4Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS11E5Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS11E6Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS11E7Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS11E8Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS11E9Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS11E11Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS11E12Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS11E13Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS11E14Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS11E15Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS11E16Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS11E17Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS11E18Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS11E21Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS11E26Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PcieStateMachineS11E27Callback( fm_smEventInfo *eventInfo, void *userInfo );


/*****************************************************************************
 * Global Variables
 *****************************************************************************/

/* array containing descriptive names for each of the port states */
fm_text fm10000PortStatesMap[FM10000_PORT_STATE_MAX] =
{
    "PORT_STATE_DISABLED",
    "PORT_STATE_NEED_CONFIG",
    "PORT_STATE_CONFIGURED",
    "PORT_STATE_POWERING_UP",
    "PORT_STATE_DEFERRED_UP",
    "PORT_STATE_AUTONEG",
    "PORT_STATE_ADMIN_FAULT",
    "PORT_STATE_LOCAL_FAULT",
    "PORT_STATE_REMOTE_FAULT",
    "PORT_STATE_BIST",
    "PORT_STATE_DOWN",
    "PORT_STATE_UP"

};

/* array containing descriptive names for each of the port events */
fm_text fm10000PortEventsMap[FM10000_PORT_EVENT_MAX] =
{
    "PORT_EVENT_CONFIG_REQ",
    "PORT_EVENT_DISABLE_REQ",
    "PORT_EVENT_LOOPBACK_ON_REQ",
    "PORT_EVENT_LOOPBACK_OFF_REQ",
    "PORT_EVENT_ADMIN_UP_REQ",
    "PORT_EVENT_ADMIN_DOWN_REQ",
    "PORT_EVENT_ADMIN_PWRDOWN_REQ",
    "PORT_EVENT_REMOTE_FAULT_REQ",
    "PORT_EVENT_LOCAL_FAULT_REQ",
    "PORT_EVENT_BIST_REQ",
    "PORT_EVENT_CONFIGURE_DFE_REQ",
    "PORT_EVENT_REMOTE_FAULT_IND",
    "PORT_EVENT_LOCAL_FAULT_IND",
    "PORT_EVENT_LANE_DFE_COMPLETE_IND",
    "PORT_EVENT_LANE_DFE_FAILED_IND",
    "PORT_EVENT_LANE_KR_COMPLETE_IND",
    "PORT_EVENT_LANE_KR_FAILED_IND",
    "PORT_EVENT_LANE_READY_IND",
    "PORT_EVENT_LANE_NOT_READY_IND",
    "PORT_EVENT_LINK_DOWN_IND",
    "PORT_EVENT_LINK_UP_IND",
    "PORT_EVENT_DEFTIMER_EXP_IND",
    "PORT_EVENT_AN_CONFIG_REQ",
    "PORT_EVENT_AN_DISABLE_REQ",
    "PORT_EVENT_AN_COMPLETE_IND",
    "PORT_EVENT_AN_RESTARTED_IND",
    "PORT_EVENT_FABRIC_LOOPBACK_ON_REQ",
    "PORT_EVENT_FABRIC_LOOPBACK_OFF_REQ",
    "PORT_EVENT_EEE_SILENT_IND",
    "PORT_EVENT_EEE_CONFIG_REQ"

};

/*****************************************************************************
 * Local Variables
 *****************************************************************************/

/*****************************************************************************
 * Local Functions
 *****************************************************************************/

/*****************************************************************************/
/** PowerUpLane
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status PowerUpLane( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing PowerUpLane\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000PowerUpLane( eventInfo, userInfo );

    return status;

} /* end  PowerUpLane */


/*****************************************************************************/
/** PowerUpLaneRx
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status PowerUpLaneRx( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing PowerUpLaneRx\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000PowerUpLaneRx( eventInfo, userInfo );

    return status;

} /* end  PowerUpLaneRx */


/*****************************************************************************/
/** PowerUpLaneTx
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status PowerUpLaneTx( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing PowerUpLaneTx\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000PowerUpLaneTx( eventInfo, userInfo );

    return status;

} /* end  PowerUpLaneTx */


/*****************************************************************************/
/** PowerDownLane
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status PowerDownLane( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing PowerDownLane\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000PowerDownLane( eventInfo, userInfo );

    return status;

} /* end  PowerDownLane */


/*****************************************************************************/
/** PowerDownLaneRx
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status PowerDownLaneRx( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing PowerDownLaneRx\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000PowerDownLaneRx( eventInfo, userInfo );

    return status;

} /* end  PowerDownLaneRx */


/*****************************************************************************/
/** PowerDownLaneTx
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status PowerDownLaneTx( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing PowerDownLaneTx\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000PowerDownLaneTx( eventInfo, userInfo );

    return status;

} /* end  PowerDownLaneTx */


/*****************************************************************************/
/** ReleaseSchedBw
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status ReleaseSchedBw( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing ReleaseSchedBw\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ReleaseSchedBw( eventInfo, userInfo );

    return status;

} /* end  ReleaseSchedBw */


/*****************************************************************************/
/** UpdateSchedBw
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status UpdateSchedBw( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing UpdateSchedBw\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000UpdateSchedBw( eventInfo, userInfo );

    return status;

} /* end  UpdateSchedBw */


/*****************************************************************************/
/** ConfigureLane
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status ConfigureLane( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing ConfigureLane\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ConfigureLane( eventInfo, userInfo );

    return status;

} /* end  ConfigureLane */


/*****************************************************************************/
/** ConfigureLaneForAn73
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status ConfigureLaneForAn73( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing ConfigureLaneForAn73\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ConfigureLaneForAn73( eventInfo, userInfo );

    return status;

} /* end  ConfigureLaneForAn73 */


/*****************************************************************************/
/** NotifyApiPortUp
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status NotifyApiPortUp( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing NotifyApiPortUp\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000NotifyApiPortUp( eventInfo, userInfo );

    return status;

} /* end  NotifyApiPortUp */


/*****************************************************************************/
/** NotifyApiPortDown
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status NotifyApiPortDown( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing NotifyApiPortDown\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000NotifyApiPortDown( eventInfo, userInfo );

    return status;

} /* end  NotifyApiPortDown */


/*****************************************************************************/
/** ConfigureLoopback
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status ConfigureLoopback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing ConfigureLoopback\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ConfigureLoopback( eventInfo, userInfo );

    return status;

} /* end  ConfigureLoopback */


/*****************************************************************************/
/** RestoreTxFaultMode
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status RestoreTxFaultMode( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing RestoreTxFaultMode\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000RestoreTxFaultMode( eventInfo, userInfo );

    return status;

} /* end  RestoreTxFaultMode */


/*****************************************************************************/
/** SetTxFaultMode
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status SetTxFaultMode( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing SetTxFaultMode\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000SetTxFaultMode( eventInfo, userInfo );

    return status;

} /* end  SetTxFaultMode */


/*****************************************************************************/
/** SetTxFaultModeToNormal
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status SetTxFaultModeToNormal( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing SetTxFaultModeToNormal\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000SetTxFaultModeToNormal( eventInfo, userInfo );

    return status;

} /* end  SetTxFaultModeToNormal */


/*****************************************************************************/
/** InitPcs
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status InitPcs( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing InitPcs\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000InitPcs( eventInfo, userInfo );

    return status;

} /* end  InitPcs */


/*****************************************************************************/
/** Init1000BaseX
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status Init1000BaseX( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing Init1000BaseX\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000Init1000BaseX( eventInfo, userInfo );

    return status;

} /* end  Init1000BaseX */


/*****************************************************************************/
/** Init10GBaseR
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status Init10GBaseR( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing Init10GBaseR\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000Init10GBaseR( eventInfo, userInfo );

    return status;

} /* end  Init10GBaseR */


/*****************************************************************************/
/** InitMlBaseR
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status InitMlBaseR( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing InitMlBaseR\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000InitMlBaseR( eventInfo, userInfo );

    return status;

} /* end  InitMlBaseR */


/*****************************************************************************/
/** InitAn73
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status InitAn73( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing InitAn73\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000InitAn73( eventInfo, userInfo );

    return status;

} /* end  InitAn73 */


/*****************************************************************************/
/** WriteEplCfgA
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status WriteEplCfgA( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing WriteEplCfgA\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000WriteEplCfgA( eventInfo, userInfo );

    return status;

} /* end  WriteEplCfgA */


/*****************************************************************************/
/** WriteEplCfgB
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status WriteEplCfgB( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing WriteEplCfgB\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000WriteEplCfgB( eventInfo, userInfo );

    return status;

} /* end  WriteEplCfgB */


/*****************************************************************************/
/** WriteMac
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status WriteMac( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing WriteMac\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000WriteMac( eventInfo, userInfo );

    return status;

} /* end  WriteMac */


/*****************************************************************************/
/** EnableDrainMode
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status EnableDrainMode( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing EnableDrainMode\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000EnableDrainMode( eventInfo, userInfo );

    return status;

} /* end  EnableDrainMode */


/*****************************************************************************/
/** DisableDrainMode
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status DisableDrainMode( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing DisableDrainMode\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000DisableDrainMode( eventInfo, userInfo );

    return status;

} /* end  DisableDrainMode */


/*****************************************************************************/
/** EnablePhy
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status EnablePhy( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing EnablePhy\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000EnablePhy( eventInfo, userInfo );

    return status;

} /* end  EnablePhy */


/*****************************************************************************/
/** DisablePhy
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status DisablePhy( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing DisablePhy\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000DisablePhy( eventInfo, userInfo );

    return status;

} /* end  DisablePhy */


/*****************************************************************************/
/** EnableLinkInterrupts
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status EnableLinkInterrupts( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing EnableLinkInterrupts\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000EnableLinkInterrupts( eventInfo, userInfo );

    return status;

} /* end  EnableLinkInterrupts */


/*****************************************************************************/
/** DisableLinkInterrupts
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status DisableLinkInterrupts( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing DisableLinkInterrupts\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000DisableLinkInterrupts( eventInfo, userInfo );

    return status;

} /* end  DisableLinkInterrupts */


/*****************************************************************************/
/** ResetPortModuleState
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status ResetPortModuleState( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing ResetPortModuleState\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ResetPortModuleState( eventInfo, userInfo );

    return status;

} /* end  ResetPortModuleState */


/*****************************************************************************/
/** EnableLoopback
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status EnableLoopback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing EnableLoopback\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000EnableLoopback( eventInfo, userInfo );

    return status;

} /* end  EnableLoopback */


/*****************************************************************************/
/** DisableLoopback
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status DisableLoopback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing DisableLoopback\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000DisableLoopback( eventInfo, userInfo );

    return status;

} /* end  DisableLoopback */


/*****************************************************************************/
/** EnableFabricLoopback
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status EnableFabricLoopback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing EnableFabricLoopback\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000EnableFabricLoopback( eventInfo, userInfo );

    return status;

} /* end  EnableFabricLoopback */


/*****************************************************************************/
/** DisableFabricLoopback
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status DisableFabricLoopback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing DisableFabricLoopback\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000DisableFabricLoopback( eventInfo, userInfo );

    return status;

} /* end  DisableFabricLoopback */


/*****************************************************************************/
/** ClearEplFifo
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status ClearEplFifo( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing ClearEplFifo\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ClearEplFifo( eventInfo, userInfo );

    return status;

} /* end  ClearEplFifo */


/*****************************************************************************/
/** EnableBistMode
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status EnableBistMode( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing EnableBistMode\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000EnableBistMode( eventInfo, userInfo );

    return status;

} /* end  EnableBistMode */


/*****************************************************************************/
/** DisableBistMode
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status DisableBistMode( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing DisableBistMode\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000DisableBistMode( eventInfo, userInfo );

    return status;

} /* end  DisableBistMode */


/*****************************************************************************/
/** Restart100gSyncDetection
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status Restart100gSyncDetection( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing Restart100gSyncDetection\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000Restart100gSyncDetection( eventInfo, userInfo );

    return status;

} /* end  Restart100gSyncDetection */


/*****************************************************************************/
/** StartDeferralTimer
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status StartDeferralTimer( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing StartDeferralTimer\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000StartDeferralTimer( eventInfo, userInfo );

    return status;

} /* end  StartDeferralTimer */


/*****************************************************************************/
/** StopDeferralTimer
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status StopDeferralTimer( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing StopDeferralTimer\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000StopDeferralTimer( eventInfo, userInfo );

    return status;

} /* end  StopDeferralTimer */


/*****************************************************************************/
/** FlagError
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status FlagError( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing FlagError\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000FlagError( eventInfo, userInfo );

    return status;

} /* end  FlagError */


/*****************************************************************************/
/** ConfigureDfe
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status ConfigureDfe( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing ConfigureDfe\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ConfigureDfe( eventInfo, userInfo );

    return status;

} /* end  ConfigureDfe */


/*****************************************************************************/
/** LinkPortToLanes
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status LinkPortToLanes( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing LinkPortToLanes\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000LinkPortToLanes( eventInfo, userInfo );

    return status;

} /* end  LinkPortToLanes */


/*****************************************************************************/
/** UnlinkPortFromLanes
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status UnlinkPortFromLanes( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing UnlinkPortFromLanes\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000UnlinkPortFromLanes( eventInfo, userInfo );

    return status;

} /* end  UnlinkPortFromLanes */


/*****************************************************************************/
/** UpdatePcieModeAndSpeed
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status UpdatePcieModeAndSpeed( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing UpdatePcieModeAndSpeed\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000UpdatePcieModeAndSpeed( eventInfo, userInfo );

    return status;

} /* end  UpdatePcieModeAndSpeed */


/*****************************************************************************/
/** UpdatePcieLanePolarity
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status UpdatePcieLanePolarity( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing UpdatePcieLanePolarity\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000UpdatePcieLanePolarity( eventInfo, userInfo );

    return status;

} /* end  UpdatePcieLanePolarity */


/*****************************************************************************/
/** UpdatePcieLaneReversal
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status UpdatePcieLaneReversal( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing UpdatePcieLaneReversal\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000UpdatePcieLaneReversal( eventInfo, userInfo );

    return status;

} /* end  UpdatePcieLaneReversal */


/*****************************************************************************/
/** EnablePcieInterrupts
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status EnablePcieInterrupts( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing EnablePcieInterrupts\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000EnablePcieInterrupts( eventInfo, userInfo );

    return status;

} /* end  EnablePcieInterrupts */


/*****************************************************************************/
/** DisablePcieInterrupts
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status DisablePcieInterrupts( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing DisablePcieInterrupts\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000DisablePcieInterrupts( eventInfo, userInfo );

    return status;

} /* end  DisablePcieInterrupts */


/*****************************************************************************/
/** AnStart
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status AnStart( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing AnStart\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000AnStart( eventInfo, userInfo );

    return status;

} /* end  AnStart */


/*****************************************************************************/
/** AnStop
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status AnStop( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing AnStop\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000AnStop( eventInfo, userInfo );

    return status;

} /* end  AnStop */


/*****************************************************************************/
/** ReconfigurePortForAn
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status ReconfigurePortForAn( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing ReconfigurePortForAn\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ReconfigurePortForAn( eventInfo, userInfo );

    return status;

} /* end  ReconfigurePortForAn */


/*****************************************************************************/
/** RestoreDfe
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status RestoreDfe( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing RestoreDfe\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000RestoreDfe( eventInfo, userInfo );

    return status;

} /* end  RestoreDfe */


/*****************************************************************************/
/** ReconfigureScheduler
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status ReconfigureScheduler( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing ReconfigureScheduler\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ReconfigureScheduler( eventInfo, userInfo );

    return status;

} /* end  ReconfigureScheduler */


/*****************************************************************************/
/** ConfigureFarLoopback
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status ConfigureFarLoopback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing ConfigureFarLoopback\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ConfigureFarLoopback( eventInfo, userInfo );

    return status;

} /* end  ConfigureFarLoopback */


/*****************************************************************************/
/** EnableLowPowerIdle
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status EnableLowPowerIdle( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing EnableLowPowerIdle\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000EnableLowPowerIdle( eventInfo, userInfo );

    return status;

} /* end  EnableLowPowerIdle */


/*****************************************************************************/
/** InitPepMailbox
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status InitPepMailbox( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing InitPepMailbox\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000InitPepMailbox( eventInfo, userInfo );

    return status;

} /* end  InitPepMailbox */


/*****************************************************************************/
/** EnablePepLoopback
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status EnablePepLoopback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing EnablePepLoopback\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000EnablePepLoopback( eventInfo, userInfo );

    return status;

} /* end  EnablePepLoopback */


/*****************************************************************************/
/** DisablePepLoopback
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status DisablePepLoopback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing DisablePepLoopback\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000DisablePepLoopback( eventInfo, userInfo );

    return status;

} /* end  DisablePepLoopback */


/*****************************************************************************/
/** NotifyEthModeChange
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status NotifyEthModeChange( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing NotifyEthModeChange\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000NotifyEthModeChange( eventInfo, userInfo );

    return status;

} /* end  NotifyEthModeChange */


/*****************************************************************************/
/** EnablePhyAutoneg
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status EnablePhyAutoneg( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing EnablePhyAutoneg\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000EnablePhyAutoneg( eventInfo, userInfo );

    return status;

} /* end  EnablePhyAutoneg */


/*****************************************************************************/
/** DisablePhyAutoneg
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status DisablePhyAutoneg( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing DisablePhyAutoneg\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000DisablePhyAutoneg( eventInfo, userInfo );

    return status;

} /* end  DisablePhyAutoneg */


/*****************************************************************************/
/** StartAnWatchDogTimer
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status StartAnWatchDogTimer( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing StartAnWatchDogTimer\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000StartAnWatchDogTimer( eventInfo, userInfo );

    return status;

} /* end  StartAnWatchDogTimer */


/*****************************************************************************/
/** StopAnWatchDogTimer
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status StopAnWatchDogTimer( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing StopAnWatchDogTimer\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000StopAnWatchDogTimer( eventInfo, userInfo );

    return status;

} /* end  StopAnWatchDogTimer */


/*****************************************************************************/
/** StartDeferredLpiTimer
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status StartDeferredLpiTimer( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing StartDeferredLpiTimer\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000StartDeferredLpiTimer( eventInfo, userInfo );

    return status;

} /* end  StartDeferredLpiTimer */


/*****************************************************************************/
/** StopDeferredLpiTimer
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status StopDeferredLpiTimer( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing StopDeferredLpiTimer\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000StopDeferredLpiTimer( eventInfo, userInfo );

    return status;

} /* end  StopDeferredLpiTimer */


/*****************************************************************************/
/** DeferredLpiMode
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status DeferredLpiMode( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing DeferredLpiMode\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000DeferredLpiMode( eventInfo, userInfo );

    return status;

} /* end  DeferredLpiMode */


/*****************************************************************************/
/** CheckLanesReady
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state
 *
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status CheckLanesReady( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    /* this log message can be modified once the port-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing CheckLanesReady\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000CheckLanesReady ( eventInfo, userInfo, nextState );

    return status;

} /* end  CheckLanesReady */


/*****************************************************************************/
/** ProcessDeferralTimer
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state
 *
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status ProcessDeferralTimer( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    /* this log message can be modified once the port-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing ProcessDeferralTimer\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ProcessDeferralTimer ( eventInfo, userInfo, nextState );

    return status;

} /* end  ProcessDeferralTimer */


/*****************************************************************************/
/** ProcessDeferralTimerWithAn
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state
 *
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status ProcessDeferralTimerWithAn( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    /* this log message can be modified once the port-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing ProcessDeferralTimerWithAn\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ProcessDeferralTimerWithAn ( eventInfo, userInfo, nextState );

    return status;

} /* end  ProcessDeferralTimerWithAn */


/*****************************************************************************/
/** ConfigureDeviceAndCheckState
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state
 *
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status ConfigureDeviceAndCheckState( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    /* this log message can be modified once the port-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing ConfigureDeviceAndCheckState\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ConfigureDeviceAndCheckState ( eventInfo, userInfo, nextState );

    return status;

} /* end  ConfigureDeviceAndCheckState */


/*****************************************************************************/
/** CheckPortStatus
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state
 *
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status CheckPortStatus( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    /* this log message can be modified once the port-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing CheckPortStatus\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000CheckPortStatus ( eventInfo, userInfo, nextState );

    return status;

} /* end  CheckPortStatus */


/*****************************************************************************/
/** AnRestart
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state
 *
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status AnRestart( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    /* this log message can be modified once the port-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing AnRestart\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000AnRestart ( eventInfo, userInfo, nextState );

    return status;

} /* end  AnRestart */


/*****************************************************************************/
/** EnterNegotiatedMode
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state
 *
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status EnterNegotiatedMode( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    /* this log message can be modified once the port-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing EnterNegotiatedMode\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000EnterNegotiatedMode ( eventInfo, userInfo, nextState );

    return status;

} /* end  EnterNegotiatedMode */


/*****************************************************************************/
/** SetupAdminModeUp
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state
 *
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status SetupAdminModeUp( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    /* this log message can be modified once the port-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing SetupAdminModeUp\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000SetupAdminModeUp ( eventInfo, userInfo, nextState );

    return status;

} /* end  SetupAdminModeUp */


/*****************************************************************************/
/** ExitBistMode
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state
 *
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status ExitBistMode( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    /* this log message can be modified once the port-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing ExitBistMode\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ExitBistMode ( eventInfo, userInfo, nextState );

    return status;

} /* end  ExitBistMode */


/*****************************************************************************/
/** ExitAdminFaultMode
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state
 *
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status ExitAdminFaultMode( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    /* this log message can be modified once the port-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing ExitAdminFaultMode\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ExitAdminFaultMode ( eventInfo, userInfo, nextState );

    return status;

} /* end  ExitAdminFaultMode */


/*****************************************************************************/
/** ProcessDisableFabricLoopback
 * ingroup intPortStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state
 *
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status ProcessDisableFabricLoopback( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    /* this log message can be modified once the port-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing ProcessDisableFabricLoopback\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ProcessDisableFabricLoopback ( eventInfo, userInfo, nextState );

    return status;

} /* end  ProcessDisableFabricLoopback */




/******************************************************************************
 * Definitions of transition callbacks for FM10000_AN_PORT_STATE_MACHINE
 *****************************************************************************/

/*****************************************************************************/
/** AnStateMachineS0E0Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_CONFIG_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DISABLED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS0E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS0E0Callback() */

/*****************************************************************************/
/** AnStateMachineS1E0Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_CONFIG_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_NEED_CONFIG
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS1E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = SetTxFaultModeToNormal( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS1E0Callback() */

/*****************************************************************************/
/** AnStateMachineS2E0Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_CONFIG_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_CONFIGURED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS2E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS2E0Callback() */

/*****************************************************************************/
/** AnStateMachineS2E1Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_DISABLE_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_CONFIGURED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS2E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UnlinkPortFromLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS2E1Callback() */

/*****************************************************************************/
/** AnStateMachineS2E4Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_UP_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_CONFIGURED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS2E4Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultModeToNormal( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UpdateSchedBw( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS2E4Callback() */

/*****************************************************************************/
/** AnStateMachineS2E5Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_DOWN_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_CONFIGURED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS2E5Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultModeToNormal( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UpdateSchedBw( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS2E5Callback() */

/*****************************************************************************/
/** AnStateMachineS2E7Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_REMOTE_FAULT_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_CONFIGURED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS2E7Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultModeToNormal( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UpdateSchedBw( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS2E7Callback() */

/*****************************************************************************/
/** AnStateMachineS2E8Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOCAL_FAULT_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_CONFIGURED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS2E8Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultModeToNormal( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UpdateSchedBw( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS2E8Callback() */

/*****************************************************************************/
/** AnStateMachineS2E9Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_BIST_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_CONFIGURED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS2E9Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultModeToNormal( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UpdateSchedBw( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS2E9Callback() */

/*****************************************************************************/
/** AnStateMachineS3E0Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_CONFIG_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_POWERING_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS3E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS3E0Callback() */

/*****************************************************************************/
/** AnStateMachineS3E1Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_DISABLE_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_POWERING_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS3E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UnlinkPortFromLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS3E1Callback() */

/*****************************************************************************/
/** AnStateMachineS3E6Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_POWERING_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS3E6Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReleaseSchedBw( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigurePortForAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS3E6Callback() */

/*****************************************************************************/
/** AnStateMachineS3E18Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LANE_NOT_READY_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_POWERING_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS3E18Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS3E18Callback() */

/*****************************************************************************/
/** AnStateMachineS4E0Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_CONFIG_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DEFERRED_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS4E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = StopDeferralTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS4E0Callback() */

/*****************************************************************************/
/** AnStateMachineS4E1Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_DISABLE_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DEFERRED_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS4E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = StopDeferralTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UnlinkPortFromLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS4E1Callback() */

/*****************************************************************************/
/** AnStateMachineS4E6Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DEFERRED_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS4E6Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = StopDeferralTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReleaseSchedBw( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS4E6Callback() */

/*****************************************************************************/
/** AnStateMachineS5E0Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_CONFIG_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_AUTONEG
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS5E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = StopAnWatchDogTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS5E0Callback() */

/*****************************************************************************/
/** AnStateMachineS5E1Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_DISABLE_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_AUTONEG
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS5E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = StopAnWatchDogTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UnlinkPortFromLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS5E1Callback() */

/*****************************************************************************/
/** AnStateMachineS5E2Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOOPBACK_ON_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_AUTONEG
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS5E2Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = AnStart( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = StartAnWatchDogTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS5E2Callback() */

/*****************************************************************************/
/** AnStateMachineS5E3Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOOPBACK_OFF_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_AUTONEG
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS5E3Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = AnStart( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = StartAnWatchDogTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS5E3Callback() */

/*****************************************************************************/
/** AnStateMachineS5E6Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_AUTONEG
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS5E6Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = StopAnWatchDogTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReleaseSchedBw( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS5E6Callback() */

/*****************************************************************************/
/** AnStateMachineS5E22Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_AN_CONFIG_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_AUTONEG
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS5E22Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = AnStart( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = StartAnWatchDogTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS5E22Callback() */

/*****************************************************************************/
/** AnStateMachineS5E23Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_AN_DISABLE_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_AUTONEG
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS5E23Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = StopAnWatchDogTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS5E23Callback() */

/*****************************************************************************/
/** AnStateMachineS6E0Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_CONFIG_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_ADMIN_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS6E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = SetTxFaultModeToNormal( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS6E0Callback() */

/*****************************************************************************/
/** AnStateMachineS6E1Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_DISABLE_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_ADMIN_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS6E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UnlinkPortFromLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS6E1Callback() */

/*****************************************************************************/
/** AnStateMachineS6E5Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_DOWN_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_ADMIN_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS6E5Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS6E5Callback() */

/*****************************************************************************/
/** AnStateMachineS6E6Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_ADMIN_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS6E6Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReleaseSchedBw( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigurePortForAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS6E6Callback() */

/*****************************************************************************/
/** AnStateMachineS6E7Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_REMOTE_FAULT_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_ADMIN_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS6E7Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS6E7Callback() */

/*****************************************************************************/
/** AnStateMachineS6E8Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOCAL_FAULT_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_ADMIN_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS6E8Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS6E8Callback() */

/*****************************************************************************/
/** AnStateMachineS6E9Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_BIST_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_ADMIN_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS6E9Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultModeToNormal( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS6E9Callback() */

/*****************************************************************************/
/** AnStateMachineS6E23Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_AN_DISABLE_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_ADMIN_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS6E23Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS6E23Callback() */

/*****************************************************************************/
/** AnStateMachineS7E0Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_CONFIG_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_LOCAL_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS7E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS7E0Callback() */

/*****************************************************************************/
/** AnStateMachineS7E1Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_DISABLE_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_LOCAL_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS7E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UnlinkPortFromLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS7E1Callback() */

/*****************************************************************************/
/** AnStateMachineS7E5Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_DOWN_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_LOCAL_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS7E5Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS7E5Callback() */

/*****************************************************************************/
/** AnStateMachineS7E6Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_LOCAL_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS7E6Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReleaseSchedBw( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigurePortForAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS7E6Callback() */

/*****************************************************************************/
/** AnStateMachineS7E7Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_REMOTE_FAULT_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_LOCAL_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS7E7Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS7E7Callback() */

/*****************************************************************************/
/** AnStateMachineS7E8Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOCAL_FAULT_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_LOCAL_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS7E8Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS7E8Callback() */

/*****************************************************************************/
/** AnStateMachineS7E9Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_BIST_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_LOCAL_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS7E9Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS7E9Callback() */

/*****************************************************************************/
/** AnStateMachineS7E23Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_AN_DISABLE_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_LOCAL_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS7E23Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS7E23Callback() */

/*****************************************************************************/
/** AnStateMachineS7E20Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LINK_UP_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_LOCAL_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS7E20Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = NotifyApiPortUp( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS7E20Callback() */

/*****************************************************************************/
/** AnStateMachineS8E0Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_CONFIG_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_REMOTE_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS8E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS8E0Callback() */

/*****************************************************************************/
/** AnStateMachineS8E1Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_DISABLE_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_REMOTE_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS8E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UnlinkPortFromLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS8E1Callback() */

/*****************************************************************************/
/** AnStateMachineS8E5Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_DOWN_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_REMOTE_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS8E5Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS8E5Callback() */

/*****************************************************************************/
/** AnStateMachineS8E6Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_REMOTE_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS8E6Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReleaseSchedBw( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigurePortForAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS8E6Callback() */

/*****************************************************************************/
/** AnStateMachineS8E7Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_REMOTE_FAULT_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_REMOTE_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS8E7Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS8E7Callback() */

/*****************************************************************************/
/** AnStateMachineS8E8Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOCAL_FAULT_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_REMOTE_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS8E8Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS8E8Callback() */

/*****************************************************************************/
/** AnStateMachineS8E9Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_BIST_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_REMOTE_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS8E9Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS8E9Callback() */

/*****************************************************************************/
/** AnStateMachineS8E23Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_AN_DISABLE_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_REMOTE_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS8E23Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS8E23Callback() */

/*****************************************************************************/
/** AnStateMachineS8E20Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LINK_UP_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_REMOTE_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS8E20Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = NotifyApiPortUp( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS8E20Callback() */

/*****************************************************************************/
/** AnStateMachineS9E0Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_CONFIG_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_BIST
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS9E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DisableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS9E0Callback() */

/*****************************************************************************/
/** AnStateMachineS9E1Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_DISABLE_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_BIST
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS9E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DisableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UnlinkPortFromLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS9E1Callback() */

/*****************************************************************************/
/** AnStateMachineS9E5Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_DOWN_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_BIST
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS9E5Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS9E5Callback() */

/*****************************************************************************/
/** AnStateMachineS9E6Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_BIST
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS9E6Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DisableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReleaseSchedBw( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigurePortForAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS9E6Callback() */

/*****************************************************************************/
/** AnStateMachineS9E7Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_REMOTE_FAULT_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_BIST
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS9E7Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS9E7Callback() */

/*****************************************************************************/
/** AnStateMachineS9E8Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOCAL_FAULT_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_BIST
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS9E8Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS9E8Callback() */

/*****************************************************************************/
/** AnStateMachineS9E9Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_BIST_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_BIST
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS9E9Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DisableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS9E9Callback() */

/*****************************************************************************/
/** AnStateMachineS9E23Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_AN_DISABLE_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_BIST
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS9E23Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS9E23Callback() */

/*****************************************************************************/
/** AnStateMachineS11E0Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_CONFIG_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS11E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = StopDeferredLpiTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS11E0Callback() */

/*****************************************************************************/
/** AnStateMachineS11E1Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_DISABLE_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS11E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = StopDeferredLpiTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UnlinkPortFromLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS11E1Callback() */

/*****************************************************************************/
/** AnStateMachineS11E5Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_DOWN_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS11E5Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS11E5Callback() */

/*****************************************************************************/
/** AnStateMachineS11E6Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS11E6Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = StopDeferredLpiTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReleaseSchedBw( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigurePortForAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS11E6Callback() */

/*****************************************************************************/
/** AnStateMachineS11E7Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_REMOTE_FAULT_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS11E7Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = StopDeferredLpiTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS11E7Callback() */

/*****************************************************************************/
/** AnStateMachineS11E8Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOCAL_FAULT_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS11E8Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = StopDeferredLpiTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS11E8Callback() */

/*****************************************************************************/
/** AnStateMachineS11E9Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_BIST_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS11E9Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = StopDeferredLpiTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS11E9Callback() */

/*****************************************************************************/
/** AnStateMachineS11E23Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_AN_DISABLE_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS11E23Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS11E23Callback() */

/*****************************************************************************/
/** AnStateMachineS11E11Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_REMOTE_FAULT_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS11E11Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = StopDeferredLpiTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS11E11Callback() */

/*****************************************************************************/
/** AnStateMachineS11E12Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOCAL_FAULT_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS11E12Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = StopDeferredLpiTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS11E12Callback() */

/*****************************************************************************/
/** AnStateMachineS11E28Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_EEE_SILENT_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS11E28Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = EnableLowPowerIdle( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS11E28Callback() */

/*****************************************************************************/
/** AnStateMachineS11E21Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_AN_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_DEFTIMER_EXP_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status AnStateMachineS11E21Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DeferredLpiMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end AnStateMachineS11E21Callback() */

/******************************************************************************
 * Definitions of transition callbacks for FM10000_BASIC_PORT_STATE_MACHINE
 *****************************************************************************/

/*****************************************************************************/
/** BasicStateMachineS0E0Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_CONFIG_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DISABLED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS0E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS0E0Callback() */

/*****************************************************************************/
/** BasicStateMachineS1E0Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_CONFIG_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_NEED_CONFIG
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS1E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = RestoreTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureFarLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS1E0Callback() */

/*****************************************************************************/
/** BasicStateMachineS2E0Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_CONFIG_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_CONFIGURED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS2E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS2E0Callback() */

/*****************************************************************************/
/** BasicStateMachineS2E1Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_DISABLE_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_CONFIGURED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS2E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UnlinkPortFromLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS2E1Callback() */

/*****************************************************************************/
/** BasicStateMachineS2E4Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_UP_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_CONFIGURED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS2E4Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureFarLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UpdateSchedBw( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS2E4Callback() */

/*****************************************************************************/
/** BasicStateMachineS2E5Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_DOWN_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_CONFIGURED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS2E5Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureFarLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UpdateSchedBw( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS2E5Callback() */

/*****************************************************************************/
/** BasicStateMachineS2E7Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_REMOTE_FAULT_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_CONFIGURED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS2E7Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UpdateSchedBw( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS2E7Callback() */

/*****************************************************************************/
/** BasicStateMachineS2E8Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOCAL_FAULT_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_CONFIGURED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS2E8Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UpdateSchedBw( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS2E8Callback() */

/*****************************************************************************/
/** BasicStateMachineS2E9Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_BIST_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_CONFIGURED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS2E9Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UpdateSchedBw( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS2E9Callback() */

/*****************************************************************************/
/** BasicStateMachineS3E0Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_CONFIG_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_POWERING_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS3E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureFarLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS3E0Callback() */

/*****************************************************************************/
/** BasicStateMachineS3E1Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_DISABLE_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_POWERING_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS3E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UnlinkPortFromLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS3E1Callback() */

/*****************************************************************************/
/** BasicStateMachineS3E2Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOOPBACK_ON_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_POWERING_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS3E2Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = EnableLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS3E2Callback() */

/*****************************************************************************/
/** BasicStateMachineS3E3Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOOPBACK_OFF_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_POWERING_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS3E3Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DisableLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS3E3Callback() */

/*****************************************************************************/
/** BasicStateMachineS3E4Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_UP_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_POWERING_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS3E4Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS3E4Callback() */

/*****************************************************************************/
/** BasicStateMachineS3E5Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_DOWN_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_POWERING_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS3E5Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS3E5Callback() */

/*****************************************************************************/
/** BasicStateMachineS3E6Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_POWERING_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS3E6Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReleaseSchedBw( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS3E6Callback() */

/*****************************************************************************/
/** BasicStateMachineS3E7Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_REMOTE_FAULT_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_POWERING_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS3E7Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS3E7Callback() */

/*****************************************************************************/
/** BasicStateMachineS3E8Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOCAL_FAULT_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_POWERING_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS3E8Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS3E8Callback() */

/*****************************************************************************/
/** BasicStateMachineS3E9Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_BIST_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_POWERING_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS3E9Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS3E9Callback() */

/*****************************************************************************/
/** BasicStateMachineS3E10Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_CONFIGURE_DFE_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_POWERING_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS3E10Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = ConfigureDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS3E10Callback() */

/*****************************************************************************/
/** BasicStateMachineS3E18Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LANE_NOT_READY_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_POWERING_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS3E18Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS3E18Callback() */

/*****************************************************************************/
/** BasicStateMachineS4E0Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_CONFIG_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DEFERRED_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS4E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = StopDeferralTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureFarLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS4E0Callback() */

/*****************************************************************************/
/** BasicStateMachineS4E1Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_DISABLE_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DEFERRED_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS4E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = StopDeferralTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UnlinkPortFromLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS4E1Callback() */

/*****************************************************************************/
/** BasicStateMachineS4E2Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOOPBACK_ON_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DEFERRED_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS4E2Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = EnableLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS4E2Callback() */

/*****************************************************************************/
/** BasicStateMachineS4E3Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOOPBACK_OFF_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DEFERRED_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS4E3Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DisableLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS4E3Callback() */

/*****************************************************************************/
/** BasicStateMachineS4E4Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_UP_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DEFERRED_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS4E4Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS4E4Callback() */

/*****************************************************************************/
/** BasicStateMachineS4E5Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_DOWN_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DEFERRED_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS4E5Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS4E5Callback() */

/*****************************************************************************/
/** BasicStateMachineS4E6Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DEFERRED_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS4E6Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = StopDeferralTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReleaseSchedBw( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS4E6Callback() */

/*****************************************************************************/
/** BasicStateMachineS4E7Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_REMOTE_FAULT_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DEFERRED_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS4E7Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS4E7Callback() */

/*****************************************************************************/
/** BasicStateMachineS4E8Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOCAL_FAULT_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DEFERRED_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS4E8Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS4E8Callback() */

/*****************************************************************************/
/** BasicStateMachineS4E9Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_BIST_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DEFERRED_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS4E9Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS4E9Callback() */

/*****************************************************************************/
/** BasicStateMachineS4E10Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_CONFIGURE_DFE_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DEFERRED_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS4E10Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = ConfigureDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS4E10Callback() */

/*****************************************************************************/
/** BasicStateMachineS4E18Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LANE_NOT_READY_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_DEFERRED_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS4E18Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS4E18Callback() */

/*****************************************************************************/
/** BasicStateMachineS6E0Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_CONFIG_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_ADMIN_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS6E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureFarLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS6E0Callback() */

/*****************************************************************************/
/** BasicStateMachineS6E1Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_DISABLE_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_ADMIN_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS6E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UnlinkPortFromLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS6E1Callback() */

/*****************************************************************************/
/** BasicStateMachineS6E5Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_DOWN_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_ADMIN_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS6E5Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS6E5Callback() */

/*****************************************************************************/
/** BasicStateMachineS6E6Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_ADMIN_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS6E6Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReleaseSchedBw( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS6E6Callback() */

/*****************************************************************************/
/** BasicStateMachineS6E7Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_REMOTE_FAULT_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_ADMIN_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS6E7Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS6E7Callback() */

/*****************************************************************************/
/** BasicStateMachineS6E8Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOCAL_FAULT_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_ADMIN_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS6E8Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS6E8Callback() */

/*****************************************************************************/
/** BasicStateMachineS6E9Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_BIST_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_ADMIN_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS6E9Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS6E9Callback() */

/*****************************************************************************/
/** BasicStateMachineS6E10Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_CONFIGURE_DFE_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_ADMIN_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS6E10Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = ConfigureDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS6E10Callback() */

/*****************************************************************************/
/** BasicStateMachineS7E0Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_CONFIG_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_LOCAL_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS7E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureFarLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS7E0Callback() */

/*****************************************************************************/
/** BasicStateMachineS7E1Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_DISABLE_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_LOCAL_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS7E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UnlinkPortFromLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS7E1Callback() */

/*****************************************************************************/
/** BasicStateMachineS7E2Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOOPBACK_ON_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_LOCAL_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS7E2Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = EnableLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS7E2Callback() */

/*****************************************************************************/
/** BasicStateMachineS7E3Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOOPBACK_OFF_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_LOCAL_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS7E3Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DisableLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS7E3Callback() */

/*****************************************************************************/
/** BasicStateMachineS7E26Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_FABRIC_LOOPBACK_ON_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_LOCAL_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS7E26Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DisableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnableDrainMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnableFabricLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisableDrainMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyApiPortUp( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS7E26Callback() */

/*****************************************************************************/
/** BasicStateMachineS7E5Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_DOWN_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_LOCAL_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS7E5Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS7E5Callback() */

/*****************************************************************************/
/** BasicStateMachineS7E6Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_LOCAL_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS7E6Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReleaseSchedBw( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS7E6Callback() */

/*****************************************************************************/
/** BasicStateMachineS7E7Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_REMOTE_FAULT_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_LOCAL_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS7E7Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS7E7Callback() */

/*****************************************************************************/
/** BasicStateMachineS7E8Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOCAL_FAULT_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_LOCAL_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS7E8Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS7E8Callback() */

/*****************************************************************************/
/** BasicStateMachineS7E9Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_BIST_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_LOCAL_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS7E9Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = EnableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS7E9Callback() */

/*****************************************************************************/
/** BasicStateMachineS7E10Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_CONFIGURE_DFE_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_LOCAL_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS7E10Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = ConfigureDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS7E10Callback() */

/*****************************************************************************/
/** BasicStateMachineS7E11Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_REMOTE_FAULT_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_LOCAL_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS7E11Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = EnableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS7E11Callback() */

/*****************************************************************************/
/** BasicStateMachineS7E20Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LINK_UP_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_LOCAL_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS7E20Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = NotifyApiPortUp( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS7E20Callback() */

/*****************************************************************************/
/** BasicStateMachineS8E0Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_CONFIG_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_REMOTE_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS8E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureFarLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS8E0Callback() */

/*****************************************************************************/
/** BasicStateMachineS8E1Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_DISABLE_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_REMOTE_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS8E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UnlinkPortFromLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS8E1Callback() */

/*****************************************************************************/
/** BasicStateMachineS8E2Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOOPBACK_ON_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_REMOTE_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS8E2Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = EnableLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS8E2Callback() */

/*****************************************************************************/
/** BasicStateMachineS8E3Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOOPBACK_OFF_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_REMOTE_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS8E3Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DisableLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS8E3Callback() */

/*****************************************************************************/
/** BasicStateMachineS8E26Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_FABRIC_LOOPBACK_ON_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_REMOTE_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS8E26Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DisableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnableDrainMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnableFabricLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisableDrainMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyApiPortUp( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS8E26Callback() */

/*****************************************************************************/
/** BasicStateMachineS8E5Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_DOWN_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_REMOTE_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS8E5Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS8E5Callback() */

/*****************************************************************************/
/** BasicStateMachineS8E6Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_REMOTE_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS8E6Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReleaseSchedBw( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS8E6Callback() */

/*****************************************************************************/
/** BasicStateMachineS8E7Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_REMOTE_FAULT_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_REMOTE_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS8E7Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS8E7Callback() */

/*****************************************************************************/
/** BasicStateMachineS8E8Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOCAL_FAULT_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_REMOTE_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS8E8Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS8E8Callback() */

/*****************************************************************************/
/** BasicStateMachineS8E9Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_BIST_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_REMOTE_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS8E9Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = EnableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS8E9Callback() */

/*****************************************************************************/
/** BasicStateMachineS8E10Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_CONFIGURE_DFE_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_REMOTE_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS8E10Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = ConfigureDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS8E10Callback() */

/*****************************************************************************/
/** BasicStateMachineS8E20Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LINK_UP_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_REMOTE_FAULT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS8E20Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = NotifyApiPortUp( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS8E20Callback() */

/*****************************************************************************/
/** BasicStateMachineS9E0Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_CONFIG_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_BIST
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS9E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DisableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureFarLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS9E0Callback() */

/*****************************************************************************/
/** BasicStateMachineS9E1Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_DISABLE_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_BIST
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS9E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DisableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UnlinkPortFromLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS9E1Callback() */

/*****************************************************************************/
/** BasicStateMachineS9E2Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOOPBACK_ON_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_BIST
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS9E2Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = EnableLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS9E2Callback() */

/*****************************************************************************/
/** BasicStateMachineS9E3Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOOPBACK_OFF_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_BIST
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS9E3Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DisableLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS9E3Callback() */

/*****************************************************************************/
/** BasicStateMachineS9E5Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_DOWN_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_BIST
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS9E5Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS9E5Callback() */

/*****************************************************************************/
/** BasicStateMachineS9E6Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_BIST
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS9E6Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DisableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReleaseSchedBw( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS9E6Callback() */

/*****************************************************************************/
/** BasicStateMachineS9E7Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_REMOTE_FAULT_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_BIST
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS9E7Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS9E7Callback() */

/*****************************************************************************/
/** BasicStateMachineS9E8Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOCAL_FAULT_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_BIST
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS9E8Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS9E8Callback() */

/*****************************************************************************/
/** BasicStateMachineS9E9Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_BIST_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_BIST
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS9E9Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = EnableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS9E9Callback() */

/*****************************************************************************/
/** BasicStateMachineS9E10Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_CONFIGURE_DFE_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_BIST
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS9E10Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = ConfigureDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS9E10Callback() */

/*****************************************************************************/
/** BasicStateMachineS11E0Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_CONFIG_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS11E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = StopDeferredLpiTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureFarLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS11E0Callback() */

/*****************************************************************************/
/** BasicStateMachineS11E1Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_DISABLE_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS11E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = StopDeferredLpiTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UnlinkPortFromLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS11E1Callback() */

/*****************************************************************************/
/** BasicStateMachineS11E2Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOOPBACK_ON_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS11E2Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = EnableLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS11E2Callback() */

/*****************************************************************************/
/** BasicStateMachineS11E3Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOOPBACK_OFF_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS11E3Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DisableLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS11E3Callback() */

/*****************************************************************************/
/** BasicStateMachineS11E26Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_FABRIC_LOOPBACK_ON_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS11E26Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DisableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnableDrainMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnableFabricLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisableDrainMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS11E26Callback() */

/*****************************************************************************/
/** BasicStateMachineS11E5Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_DOWN_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS11E5Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = StopDeferredLpiTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS11E5Callback() */

/*****************************************************************************/
/** BasicStateMachineS11E6Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS11E6Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = StopDeferredLpiTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReleaseSchedBw( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS11E6Callback() */

/*****************************************************************************/
/** BasicStateMachineS11E7Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_REMOTE_FAULT_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS11E7Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = StopDeferredLpiTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS11E7Callback() */

/*****************************************************************************/
/** BasicStateMachineS11E8Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOCAL_FAULT_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS11E8Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = StopDeferredLpiTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS11E8Callback() */

/*****************************************************************************/
/** BasicStateMachineS11E9Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_BIST_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS11E9Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = StopDeferredLpiTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS11E9Callback() */

/*****************************************************************************/
/** BasicStateMachineS11E10Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_CONFIGURE_DFE_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS11E10Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = StopDeferredLpiTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ConfigureDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS11E10Callback() */

/*****************************************************************************/
/** BasicStateMachineS11E11Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_REMOTE_FAULT_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS11E11Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = StopDeferredLpiTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS11E11Callback() */

/*****************************************************************************/
/** BasicStateMachineS11E12Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOCAL_FAULT_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS11E12Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = StopDeferredLpiTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS11E12Callback() */

/*****************************************************************************/
/** BasicStateMachineS11E28Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_EEE_SILENT_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS11E28Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = EnableLowPowerIdle( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS11E28Callback() */

/*****************************************************************************/
/** BasicStateMachineS11E21Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_BASIC_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_DEFTIMER_EXP_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status BasicStateMachineS11E21Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DeferredLpiMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end BasicStateMachineS11E21Callback() */

/******************************************************************************
 * Definitions of transition callbacks for FM10000_PCIE_PORT_STATE_MACHINE
 *****************************************************************************/

/*****************************************************************************/
/** PcieStateMachineS0E20Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LINK_UP_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_DISABLED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS0E20Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = EnablePcieInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS0E20Callback() */

/*****************************************************************************/
/** PcieStateMachineS0E19Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LINK_DOWN_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_DISABLED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS0E19Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = EnablePcieInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS0E19Callback() */

/*****************************************************************************/
/** PcieStateMachineS0E2Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOOPBACK_ON_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DISABLED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS0E2Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS0E2Callback() */

/*****************************************************************************/
/** PcieStateMachineS0E3Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOOPBACK_OFF_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DISABLED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS0E3Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS0E3Callback() */

/*****************************************************************************/
/** PcieStateMachineS0E4Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_UP_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DISABLED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS0E4Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS0E4Callback() */

/*****************************************************************************/
/** PcieStateMachineS0E5Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_DOWN_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DISABLED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS0E5Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS0E5Callback() */

/*****************************************************************************/
/** PcieStateMachineS0E6Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DISABLED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS0E6Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS0E6Callback() */

/*****************************************************************************/
/** PcieStateMachineS0E7Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_REMOTE_FAULT_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DISABLED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS0E7Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS0E7Callback() */

/*****************************************************************************/
/** PcieStateMachineS0E8Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOCAL_FAULT_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DISABLED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS0E8Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS0E8Callback() */

/*****************************************************************************/
/** PcieStateMachineS0E9Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_BIST_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DISABLED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS0E9Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS0E9Callback() */

/*****************************************************************************/
/** PcieStateMachineS0E11Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_REMOTE_FAULT_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_DISABLED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS0E11Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS0E11Callback() */

/*****************************************************************************/
/** PcieStateMachineS0E12Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOCAL_FAULT_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_DISABLED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS0E12Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS0E12Callback() */

/*****************************************************************************/
/** PcieStateMachineS0E13Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LANE_DFE_COMPLETE_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_DISABLED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS0E13Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS0E13Callback() */

/*****************************************************************************/
/** PcieStateMachineS0E14Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LANE_DFE_FAILED_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_DISABLED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS0E14Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS0E14Callback() */

/*****************************************************************************/
/** PcieStateMachineS0E15Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LANE_KR_COMPLETE_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_DISABLED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS0E15Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS0E15Callback() */

/*****************************************************************************/
/** PcieStateMachineS0E16Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LANE_KR_FAILED_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_DISABLED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS0E16Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS0E16Callback() */

/*****************************************************************************/
/** PcieStateMachineS0E17Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LANE_READY_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_DISABLED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS0E17Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS0E17Callback() */

/*****************************************************************************/
/** PcieStateMachineS0E18Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LANE_NOT_READY_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_DISABLED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS0E18Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS0E18Callback() */

/*****************************************************************************/
/** PcieStateMachineS0E21Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_DEFTIMER_EXP_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_DISABLED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS0E21Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS0E21Callback() */

/*****************************************************************************/
/** PcieStateMachineS10E0Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_CONFIG_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DOWN
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS10E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS10E0Callback() */

/*****************************************************************************/
/** PcieStateMachineS10E1Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_DISABLE_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DOWN
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS10E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UnlinkPortFromLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePcieInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePepLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS10E1Callback() */

/*****************************************************************************/
/** PcieStateMachineS10E20Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LINK_UP_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_DOWN
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS10E20Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = InitPepMailbox( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePepLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UpdatePcieModeAndSpeed( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UpdatePcieLanePolarity( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UpdatePcieLaneReversal( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyApiPortUp( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePcieInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS10E20Callback() */

/*****************************************************************************/
/** PcieStateMachineS10E19Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LINK_DOWN_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_DOWN
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS10E19Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = EnablePcieInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS10E19Callback() */

/*****************************************************************************/
/** PcieStateMachineS10E2Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOOPBACK_ON_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DOWN
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS10E2Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS10E2Callback() */

/*****************************************************************************/
/** PcieStateMachineS10E3Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOOPBACK_OFF_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DOWN
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS10E3Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS10E3Callback() */

/*****************************************************************************/
/** PcieStateMachineS10E4Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_UP_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DOWN
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS10E4Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS10E4Callback() */

/*****************************************************************************/
/** PcieStateMachineS10E5Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_DOWN_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DOWN
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS10E5Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS10E5Callback() */

/*****************************************************************************/
/** PcieStateMachineS10E6Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DOWN
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS10E6Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS10E6Callback() */

/*****************************************************************************/
/** PcieStateMachineS10E7Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_REMOTE_FAULT_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DOWN
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS10E7Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS10E7Callback() */

/*****************************************************************************/
/** PcieStateMachineS10E8Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOCAL_FAULT_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DOWN
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS10E8Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS10E8Callback() */

/*****************************************************************************/
/** PcieStateMachineS10E9Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_BIST_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DOWN
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS10E9Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS10E9Callback() */

/*****************************************************************************/
/** PcieStateMachineS10E11Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_REMOTE_FAULT_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_DOWN
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS10E11Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS10E11Callback() */

/*****************************************************************************/
/** PcieStateMachineS10E12Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOCAL_FAULT_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_DOWN
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS10E12Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS10E12Callback() */

/*****************************************************************************/
/** PcieStateMachineS10E13Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LANE_DFE_COMPLETE_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_DOWN
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS10E13Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS10E13Callback() */

/*****************************************************************************/
/** PcieStateMachineS10E14Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LANE_DFE_FAILED_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_DOWN
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS10E14Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS10E14Callback() */

/*****************************************************************************/
/** PcieStateMachineS10E15Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LANE_KR_COMPLETE_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_DOWN
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS10E15Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS10E15Callback() */

/*****************************************************************************/
/** PcieStateMachineS10E16Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LANE_KR_FAILED_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_DOWN
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS10E16Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS10E16Callback() */

/*****************************************************************************/
/** PcieStateMachineS10E17Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LANE_READY_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_DOWN
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS10E17Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS10E17Callback() */

/*****************************************************************************/
/** PcieStateMachineS10E18Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LANE_NOT_READY_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_DOWN
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS10E18Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS10E18Callback() */

/*****************************************************************************/
/** PcieStateMachineS10E21Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_DEFTIMER_EXP_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_DOWN
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS10E21Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS10E21Callback() */

/*****************************************************************************/
/** PcieStateMachineS10E26Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_FABRIC_LOOPBACK_ON_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DOWN
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS10E26Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = EnablePepLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyApiPortUp( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS10E26Callback() */

/*****************************************************************************/
/** PcieStateMachineS10E27Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_FABRIC_LOOPBACK_OFF_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_DOWN
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS10E27Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DisablePepLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS10E27Callback() */

/*****************************************************************************/
/** PcieStateMachineS11E0Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_CONFIG_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS11E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS11E0Callback() */

/*****************************************************************************/
/** PcieStateMachineS11E1Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_DISABLE_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS11E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UnlinkPortFromLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePcieInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = DisablePepLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS11E1Callback() */

/*****************************************************************************/
/** PcieStateMachineS11E20Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LINK_UP_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS11E20Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = UpdatePcieModeAndSpeed( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UpdatePcieLanePolarity( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UpdatePcieLaneReversal( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePcieInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS11E20Callback() */

/*****************************************************************************/
/** PcieStateMachineS11E19Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LINK_DOWN_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS11E19Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = UpdatePcieModeAndSpeed( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UpdatePcieLanePolarity( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = UpdatePcieLaneReversal( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
    status = EnablePcieInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS11E19Callback() */

/*****************************************************************************/
/** PcieStateMachineS11E2Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOOPBACK_ON_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS11E2Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS11E2Callback() */

/*****************************************************************************/
/** PcieStateMachineS11E3Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOOPBACK_OFF_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS11E3Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS11E3Callback() */

/*****************************************************************************/
/** PcieStateMachineS11E4Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_UP_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS11E4Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS11E4Callback() */

/*****************************************************************************/
/** PcieStateMachineS11E5Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_DOWN_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS11E5Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS11E5Callback() */

/*****************************************************************************/
/** PcieStateMachineS11E6Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS11E6Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS11E6Callback() */

/*****************************************************************************/
/** PcieStateMachineS11E7Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_REMOTE_FAULT_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS11E7Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS11E7Callback() */

/*****************************************************************************/
/** PcieStateMachineS11E8Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOCAL_FAULT_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS11E8Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS11E8Callback() */

/*****************************************************************************/
/** PcieStateMachineS11E9Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_BIST_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS11E9Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS11E9Callback() */

/*****************************************************************************/
/** PcieStateMachineS11E11Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_REMOTE_FAULT_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS11E11Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS11E11Callback() */

/*****************************************************************************/
/** PcieStateMachineS11E12Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LOCAL_FAULT_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS11E12Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS11E12Callback() */

/*****************************************************************************/
/** PcieStateMachineS11E13Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LANE_DFE_COMPLETE_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS11E13Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS11E13Callback() */

/*****************************************************************************/
/** PcieStateMachineS11E14Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LANE_DFE_FAILED_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS11E14Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS11E14Callback() */

/*****************************************************************************/
/** PcieStateMachineS11E15Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LANE_KR_COMPLETE_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS11E15Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS11E15Callback() */

/*****************************************************************************/
/** PcieStateMachineS11E16Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LANE_KR_FAILED_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS11E16Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS11E16Callback() */

/*****************************************************************************/
/** PcieStateMachineS11E17Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LANE_READY_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS11E17Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS11E17Callback() */

/*****************************************************************************/
/** PcieStateMachineS11E18Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_LANE_NOT_READY_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS11E18Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS11E18Callback() */

/*****************************************************************************/
/** PcieStateMachineS11E21Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_DEFTIMER_EXP_IND'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS11E21Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS11E21Callback() */

/*****************************************************************************/
/** PcieStateMachineS11E26Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_FABRIC_LOOPBACK_ON_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS11E26Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = EnablePepLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS11E26Callback() */

/*****************************************************************************/
/** PcieStateMachineS11E27Callback
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for port state machine type
 *                  ''FM10000_PCIE_PORT_STATE_MACHINE'', when event
 *                  ''FM10000_PORT_EVENT_FABRIC_LOOPBACK_OFF_REQ'' occurs in state
 *                  ''FM10000_PORT_STATE_UP
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status PcieStateMachineS11E27Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;
        
    status = DisablePepLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );
            
ABORT:
    return status;

}   /* end PcieStateMachineS11E27Callback() */


/*****************************************************************************
 * Public Functions
 *****************************************************************************/


/*****************************************************************************/
/** fm10000RegisterAnPortStateMachine
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            This function registers with the Generic State Machine
 *                  Engine state machine type ''FM10000_AN_PORT_STATE_MACHINE''
 * 
 * \return          FM_OK if the state machine was created successfully
 * 
 * \return          FM_ERR_INVALID_ARGUMENT if one of the arguments is invalid
 *
 * \return          FM_ERR_NO_MEM if there was a memory allocation failure
 *                  while creating one of the state machine internal structures
 * 
 * \return          FM_ERR_STATE_MACHINE_TYPE if this state machine type is
 *                  already registered 
 *
 *****************************************************************************/
fm_status fm10000RegisterAnPortStateMachine( void )
{
    fm_int      i;
    fm_status   status;
    fm_smTransitionEntry  stt[FM10000_PORT_STATE_MAX][FM10000_PORT_EVENT_MAX];
    fm_smTransitionEntry *dynstt[FM10000_PORT_STATE_MAX];
    fm_smTransitionLogCallback logCallback;

    
    /* log callback for this type */
    logCallback = fm10000LogPortStateTransition;
    

    /* clear out the temporary state transition table */
    FM_MEMSET_S( stt, sizeof(stt), 0, sizeof(stt));

    /* transition for state=PORT_STATE_DISABLED(0), event=PORT_EVENT_CONFIG_REQ(0) */
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_CONFIG_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_CONFIG_REQ].nextState = FM10000_PORT_STATE_CONFIGURED;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_CONFIG_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_CONFIG_REQ].transitionCallback = AnStateMachineS0E0Callback;

    /* transition for state=PORT_STATE_DISABLED(0), event=PORT_EVENT_ADMIN_UP_REQ(4) */
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].nextState = FM10000_PORT_STATE_NEED_CONFIG;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].transitionCallback = NULL;

    /* transition for state=PORT_STATE_DISABLED(0), event=PORT_EVENT_ADMIN_DOWN_REQ(5) */
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].nextState = FM10000_PORT_STATE_NEED_CONFIG;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].transitionCallback = NULL;

    /* transition for state=PORT_STATE_DISABLED(0), event=PORT_EVENT_REMOTE_FAULT_REQ(7) */
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].nextState = FM10000_PORT_STATE_NEED_CONFIG;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].transitionCallback = NULL;

    /* transition for state=PORT_STATE_DISABLED(0), event=PORT_EVENT_LOCAL_FAULT_REQ(8) */
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].nextState = FM10000_PORT_STATE_NEED_CONFIG;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].transitionCallback = NULL;

    /* transition for state=PORT_STATE_DISABLED(0), event=PORT_EVENT_BIST_REQ(9) */
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_BIST_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_BIST_REQ].nextState = FM10000_PORT_STATE_NEED_CONFIG;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_BIST_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_BIST_REQ].transitionCallback = NULL;

    /* transition for state=PORT_STATE_NEED_CONFIG(1), event=PORT_EVENT_CONFIG_REQ(0) */
    stt[FM10000_PORT_STATE_NEED_CONFIG]
       [FM10000_PORT_EVENT_CONFIG_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_NEED_CONFIG]
       [FM10000_PORT_EVENT_CONFIG_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_NEED_CONFIG]
       [FM10000_PORT_EVENT_CONFIG_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_NEED_CONFIG]
       [FM10000_PORT_EVENT_CONFIG_REQ].transitionCallback = AnStateMachineS1E0Callback;

    /* transition for state=PORT_STATE_NEED_CONFIG(1), event=PORT_EVENT_ADMIN_PWRDOWN_REQ(6) */
    stt[FM10000_PORT_STATE_NEED_CONFIG]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_NEED_CONFIG]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].nextState = FM10000_PORT_STATE_DISABLED;
    stt[FM10000_PORT_STATE_NEED_CONFIG]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_NEED_CONFIG]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].transitionCallback = NULL;

    /* transition for state=PORT_STATE_CONFIGURED(2), event=PORT_EVENT_CONFIG_REQ(0) */
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_CONFIG_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_CONFIG_REQ].nextState = FM10000_PORT_STATE_CONFIGURED;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_CONFIG_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_CONFIG_REQ].transitionCallback = AnStateMachineS2E0Callback;

    /* transition for state=PORT_STATE_CONFIGURED(2), event=PORT_EVENT_DISABLE_REQ(1) */
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_DISABLE_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_DISABLE_REQ].nextState = FM10000_PORT_STATE_DISABLED;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_DISABLE_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_DISABLE_REQ].transitionCallback = AnStateMachineS2E1Callback;

    /* transition for state=PORT_STATE_CONFIGURED(2), event=PORT_EVENT_ADMIN_UP_REQ(4) */
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].transitionCallback = AnStateMachineS2E4Callback;

    /* transition for state=PORT_STATE_CONFIGURED(2), event=PORT_EVENT_ADMIN_DOWN_REQ(5) */
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].transitionCallback = AnStateMachineS2E5Callback;

    /* transition for state=PORT_STATE_CONFIGURED(2), event=PORT_EVENT_REMOTE_FAULT_REQ(7) */
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].transitionCallback = AnStateMachineS2E7Callback;

    /* transition for state=PORT_STATE_CONFIGURED(2), event=PORT_EVENT_LOCAL_FAULT_REQ(8) */
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].transitionCallback = AnStateMachineS2E8Callback;

    /* transition for state=PORT_STATE_CONFIGURED(2), event=PORT_EVENT_BIST_REQ(9) */
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_BIST_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_BIST_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_BIST_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_BIST_REQ].transitionCallback = AnStateMachineS2E9Callback;

    /* transition for state=PORT_STATE_POWERING_UP(3), event=PORT_EVENT_CONFIG_REQ(0) */
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_CONFIG_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_CONFIG_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_CONFIG_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_CONFIG_REQ].transitionCallback = AnStateMachineS3E0Callback;

    /* transition for state=PORT_STATE_POWERING_UP(3), event=PORT_EVENT_DISABLE_REQ(1) */
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_DISABLE_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_DISABLE_REQ].nextState = FM10000_PORT_STATE_NEED_CONFIG;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_DISABLE_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_DISABLE_REQ].transitionCallback = AnStateMachineS3E1Callback;

    /* transition for state=PORT_STATE_POWERING_UP(3), event=PORT_EVENT_ADMIN_PWRDOWN_REQ(6) */
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].nextState = FM10000_PORT_STATE_CONFIGURED;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].transitionCallback = AnStateMachineS3E6Callback;

    /* transition for state=PORT_STATE_POWERING_UP(3), event=PORT_EVENT_LANE_READY_IND(17) */
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_LANE_READY_IND].used = TRUE;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_LANE_READY_IND].nextState = FM_STATE_UNSPECIFIED;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_LANE_READY_IND].conditionCallback = CheckLanesReady;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_LANE_READY_IND].transitionCallback = NULL;

    /* transition for state=PORT_STATE_POWERING_UP(3), event=PORT_EVENT_LANE_NOT_READY_IND(18) */
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_LANE_NOT_READY_IND].used = TRUE;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_LANE_NOT_READY_IND].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_LANE_NOT_READY_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_LANE_NOT_READY_IND].transitionCallback = AnStateMachineS3E18Callback;

    /* transition for state=PORT_STATE_POWERING_UP(3), event=PORT_EVENT_AN_RESTARTED_IND(25) */
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_AN_RESTARTED_IND].used = TRUE;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_AN_RESTARTED_IND].nextState = FM_STATE_UNSPECIFIED;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_AN_RESTARTED_IND].conditionCallback = AnRestart;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_AN_RESTARTED_IND].transitionCallback = NULL;

    /* transition for state=PORT_STATE_DEFERRED_UP(4), event=PORT_EVENT_CONFIG_REQ(0) */
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_CONFIG_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_CONFIG_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_CONFIG_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_CONFIG_REQ].transitionCallback = AnStateMachineS4E0Callback;

    /* transition for state=PORT_STATE_DEFERRED_UP(4), event=PORT_EVENT_DISABLE_REQ(1) */
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_DISABLE_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_DISABLE_REQ].nextState = FM10000_PORT_STATE_NEED_CONFIG;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_DISABLE_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_DISABLE_REQ].transitionCallback = AnStateMachineS4E1Callback;

    /* transition for state=PORT_STATE_DEFERRED_UP(4), event=PORT_EVENT_ADMIN_PWRDOWN_REQ(6) */
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].nextState = FM10000_PORT_STATE_CONFIGURED;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].transitionCallback = AnStateMachineS4E6Callback;

    /* transition for state=PORT_STATE_DEFERRED_UP(4), event=PORT_EVENT_DEFTIMER_EXP_IND(21) */
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_DEFTIMER_EXP_IND].used = TRUE;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_DEFTIMER_EXP_IND].nextState = FM_STATE_UNSPECIFIED;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_DEFTIMER_EXP_IND].conditionCallback = ProcessDeferralTimerWithAn;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_DEFTIMER_EXP_IND].transitionCallback = NULL;

    /* transition for state=PORT_STATE_DEFERRED_UP(4), event=PORT_EVENT_AN_RESTARTED_IND(25) */
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_AN_RESTARTED_IND].used = TRUE;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_AN_RESTARTED_IND].nextState = FM_STATE_UNSPECIFIED;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_AN_RESTARTED_IND].conditionCallback = AnRestart;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_AN_RESTARTED_IND].transitionCallback = NULL;

    /* transition for state=PORT_STATE_DEFERRED_UP(4), event=PORT_EVENT_LINK_DOWN_IND(19) */
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LINK_DOWN_IND].used = TRUE;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LINK_DOWN_IND].nextState = FM10000_PORT_STATE_DEFERRED_UP;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LINK_DOWN_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LINK_DOWN_IND].transitionCallback = NULL;

    /* transition for state=PORT_STATE_DEFERRED_UP(4), event=PORT_EVENT_LINK_UP_IND(20) */
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LINK_UP_IND].used = TRUE;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LINK_UP_IND].nextState = FM10000_PORT_STATE_DEFERRED_UP;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LINK_UP_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LINK_UP_IND].transitionCallback = NULL;

    /* transition for state=PORT_STATE_DEFERRED_UP(4), event=PORT_EVENT_REMOTE_FAULT_IND(11) */
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].used = TRUE;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].nextState = FM10000_PORT_STATE_DEFERRED_UP;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].transitionCallback = NULL;

    /* transition for state=PORT_STATE_DEFERRED_UP(4), event=PORT_EVENT_LOCAL_FAULT_IND(12) */
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].used = TRUE;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].nextState = FM10000_PORT_STATE_DEFERRED_UP;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].transitionCallback = NULL;

    /* transition for state=PORT_STATE_AUTONEG(5), event=PORT_EVENT_CONFIG_REQ(0) */
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_CONFIG_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_CONFIG_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_CONFIG_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_CONFIG_REQ].transitionCallback = AnStateMachineS5E0Callback;

    /* transition for state=PORT_STATE_AUTONEG(5), event=PORT_EVENT_DISABLE_REQ(1) */
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_DISABLE_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_DISABLE_REQ].nextState = FM10000_PORT_STATE_NEED_CONFIG;
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_DISABLE_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_DISABLE_REQ].transitionCallback = AnStateMachineS5E1Callback;

    /* transition for state=PORT_STATE_AUTONEG(5), event=PORT_EVENT_LOOPBACK_ON_REQ(2) */
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].nextState = FM10000_PORT_STATE_AUTONEG;
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].transitionCallback = AnStateMachineS5E2Callback;

    /* transition for state=PORT_STATE_AUTONEG(5), event=PORT_EVENT_LOOPBACK_OFF_REQ(3) */
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].nextState = FM10000_PORT_STATE_AUTONEG;
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].transitionCallback = AnStateMachineS5E3Callback;

    /* transition for state=PORT_STATE_AUTONEG(5), event=PORT_EVENT_ADMIN_PWRDOWN_REQ(6) */
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].nextState = FM10000_PORT_STATE_CONFIGURED;
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].transitionCallback = AnStateMachineS5E6Callback;

    /* transition for state=PORT_STATE_AUTONEG(5), event=PORT_EVENT_AN_CONFIG_REQ(22) */
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_AN_CONFIG_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_AN_CONFIG_REQ].nextState = FM10000_PORT_STATE_AUTONEG;
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_AN_CONFIG_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_AN_CONFIG_REQ].transitionCallback = AnStateMachineS5E22Callback;

    /* transition for state=PORT_STATE_AUTONEG(5), event=PORT_EVENT_DEFTIMER_EXP_IND(21) */
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_DEFTIMER_EXP_IND].used = TRUE;
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_DEFTIMER_EXP_IND].nextState = FM_STATE_UNSPECIFIED;
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_DEFTIMER_EXP_IND].conditionCallback = AnRestart;
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_DEFTIMER_EXP_IND].transitionCallback = NULL;

    /* transition for state=PORT_STATE_AUTONEG(5), event=PORT_EVENT_AN_DISABLE_REQ(23) */
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_AN_DISABLE_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_AN_DISABLE_REQ].nextState = FM10000_PORT_STATE_AUTONEG;
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_AN_DISABLE_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_AN_DISABLE_REQ].transitionCallback = AnStateMachineS5E23Callback;

    /* transition for state=PORT_STATE_AUTONEG(5), event=PORT_EVENT_AN_COMPLETE_IND(24) */
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_AN_COMPLETE_IND].used = TRUE;
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_AN_COMPLETE_IND].nextState = FM_STATE_UNSPECIFIED;
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_AN_COMPLETE_IND].conditionCallback = EnterNegotiatedMode;
    stt[FM10000_PORT_STATE_AUTONEG]
       [FM10000_PORT_EVENT_AN_COMPLETE_IND].transitionCallback = NULL;

    /* transition for state=PORT_STATE_ADMIN_FAULT(6), event=PORT_EVENT_CONFIG_REQ(0) */
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_CONFIG_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_CONFIG_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_CONFIG_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_CONFIG_REQ].transitionCallback = AnStateMachineS6E0Callback;

    /* transition for state=PORT_STATE_ADMIN_FAULT(6), event=PORT_EVENT_DISABLE_REQ(1) */
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_DISABLE_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_DISABLE_REQ].nextState = FM10000_PORT_STATE_NEED_CONFIG;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_DISABLE_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_DISABLE_REQ].transitionCallback = AnStateMachineS6E1Callback;

    /* transition for state=PORT_STATE_ADMIN_FAULT(6), event=PORT_EVENT_ADMIN_UP_REQ(4) */
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].nextState = FM_STATE_UNSPECIFIED;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].conditionCallback = AnRestart;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].transitionCallback = NULL;

    /* transition for state=PORT_STATE_ADMIN_FAULT(6), event=PORT_EVENT_ADMIN_DOWN_REQ(5) */
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].nextState = FM10000_PORT_STATE_ADMIN_FAULT;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].transitionCallback = AnStateMachineS6E5Callback;

    /* transition for state=PORT_STATE_ADMIN_FAULT(6), event=PORT_EVENT_ADMIN_PWRDOWN_REQ(6) */
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].nextState = FM10000_PORT_STATE_CONFIGURED;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].transitionCallback = AnStateMachineS6E6Callback;

    /* transition for state=PORT_STATE_ADMIN_FAULT(6), event=PORT_EVENT_REMOTE_FAULT_REQ(7) */
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].nextState = FM10000_PORT_STATE_ADMIN_FAULT;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].transitionCallback = AnStateMachineS6E7Callback;

    /* transition for state=PORT_STATE_ADMIN_FAULT(6), event=PORT_EVENT_LOCAL_FAULT_REQ(8) */
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].nextState = FM10000_PORT_STATE_ADMIN_FAULT;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].transitionCallback = AnStateMachineS6E8Callback;

    /* transition for state=PORT_STATE_ADMIN_FAULT(6), event=PORT_EVENT_BIST_REQ(9) */
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_BIST_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_BIST_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_BIST_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_BIST_REQ].transitionCallback = AnStateMachineS6E9Callback;

    /* transition for state=PORT_STATE_ADMIN_FAULT(6), event=PORT_EVENT_AN_CONFIG_REQ(22) */
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_AN_CONFIG_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_AN_CONFIG_REQ].nextState = FM_STATE_UNSPECIFIED;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_AN_CONFIG_REQ].conditionCallback = AnRestart;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_AN_CONFIG_REQ].transitionCallback = NULL;

    /* transition for state=PORT_STATE_ADMIN_FAULT(6), event=PORT_EVENT_AN_DISABLE_REQ(23) */
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_AN_DISABLE_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_AN_DISABLE_REQ].nextState = FM10000_PORT_STATE_ADMIN_FAULT;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_AN_DISABLE_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_AN_DISABLE_REQ].transitionCallback = AnStateMachineS6E23Callback;

    /* transition for state=PORT_STATE_ADMIN_FAULT(6), event=PORT_EVENT_AN_RESTARTED_IND(25) */
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_AN_RESTARTED_IND].used = TRUE;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_AN_RESTARTED_IND].nextState = FM_STATE_UNSPECIFIED;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_AN_RESTARTED_IND].conditionCallback = AnRestart;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_AN_RESTARTED_IND].transitionCallback = NULL;

    /* transition for state=PORT_STATE_LOCAL_FAULT(7), event=PORT_EVENT_CONFIG_REQ(0) */
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_CONFIG_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_CONFIG_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_CONFIG_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_CONFIG_REQ].transitionCallback = AnStateMachineS7E0Callback;

    /* transition for state=PORT_STATE_LOCAL_FAULT(7), event=PORT_EVENT_DISABLE_REQ(1) */
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_DISABLE_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_DISABLE_REQ].nextState = FM10000_PORT_STATE_NEED_CONFIG;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_DISABLE_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_DISABLE_REQ].transitionCallback = AnStateMachineS7E1Callback;

    /* transition for state=PORT_STATE_LOCAL_FAULT(7), event=PORT_EVENT_LOOPBACK_ON_REQ(2) */
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].nextState = FM_STATE_UNSPECIFIED;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].conditionCallback = AnRestart;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].transitionCallback = NULL;

    /* transition for state=PORT_STATE_LOCAL_FAULT(7), event=PORT_EVENT_LOOPBACK_OFF_REQ(3) */
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].nextState = FM_STATE_UNSPECIFIED;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].conditionCallback = AnRestart;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].transitionCallback = NULL;

    /* transition for state=PORT_STATE_LOCAL_FAULT(7), event=PORT_EVENT_ADMIN_DOWN_REQ(5) */
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].nextState = FM10000_PORT_STATE_ADMIN_FAULT;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].transitionCallback = AnStateMachineS7E5Callback;

    /* transition for state=PORT_STATE_LOCAL_FAULT(7), event=PORT_EVENT_ADMIN_PWRDOWN_REQ(6) */
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].nextState = FM10000_PORT_STATE_CONFIGURED;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].transitionCallback = AnStateMachineS7E6Callback;

    /* transition for state=PORT_STATE_LOCAL_FAULT(7), event=PORT_EVENT_REMOTE_FAULT_REQ(7) */
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].nextState = FM10000_PORT_STATE_ADMIN_FAULT;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].transitionCallback = AnStateMachineS7E7Callback;

    /* transition for state=PORT_STATE_LOCAL_FAULT(7), event=PORT_EVENT_LOCAL_FAULT_REQ(8) */
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].nextState = FM10000_PORT_STATE_ADMIN_FAULT;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].transitionCallback = AnStateMachineS7E8Callback;

    /* transition for state=PORT_STATE_LOCAL_FAULT(7), event=PORT_EVENT_BIST_REQ(9) */
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_BIST_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_BIST_REQ].nextState = FM10000_PORT_STATE_BIST;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_BIST_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_BIST_REQ].transitionCallback = AnStateMachineS7E9Callback;

    /* transition for state=PORT_STATE_LOCAL_FAULT(7), event=PORT_EVENT_AN_CONFIG_REQ(22) */
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_AN_CONFIG_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_AN_CONFIG_REQ].nextState = FM_STATE_UNSPECIFIED;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_AN_CONFIG_REQ].conditionCallback = AnRestart;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_AN_CONFIG_REQ].transitionCallback = NULL;

    /* transition for state=PORT_STATE_LOCAL_FAULT(7), event=PORT_EVENT_AN_DISABLE_REQ(23) */
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_AN_DISABLE_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_AN_DISABLE_REQ].nextState = FM10000_PORT_STATE_LOCAL_FAULT;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_AN_DISABLE_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_AN_DISABLE_REQ].transitionCallback = AnStateMachineS7E23Callback;

    /* transition for state=PORT_STATE_LOCAL_FAULT(7), event=PORT_EVENT_REMOTE_FAULT_IND(11) */
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].used = TRUE;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].nextState = FM10000_PORT_STATE_REMOTE_FAULT;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].transitionCallback = NULL;

    /* transition for state=PORT_STATE_LOCAL_FAULT(7), event=PORT_EVENT_LINK_UP_IND(20) */
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_LINK_UP_IND].used = TRUE;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_LINK_UP_IND].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_LINK_UP_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_LINK_UP_IND].transitionCallback = AnStateMachineS7E20Callback;

    /* transition for state=PORT_STATE_LOCAL_FAULT(7), event=PORT_EVENT_AN_RESTARTED_IND(25) */
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_AN_RESTARTED_IND].used = TRUE;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_AN_RESTARTED_IND].nextState = FM_STATE_UNSPECIFIED;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_AN_RESTARTED_IND].conditionCallback = AnRestart;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_AN_RESTARTED_IND].transitionCallback = NULL;

    /* transition for state=PORT_STATE_REMOTE_FAULT(8), event=PORT_EVENT_CONFIG_REQ(0) */
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_CONFIG_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_CONFIG_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_CONFIG_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_CONFIG_REQ].transitionCallback = AnStateMachineS8E0Callback;

    /* transition for state=PORT_STATE_REMOTE_FAULT(8), event=PORT_EVENT_DISABLE_REQ(1) */
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_DISABLE_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_DISABLE_REQ].nextState = FM10000_PORT_STATE_NEED_CONFIG;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_DISABLE_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_DISABLE_REQ].transitionCallback = AnStateMachineS8E1Callback;

    /* transition for state=PORT_STATE_REMOTE_FAULT(8), event=PORT_EVENT_LOOPBACK_ON_REQ(2) */
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].nextState = FM_STATE_UNSPECIFIED;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].conditionCallback = AnRestart;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].transitionCallback = NULL;

    /* transition for state=PORT_STATE_REMOTE_FAULT(8), event=PORT_EVENT_LOOPBACK_OFF_REQ(3) */
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].nextState = FM_STATE_UNSPECIFIED;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].conditionCallback = AnRestart;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].transitionCallback = NULL;

    /* transition for state=PORT_STATE_REMOTE_FAULT(8), event=PORT_EVENT_ADMIN_DOWN_REQ(5) */
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].nextState = FM10000_PORT_STATE_ADMIN_FAULT;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].transitionCallback = AnStateMachineS8E5Callback;

    /* transition for state=PORT_STATE_REMOTE_FAULT(8), event=PORT_EVENT_ADMIN_PWRDOWN_REQ(6) */
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].nextState = FM10000_PORT_STATE_CONFIGURED;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].transitionCallback = AnStateMachineS8E6Callback;

    /* transition for state=PORT_STATE_REMOTE_FAULT(8), event=PORT_EVENT_REMOTE_FAULT_REQ(7) */
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].nextState = FM10000_PORT_STATE_ADMIN_FAULT;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].transitionCallback = AnStateMachineS8E7Callback;

    /* transition for state=PORT_STATE_REMOTE_FAULT(8), event=PORT_EVENT_LOCAL_FAULT_REQ(8) */
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].nextState = FM10000_PORT_STATE_ADMIN_FAULT;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].transitionCallback = AnStateMachineS8E8Callback;

    /* transition for state=PORT_STATE_REMOTE_FAULT(8), event=PORT_EVENT_BIST_REQ(9) */
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_BIST_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_BIST_REQ].nextState = FM10000_PORT_STATE_BIST;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_BIST_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_BIST_REQ].transitionCallback = AnStateMachineS8E9Callback;

    /* transition for state=PORT_STATE_REMOTE_FAULT(8), event=PORT_EVENT_AN_CONFIG_REQ(22) */
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_AN_CONFIG_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_AN_CONFIG_REQ].nextState = FM_STATE_UNSPECIFIED;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_AN_CONFIG_REQ].conditionCallback = AnRestart;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_AN_CONFIG_REQ].transitionCallback = NULL;

    /* transition for state=PORT_STATE_REMOTE_FAULT(8), event=PORT_EVENT_AN_DISABLE_REQ(23) */
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_AN_DISABLE_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_AN_DISABLE_REQ].nextState = FM10000_PORT_STATE_REMOTE_FAULT;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_AN_DISABLE_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_AN_DISABLE_REQ].transitionCallback = AnStateMachineS8E23Callback;

    /* transition for state=PORT_STATE_REMOTE_FAULT(8), event=PORT_EVENT_LOCAL_FAULT_IND(12) */
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].used = TRUE;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].nextState = FM10000_PORT_STATE_LOCAL_FAULT;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].transitionCallback = NULL;

    /* transition for state=PORT_STATE_REMOTE_FAULT(8), event=PORT_EVENT_LINK_UP_IND(20) */
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LINK_UP_IND].used = TRUE;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LINK_UP_IND].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LINK_UP_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LINK_UP_IND].transitionCallback = AnStateMachineS8E20Callback;

    /* transition for state=PORT_STATE_REMOTE_FAULT(8), event=PORT_EVENT_AN_RESTARTED_IND(25) */
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_AN_RESTARTED_IND].used = TRUE;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_AN_RESTARTED_IND].nextState = FM_STATE_UNSPECIFIED;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_AN_RESTARTED_IND].conditionCallback = AnRestart;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_AN_RESTARTED_IND].transitionCallback = NULL;

    /* transition for state=PORT_STATE_BIST(9), event=PORT_EVENT_CONFIG_REQ(0) */
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_CONFIG_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_CONFIG_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_CONFIG_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_CONFIG_REQ].transitionCallback = AnStateMachineS9E0Callback;

    /* transition for state=PORT_STATE_BIST(9), event=PORT_EVENT_DISABLE_REQ(1) */
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_DISABLE_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_DISABLE_REQ].nextState = FM10000_PORT_STATE_NEED_CONFIG;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_DISABLE_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_DISABLE_REQ].transitionCallback = AnStateMachineS9E1Callback;

    /* transition for state=PORT_STATE_BIST(9), event=PORT_EVENT_LOOPBACK_ON_REQ(2) */
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].nextState = FM_STATE_UNSPECIFIED;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].conditionCallback = AnRestart;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].transitionCallback = NULL;

    /* transition for state=PORT_STATE_BIST(9), event=PORT_EVENT_LOOPBACK_OFF_REQ(3) */
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].nextState = FM_STATE_UNSPECIFIED;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].conditionCallback = AnRestart;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].transitionCallback = NULL;

    /* transition for state=PORT_STATE_BIST(9), event=PORT_EVENT_ADMIN_UP_REQ(4) */
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].nextState = FM_STATE_UNSPECIFIED;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].conditionCallback = AnRestart;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].transitionCallback = NULL;

    /* transition for state=PORT_STATE_BIST(9), event=PORT_EVENT_ADMIN_DOWN_REQ(5) */
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].nextState = FM10000_PORT_STATE_ADMIN_FAULT;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].transitionCallback = AnStateMachineS9E5Callback;

    /* transition for state=PORT_STATE_BIST(9), event=PORT_EVENT_ADMIN_PWRDOWN_REQ(6) */
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].nextState = FM10000_PORT_STATE_CONFIGURED;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].transitionCallback = AnStateMachineS9E6Callback;

    /* transition for state=PORT_STATE_BIST(9), event=PORT_EVENT_REMOTE_FAULT_REQ(7) */
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].nextState = FM10000_PORT_STATE_ADMIN_FAULT;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].transitionCallback = AnStateMachineS9E7Callback;

    /* transition for state=PORT_STATE_BIST(9), event=PORT_EVENT_LOCAL_FAULT_REQ(8) */
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].nextState = FM10000_PORT_STATE_ADMIN_FAULT;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].transitionCallback = AnStateMachineS9E8Callback;

    /* transition for state=PORT_STATE_BIST(9), event=PORT_EVENT_BIST_REQ(9) */
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_BIST_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_BIST_REQ].nextState = FM10000_PORT_STATE_BIST;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_BIST_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_BIST_REQ].transitionCallback = AnStateMachineS9E9Callback;

    /* transition for state=PORT_STATE_BIST(9), event=PORT_EVENT_AN_CONFIG_REQ(22) */
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_AN_CONFIG_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_AN_CONFIG_REQ].nextState = FM_STATE_UNSPECIFIED;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_AN_CONFIG_REQ].conditionCallback = AnRestart;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_AN_CONFIG_REQ].transitionCallback = NULL;

    /* transition for state=PORT_STATE_BIST(9), event=PORT_EVENT_AN_DISABLE_REQ(23) */
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_AN_DISABLE_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_AN_DISABLE_REQ].nextState = FM10000_PORT_STATE_BIST;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_AN_DISABLE_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_AN_DISABLE_REQ].transitionCallback = AnStateMachineS9E23Callback;

    /* transition for state=PORT_STATE_BIST(9), event=PORT_EVENT_AN_RESTARTED_IND(25) */
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_AN_RESTARTED_IND].used = TRUE;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_AN_RESTARTED_IND].nextState = FM_STATE_UNSPECIFIED;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_AN_RESTARTED_IND].conditionCallback = AnRestart;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_AN_RESTARTED_IND].transitionCallback = NULL;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_CONFIG_REQ(0) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_CONFIG_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_CONFIG_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_CONFIG_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_CONFIG_REQ].transitionCallback = AnStateMachineS11E0Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_DISABLE_REQ(1) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_DISABLE_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_DISABLE_REQ].nextState = FM10000_PORT_STATE_NEED_CONFIG;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_DISABLE_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_DISABLE_REQ].transitionCallback = AnStateMachineS11E1Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_LOOPBACK_ON_REQ(2) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].nextState = FM_STATE_UNSPECIFIED;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].conditionCallback = AnRestart;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].transitionCallback = NULL;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_LOOPBACK_OFF_REQ(3) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].nextState = FM_STATE_UNSPECIFIED;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].conditionCallback = AnRestart;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].transitionCallback = NULL;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_ADMIN_DOWN_REQ(5) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].nextState = FM10000_PORT_STATE_ADMIN_FAULT;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].transitionCallback = AnStateMachineS11E5Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_ADMIN_PWRDOWN_REQ(6) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].nextState = FM10000_PORT_STATE_CONFIGURED;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].transitionCallback = AnStateMachineS11E6Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_REMOTE_FAULT_REQ(7) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].nextState = FM10000_PORT_STATE_ADMIN_FAULT;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].transitionCallback = AnStateMachineS11E7Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_LOCAL_FAULT_REQ(8) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].nextState = FM10000_PORT_STATE_ADMIN_FAULT;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].transitionCallback = AnStateMachineS11E8Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_BIST_REQ(9) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_BIST_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_BIST_REQ].nextState = FM10000_PORT_STATE_BIST;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_BIST_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_BIST_REQ].transitionCallback = AnStateMachineS11E9Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_AN_CONFIG_REQ(22) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_AN_CONFIG_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_AN_CONFIG_REQ].nextState = FM_STATE_UNSPECIFIED;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_AN_CONFIG_REQ].conditionCallback = AnRestart;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_AN_CONFIG_REQ].transitionCallback = NULL;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_AN_DISABLE_REQ(23) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_AN_DISABLE_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_AN_DISABLE_REQ].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_AN_DISABLE_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_AN_DISABLE_REQ].transitionCallback = AnStateMachineS11E23Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_REMOTE_FAULT_IND(11) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].nextState = FM10000_PORT_STATE_REMOTE_FAULT;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].transitionCallback = AnStateMachineS11E11Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_LOCAL_FAULT_IND(12) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].nextState = FM10000_PORT_STATE_LOCAL_FAULT;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].transitionCallback = AnStateMachineS11E12Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_AN_RESTARTED_IND(25) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_AN_RESTARTED_IND].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_AN_RESTARTED_IND].nextState = FM_STATE_UNSPECIFIED;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_AN_RESTARTED_IND].conditionCallback = AnRestart;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_AN_RESTARTED_IND].transitionCallback = NULL;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_EEE_SILENT_IND(28) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_EEE_SILENT_IND].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_EEE_SILENT_IND].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_EEE_SILENT_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_EEE_SILENT_IND].transitionCallback = AnStateMachineS11E28Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_DEFTIMER_EXP_IND(21) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_DEFTIMER_EXP_IND].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_DEFTIMER_EXP_IND].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_DEFTIMER_EXP_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_DEFTIMER_EXP_IND].transitionCallback = AnStateMachineS11E21Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_EEE_CONFIG_REQ(29) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_EEE_CONFIG_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_EEE_CONFIG_REQ].nextState = FM_STATE_UNSPECIFIED;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_EEE_CONFIG_REQ].conditionCallback = AnRestart;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_EEE_CONFIG_REQ].transitionCallback = NULL;

    /* fill out the state transition table for this state machine type */
    for (i = 0 ; i < FM10000_PORT_STATE_MAX  ; i++)
    {
        dynstt[i] = &stt[i][0];
    }

    /* register this state machine type */
    status = fmRegisterStateTransitionTable( FM10000_AN_PORT_STATE_MACHINE,
                                             FM10000_PORT_STATE_MAX,
                                             FM10000_PORT_EVENT_MAX,
                                             dynstt,
                                             logCallback,
                                             TRUE ); 
    return status;

}   /* end  fm10000RegisterAnPortStateMachine */


/*****************************************************************************/
/** fm10000RegisterBasicPortStateMachine
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            This function registers with the Generic State Machine
 *                  Engine state machine type ''FM10000_BASIC_PORT_STATE_MACHINE''
 * 
 * \return          FM_OK if the state machine was created successfully
 * 
 * \return          FM_ERR_INVALID_ARGUMENT if one of the arguments is invalid
 *
 * \return          FM_ERR_NO_MEM if there was a memory allocation failure
 *                  while creating one of the state machine internal structures
 * 
 * \return          FM_ERR_STATE_MACHINE_TYPE if this state machine type is
 *                  already registered 
 *
 *****************************************************************************/
fm_status fm10000RegisterBasicPortStateMachine( void )
{
    fm_int      i;
    fm_status   status;
    fm_smTransitionEntry  stt[FM10000_PORT_STATE_MAX][FM10000_PORT_EVENT_MAX];
    fm_smTransitionEntry *dynstt[FM10000_PORT_STATE_MAX];
    fm_smTransitionLogCallback logCallback;

    
    /* log callback for this type */
    logCallback = fm10000LogPortStateTransition;
    

    /* clear out the temporary state transition table */
    FM_MEMSET_S( stt, sizeof(stt), 0, sizeof(stt));

    /* transition for state=PORT_STATE_DISABLED(0), event=PORT_EVENT_CONFIG_REQ(0) */
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_CONFIG_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_CONFIG_REQ].nextState = FM10000_PORT_STATE_CONFIGURED;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_CONFIG_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_CONFIG_REQ].transitionCallback = BasicStateMachineS0E0Callback;

    /* transition for state=PORT_STATE_DISABLED(0), event=PORT_EVENT_ADMIN_UP_REQ(4) */
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].nextState = FM10000_PORT_STATE_NEED_CONFIG;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].transitionCallback = NULL;

    /* transition for state=PORT_STATE_DISABLED(0), event=PORT_EVENT_ADMIN_DOWN_REQ(5) */
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].nextState = FM10000_PORT_STATE_NEED_CONFIG;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].transitionCallback = NULL;

    /* transition for state=PORT_STATE_DISABLED(0), event=PORT_EVENT_REMOTE_FAULT_REQ(7) */
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].nextState = FM10000_PORT_STATE_NEED_CONFIG;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].transitionCallback = NULL;

    /* transition for state=PORT_STATE_DISABLED(0), event=PORT_EVENT_LOCAL_FAULT_REQ(8) */
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].nextState = FM10000_PORT_STATE_NEED_CONFIG;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].transitionCallback = NULL;

    /* transition for state=PORT_STATE_DISABLED(0), event=PORT_EVENT_BIST_REQ(9) */
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_BIST_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_BIST_REQ].nextState = FM10000_PORT_STATE_NEED_CONFIG;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_BIST_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_BIST_REQ].transitionCallback = NULL;

    /* transition for state=PORT_STATE_NEED_CONFIG(1), event=PORT_EVENT_CONFIG_REQ(0) */
    stt[FM10000_PORT_STATE_NEED_CONFIG]
       [FM10000_PORT_EVENT_CONFIG_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_NEED_CONFIG]
       [FM10000_PORT_EVENT_CONFIG_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_NEED_CONFIG]
       [FM10000_PORT_EVENT_CONFIG_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_NEED_CONFIG]
       [FM10000_PORT_EVENT_CONFIG_REQ].transitionCallback = BasicStateMachineS1E0Callback;

    /* transition for state=PORT_STATE_NEED_CONFIG(1), event=PORT_EVENT_ADMIN_PWRDOWN_REQ(6) */
    stt[FM10000_PORT_STATE_NEED_CONFIG]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_NEED_CONFIG]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].nextState = FM10000_PORT_STATE_DISABLED;
    stt[FM10000_PORT_STATE_NEED_CONFIG]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_NEED_CONFIG]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].transitionCallback = NULL;

    /* transition for state=PORT_STATE_CONFIGURED(2), event=PORT_EVENT_CONFIG_REQ(0) */
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_CONFIG_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_CONFIG_REQ].nextState = FM10000_PORT_STATE_CONFIGURED;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_CONFIG_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_CONFIG_REQ].transitionCallback = BasicStateMachineS2E0Callback;

    /* transition for state=PORT_STATE_CONFIGURED(2), event=PORT_EVENT_DISABLE_REQ(1) */
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_DISABLE_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_DISABLE_REQ].nextState = FM10000_PORT_STATE_DISABLED;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_DISABLE_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_DISABLE_REQ].transitionCallback = BasicStateMachineS2E1Callback;

    /* transition for state=PORT_STATE_CONFIGURED(2), event=PORT_EVENT_ADMIN_UP_REQ(4) */
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].transitionCallback = BasicStateMachineS2E4Callback;

    /* transition for state=PORT_STATE_CONFIGURED(2), event=PORT_EVENT_ADMIN_DOWN_REQ(5) */
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].transitionCallback = BasicStateMachineS2E5Callback;

    /* transition for state=PORT_STATE_CONFIGURED(2), event=PORT_EVENT_REMOTE_FAULT_REQ(7) */
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].transitionCallback = BasicStateMachineS2E7Callback;

    /* transition for state=PORT_STATE_CONFIGURED(2), event=PORT_EVENT_LOCAL_FAULT_REQ(8) */
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].transitionCallback = BasicStateMachineS2E8Callback;

    /* transition for state=PORT_STATE_CONFIGURED(2), event=PORT_EVENT_BIST_REQ(9) */
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_BIST_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_BIST_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_BIST_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_CONFIGURED]
       [FM10000_PORT_EVENT_BIST_REQ].transitionCallback = BasicStateMachineS2E9Callback;

    /* transition for state=PORT_STATE_POWERING_UP(3), event=PORT_EVENT_CONFIG_REQ(0) */
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_CONFIG_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_CONFIG_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_CONFIG_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_CONFIG_REQ].transitionCallback = BasicStateMachineS3E0Callback;

    /* transition for state=PORT_STATE_POWERING_UP(3), event=PORT_EVENT_DISABLE_REQ(1) */
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_DISABLE_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_DISABLE_REQ].nextState = FM10000_PORT_STATE_NEED_CONFIG;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_DISABLE_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_DISABLE_REQ].transitionCallback = BasicStateMachineS3E1Callback;

    /* transition for state=PORT_STATE_POWERING_UP(3), event=PORT_EVENT_LOOPBACK_ON_REQ(2) */
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].transitionCallback = BasicStateMachineS3E2Callback;

    /* transition for state=PORT_STATE_POWERING_UP(3), event=PORT_EVENT_LOOPBACK_OFF_REQ(3) */
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].transitionCallback = BasicStateMachineS3E3Callback;

    /* transition for state=PORT_STATE_POWERING_UP(3), event=PORT_EVENT_ADMIN_UP_REQ(4) */
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].transitionCallback = BasicStateMachineS3E4Callback;

    /* transition for state=PORT_STATE_POWERING_UP(3), event=PORT_EVENT_ADMIN_DOWN_REQ(5) */
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].transitionCallback = BasicStateMachineS3E5Callback;

    /* transition for state=PORT_STATE_POWERING_UP(3), event=PORT_EVENT_ADMIN_PWRDOWN_REQ(6) */
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].nextState = FM10000_PORT_STATE_CONFIGURED;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].transitionCallback = BasicStateMachineS3E6Callback;

    /* transition for state=PORT_STATE_POWERING_UP(3), event=PORT_EVENT_REMOTE_FAULT_REQ(7) */
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].transitionCallback = BasicStateMachineS3E7Callback;

    /* transition for state=PORT_STATE_POWERING_UP(3), event=PORT_EVENT_LOCAL_FAULT_REQ(8) */
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].transitionCallback = BasicStateMachineS3E8Callback;

    /* transition for state=PORT_STATE_POWERING_UP(3), event=PORT_EVENT_BIST_REQ(9) */
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_BIST_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_BIST_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_BIST_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_BIST_REQ].transitionCallback = BasicStateMachineS3E9Callback;

    /* transition for state=PORT_STATE_POWERING_UP(3), event=PORT_EVENT_CONFIGURE_DFE_REQ(10) */
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_CONFIGURE_DFE_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_CONFIGURE_DFE_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_CONFIGURE_DFE_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_CONFIGURE_DFE_REQ].transitionCallback = BasicStateMachineS3E10Callback;

    /* transition for state=PORT_STATE_POWERING_UP(3), event=PORT_EVENT_LANE_READY_IND(17) */
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_LANE_READY_IND].used = TRUE;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_LANE_READY_IND].nextState = FM_STATE_UNSPECIFIED;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_LANE_READY_IND].conditionCallback = CheckLanesReady;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_LANE_READY_IND].transitionCallback = NULL;

    /* transition for state=PORT_STATE_POWERING_UP(3), event=PORT_EVENT_LANE_NOT_READY_IND(18) */
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_LANE_NOT_READY_IND].used = TRUE;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_LANE_NOT_READY_IND].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_LANE_NOT_READY_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_POWERING_UP]
       [FM10000_PORT_EVENT_LANE_NOT_READY_IND].transitionCallback = BasicStateMachineS3E18Callback;

    /* transition for state=PORT_STATE_DEFERRED_UP(4), event=PORT_EVENT_CONFIG_REQ(0) */
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_CONFIG_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_CONFIG_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_CONFIG_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_CONFIG_REQ].transitionCallback = BasicStateMachineS4E0Callback;

    /* transition for state=PORT_STATE_DEFERRED_UP(4), event=PORT_EVENT_DISABLE_REQ(1) */
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_DISABLE_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_DISABLE_REQ].nextState = FM10000_PORT_STATE_NEED_CONFIG;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_DISABLE_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_DISABLE_REQ].transitionCallback = BasicStateMachineS4E1Callback;

    /* transition for state=PORT_STATE_DEFERRED_UP(4), event=PORT_EVENT_LOOPBACK_ON_REQ(2) */
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].nextState = FM10000_PORT_STATE_DEFERRED_UP;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].transitionCallback = BasicStateMachineS4E2Callback;

    /* transition for state=PORT_STATE_DEFERRED_UP(4), event=PORT_EVENT_LOOPBACK_OFF_REQ(3) */
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].nextState = FM10000_PORT_STATE_DEFERRED_UP;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].transitionCallback = BasicStateMachineS4E3Callback;

    /* transition for state=PORT_STATE_DEFERRED_UP(4), event=PORT_EVENT_ADMIN_UP_REQ(4) */
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].nextState = FM10000_PORT_STATE_DEFERRED_UP;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].transitionCallback = BasicStateMachineS4E4Callback;

    /* transition for state=PORT_STATE_DEFERRED_UP(4), event=PORT_EVENT_ADMIN_DOWN_REQ(5) */
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].nextState = FM10000_PORT_STATE_DEFERRED_UP;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].transitionCallback = BasicStateMachineS4E5Callback;

    /* transition for state=PORT_STATE_DEFERRED_UP(4), event=PORT_EVENT_ADMIN_PWRDOWN_REQ(6) */
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].nextState = FM10000_PORT_STATE_CONFIGURED;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].transitionCallback = BasicStateMachineS4E6Callback;

    /* transition for state=PORT_STATE_DEFERRED_UP(4), event=PORT_EVENT_REMOTE_FAULT_REQ(7) */
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].nextState = FM10000_PORT_STATE_DEFERRED_UP;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].transitionCallback = BasicStateMachineS4E7Callback;

    /* transition for state=PORT_STATE_DEFERRED_UP(4), event=PORT_EVENT_LOCAL_FAULT_REQ(8) */
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].nextState = FM10000_PORT_STATE_DEFERRED_UP;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].transitionCallback = BasicStateMachineS4E8Callback;

    /* transition for state=PORT_STATE_DEFERRED_UP(4), event=PORT_EVENT_BIST_REQ(9) */
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_BIST_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_BIST_REQ].nextState = FM10000_PORT_STATE_DEFERRED_UP;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_BIST_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_BIST_REQ].transitionCallback = BasicStateMachineS4E9Callback;

    /* transition for state=PORT_STATE_DEFERRED_UP(4), event=PORT_EVENT_CONFIGURE_DFE_REQ(10) */
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_CONFIGURE_DFE_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_CONFIGURE_DFE_REQ].nextState = FM10000_PORT_STATE_DEFERRED_UP;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_CONFIGURE_DFE_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_CONFIGURE_DFE_REQ].transitionCallback = BasicStateMachineS4E10Callback;

    /* transition for state=PORT_STATE_DEFERRED_UP(4), event=PORT_EVENT_LANE_NOT_READY_IND(18) */
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LANE_NOT_READY_IND].used = TRUE;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LANE_NOT_READY_IND].nextState = FM10000_PORT_STATE_DEFERRED_UP;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LANE_NOT_READY_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LANE_NOT_READY_IND].transitionCallback = BasicStateMachineS4E18Callback;

    /* transition for state=PORT_STATE_DEFERRED_UP(4), event=PORT_EVENT_DEFTIMER_EXP_IND(21) */
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_DEFTIMER_EXP_IND].used = TRUE;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_DEFTIMER_EXP_IND].nextState = FM_STATE_UNSPECIFIED;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_DEFTIMER_EXP_IND].conditionCallback = ProcessDeferralTimer;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_DEFTIMER_EXP_IND].transitionCallback = NULL;

    /* transition for state=PORT_STATE_DEFERRED_UP(4), event=PORT_EVENT_AN_RESTARTED_IND(25) */
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_AN_RESTARTED_IND].used = TRUE;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_AN_RESTARTED_IND].nextState = FM_STATE_UNSPECIFIED;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_AN_RESTARTED_IND].conditionCallback = AnRestart;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_AN_RESTARTED_IND].transitionCallback = NULL;

    /* transition for state=PORT_STATE_DEFERRED_UP(4), event=PORT_EVENT_LINK_DOWN_IND(19) */
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LINK_DOWN_IND].used = TRUE;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LINK_DOWN_IND].nextState = FM10000_PORT_STATE_DEFERRED_UP;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LINK_DOWN_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LINK_DOWN_IND].transitionCallback = NULL;

    /* transition for state=PORT_STATE_DEFERRED_UP(4), event=PORT_EVENT_LINK_UP_IND(20) */
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LINK_UP_IND].used = TRUE;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LINK_UP_IND].nextState = FM10000_PORT_STATE_DEFERRED_UP;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LINK_UP_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LINK_UP_IND].transitionCallback = NULL;

    /* transition for state=PORT_STATE_DEFERRED_UP(4), event=PORT_EVENT_REMOTE_FAULT_IND(11) */
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].used = TRUE;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].nextState = FM10000_PORT_STATE_DEFERRED_UP;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].transitionCallback = NULL;

    /* transition for state=PORT_STATE_DEFERRED_UP(4), event=PORT_EVENT_LOCAL_FAULT_IND(12) */
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].used = TRUE;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].nextState = FM10000_PORT_STATE_DEFERRED_UP;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DEFERRED_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].transitionCallback = NULL;

    /* transition for state=PORT_STATE_ADMIN_FAULT(6), event=PORT_EVENT_CONFIG_REQ(0) */
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_CONFIG_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_CONFIG_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_CONFIG_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_CONFIG_REQ].transitionCallback = BasicStateMachineS6E0Callback;

    /* transition for state=PORT_STATE_ADMIN_FAULT(6), event=PORT_EVENT_DISABLE_REQ(1) */
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_DISABLE_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_DISABLE_REQ].nextState = FM10000_PORT_STATE_NEED_CONFIG;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_DISABLE_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_DISABLE_REQ].transitionCallback = BasicStateMachineS6E1Callback;

    /* transition for state=PORT_STATE_ADMIN_FAULT(6), event=PORT_EVENT_ADMIN_UP_REQ(4) */
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].nextState = FM_STATE_UNSPECIFIED;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].conditionCallback = ExitAdminFaultMode;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].transitionCallback = NULL;

    /* transition for state=PORT_STATE_ADMIN_FAULT(6), event=PORT_EVENT_ADMIN_DOWN_REQ(5) */
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].nextState = FM10000_PORT_STATE_ADMIN_FAULT;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].transitionCallback = BasicStateMachineS6E5Callback;

    /* transition for state=PORT_STATE_ADMIN_FAULT(6), event=PORT_EVENT_ADMIN_PWRDOWN_REQ(6) */
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].nextState = FM10000_PORT_STATE_CONFIGURED;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].transitionCallback = BasicStateMachineS6E6Callback;

    /* transition for state=PORT_STATE_ADMIN_FAULT(6), event=PORT_EVENT_REMOTE_FAULT_REQ(7) */
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].nextState = FM10000_PORT_STATE_ADMIN_FAULT;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].transitionCallback = BasicStateMachineS6E7Callback;

    /* transition for state=PORT_STATE_ADMIN_FAULT(6), event=PORT_EVENT_LOCAL_FAULT_REQ(8) */
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].nextState = FM10000_PORT_STATE_ADMIN_FAULT;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].transitionCallback = BasicStateMachineS6E8Callback;

    /* transition for state=PORT_STATE_ADMIN_FAULT(6), event=PORT_EVENT_BIST_REQ(9) */
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_BIST_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_BIST_REQ].nextState = FM10000_PORT_STATE_BIST;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_BIST_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_BIST_REQ].transitionCallback = BasicStateMachineS6E9Callback;

    /* transition for state=PORT_STATE_ADMIN_FAULT(6), event=PORT_EVENT_CONFIGURE_DFE_REQ(10) */
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_CONFIGURE_DFE_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_CONFIGURE_DFE_REQ].nextState = FM10000_PORT_STATE_ADMIN_FAULT;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_CONFIGURE_DFE_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_ADMIN_FAULT]
       [FM10000_PORT_EVENT_CONFIGURE_DFE_REQ].transitionCallback = BasicStateMachineS6E10Callback;

    /* transition for state=PORT_STATE_LOCAL_FAULT(7), event=PORT_EVENT_CONFIG_REQ(0) */
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_CONFIG_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_CONFIG_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_CONFIG_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_CONFIG_REQ].transitionCallback = BasicStateMachineS7E0Callback;

    /* transition for state=PORT_STATE_LOCAL_FAULT(7), event=PORT_EVENT_DISABLE_REQ(1) */
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_DISABLE_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_DISABLE_REQ].nextState = FM10000_PORT_STATE_NEED_CONFIG;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_DISABLE_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_DISABLE_REQ].transitionCallback = BasicStateMachineS7E1Callback;

    /* transition for state=PORT_STATE_LOCAL_FAULT(7), event=PORT_EVENT_LOOPBACK_ON_REQ(2) */
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].nextState = FM10000_PORT_STATE_LOCAL_FAULT;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].transitionCallback = BasicStateMachineS7E2Callback;

    /* transition for state=PORT_STATE_LOCAL_FAULT(7), event=PORT_EVENT_LOOPBACK_OFF_REQ(3) */
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].nextState = FM10000_PORT_STATE_LOCAL_FAULT;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].transitionCallback = BasicStateMachineS7E3Callback;

    /* transition for state=PORT_STATE_LOCAL_FAULT(7), event=PORT_EVENT_FABRIC_LOOPBACK_ON_REQ(26) */
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_FABRIC_LOOPBACK_ON_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_FABRIC_LOOPBACK_ON_REQ].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_FABRIC_LOOPBACK_ON_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_FABRIC_LOOPBACK_ON_REQ].transitionCallback = BasicStateMachineS7E26Callback;

    /* transition for state=PORT_STATE_LOCAL_FAULT(7), event=PORT_EVENT_ADMIN_DOWN_REQ(5) */
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].nextState = FM10000_PORT_STATE_ADMIN_FAULT;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].transitionCallback = BasicStateMachineS7E5Callback;

    /* transition for state=PORT_STATE_LOCAL_FAULT(7), event=PORT_EVENT_ADMIN_PWRDOWN_REQ(6) */
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].nextState = FM10000_PORT_STATE_CONFIGURED;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].transitionCallback = BasicStateMachineS7E6Callback;

    /* transition for state=PORT_STATE_LOCAL_FAULT(7), event=PORT_EVENT_REMOTE_FAULT_REQ(7) */
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].nextState = FM10000_PORT_STATE_ADMIN_FAULT;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].transitionCallback = BasicStateMachineS7E7Callback;

    /* transition for state=PORT_STATE_LOCAL_FAULT(7), event=PORT_EVENT_LOCAL_FAULT_REQ(8) */
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].nextState = FM10000_PORT_STATE_ADMIN_FAULT;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].transitionCallback = BasicStateMachineS7E8Callback;

    /* transition for state=PORT_STATE_LOCAL_FAULT(7), event=PORT_EVENT_BIST_REQ(9) */
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_BIST_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_BIST_REQ].nextState = FM10000_PORT_STATE_BIST;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_BIST_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_BIST_REQ].transitionCallback = BasicStateMachineS7E9Callback;

    /* transition for state=PORT_STATE_LOCAL_FAULT(7), event=PORT_EVENT_CONFIGURE_DFE_REQ(10) */
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_CONFIGURE_DFE_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_CONFIGURE_DFE_REQ].nextState = FM10000_PORT_STATE_LOCAL_FAULT;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_CONFIGURE_DFE_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_CONFIGURE_DFE_REQ].transitionCallback = BasicStateMachineS7E10Callback;

    /* transition for state=PORT_STATE_LOCAL_FAULT(7), event=PORT_EVENT_REMOTE_FAULT_IND(11) */
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].used = TRUE;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].nextState = FM10000_PORT_STATE_REMOTE_FAULT;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].transitionCallback = BasicStateMachineS7E11Callback;

    /* transition for state=PORT_STATE_LOCAL_FAULT(7), event=PORT_EVENT_LINK_UP_IND(20) */
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_LINK_UP_IND].used = TRUE;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_LINK_UP_IND].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_LINK_UP_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_LOCAL_FAULT]
       [FM10000_PORT_EVENT_LINK_UP_IND].transitionCallback = BasicStateMachineS7E20Callback;

    /* transition for state=PORT_STATE_REMOTE_FAULT(8), event=PORT_EVENT_CONFIG_REQ(0) */
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_CONFIG_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_CONFIG_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_CONFIG_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_CONFIG_REQ].transitionCallback = BasicStateMachineS8E0Callback;

    /* transition for state=PORT_STATE_REMOTE_FAULT(8), event=PORT_EVENT_DISABLE_REQ(1) */
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_DISABLE_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_DISABLE_REQ].nextState = FM10000_PORT_STATE_NEED_CONFIG;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_DISABLE_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_DISABLE_REQ].transitionCallback = BasicStateMachineS8E1Callback;

    /* transition for state=PORT_STATE_REMOTE_FAULT(8), event=PORT_EVENT_LOOPBACK_ON_REQ(2) */
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].nextState = FM10000_PORT_STATE_REMOTE_FAULT;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].transitionCallback = BasicStateMachineS8E2Callback;

    /* transition for state=PORT_STATE_REMOTE_FAULT(8), event=PORT_EVENT_LOOPBACK_OFF_REQ(3) */
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].nextState = FM10000_PORT_STATE_REMOTE_FAULT;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].transitionCallback = BasicStateMachineS8E3Callback;

    /* transition for state=PORT_STATE_REMOTE_FAULT(8), event=PORT_EVENT_FABRIC_LOOPBACK_ON_REQ(26) */
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_FABRIC_LOOPBACK_ON_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_FABRIC_LOOPBACK_ON_REQ].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_FABRIC_LOOPBACK_ON_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_FABRIC_LOOPBACK_ON_REQ].transitionCallback = BasicStateMachineS8E26Callback;

    /* transition for state=PORT_STATE_REMOTE_FAULT(8), event=PORT_EVENT_ADMIN_DOWN_REQ(5) */
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].nextState = FM10000_PORT_STATE_ADMIN_FAULT;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].transitionCallback = BasicStateMachineS8E5Callback;

    /* transition for state=PORT_STATE_REMOTE_FAULT(8), event=PORT_EVENT_ADMIN_PWRDOWN_REQ(6) */
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].nextState = FM10000_PORT_STATE_CONFIGURED;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].transitionCallback = BasicStateMachineS8E6Callback;

    /* transition for state=PORT_STATE_REMOTE_FAULT(8), event=PORT_EVENT_REMOTE_FAULT_REQ(7) */
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].nextState = FM10000_PORT_STATE_ADMIN_FAULT;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].transitionCallback = BasicStateMachineS8E7Callback;

    /* transition for state=PORT_STATE_REMOTE_FAULT(8), event=PORT_EVENT_LOCAL_FAULT_REQ(8) */
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].nextState = FM10000_PORT_STATE_ADMIN_FAULT;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].transitionCallback = BasicStateMachineS8E8Callback;

    /* transition for state=PORT_STATE_REMOTE_FAULT(8), event=PORT_EVENT_BIST_REQ(9) */
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_BIST_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_BIST_REQ].nextState = FM10000_PORT_STATE_BIST;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_BIST_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_BIST_REQ].transitionCallback = BasicStateMachineS8E9Callback;

    /* transition for state=PORT_STATE_REMOTE_FAULT(8), event=PORT_EVENT_CONFIGURE_DFE_REQ(10) */
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_CONFIGURE_DFE_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_CONFIGURE_DFE_REQ].nextState = FM10000_PORT_STATE_REMOTE_FAULT;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_CONFIGURE_DFE_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_CONFIGURE_DFE_REQ].transitionCallback = BasicStateMachineS8E10Callback;

    /* transition for state=PORT_STATE_REMOTE_FAULT(8), event=PORT_EVENT_LOCAL_FAULT_IND(12) */
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].used = TRUE;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].nextState = FM10000_PORT_STATE_LOCAL_FAULT;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].transitionCallback = NULL;

    /* transition for state=PORT_STATE_REMOTE_FAULT(8), event=PORT_EVENT_LINK_UP_IND(20) */
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LINK_UP_IND].used = TRUE;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LINK_UP_IND].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LINK_UP_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_REMOTE_FAULT]
       [FM10000_PORT_EVENT_LINK_UP_IND].transitionCallback = BasicStateMachineS8E20Callback;

    /* transition for state=PORT_STATE_BIST(9), event=PORT_EVENT_CONFIG_REQ(0) */
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_CONFIG_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_CONFIG_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_CONFIG_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_CONFIG_REQ].transitionCallback = BasicStateMachineS9E0Callback;

    /* transition for state=PORT_STATE_BIST(9), event=PORT_EVENT_DISABLE_REQ(1) */
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_DISABLE_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_DISABLE_REQ].nextState = FM10000_PORT_STATE_NEED_CONFIG;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_DISABLE_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_DISABLE_REQ].transitionCallback = BasicStateMachineS9E1Callback;

    /* transition for state=PORT_STATE_BIST(9), event=PORT_EVENT_LOOPBACK_ON_REQ(2) */
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].nextState = FM10000_PORT_STATE_BIST;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].transitionCallback = BasicStateMachineS9E2Callback;

    /* transition for state=PORT_STATE_BIST(9), event=PORT_EVENT_LOOPBACK_OFF_REQ(3) */
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].nextState = FM10000_PORT_STATE_BIST;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].transitionCallback = BasicStateMachineS9E3Callback;

    /* transition for state=PORT_STATE_BIST(9), event=PORT_EVENT_ADMIN_UP_REQ(4) */
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].nextState = FM_STATE_UNSPECIFIED;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].conditionCallback = ExitBistMode;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].transitionCallback = NULL;

    /* transition for state=PORT_STATE_BIST(9), event=PORT_EVENT_ADMIN_DOWN_REQ(5) */
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].nextState = FM10000_PORT_STATE_ADMIN_FAULT;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].transitionCallback = BasicStateMachineS9E5Callback;

    /* transition for state=PORT_STATE_BIST(9), event=PORT_EVENT_ADMIN_PWRDOWN_REQ(6) */
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].nextState = FM10000_PORT_STATE_CONFIGURED;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].transitionCallback = BasicStateMachineS9E6Callback;

    /* transition for state=PORT_STATE_BIST(9), event=PORT_EVENT_REMOTE_FAULT_REQ(7) */
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].nextState = FM10000_PORT_STATE_ADMIN_FAULT;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].transitionCallback = BasicStateMachineS9E7Callback;

    /* transition for state=PORT_STATE_BIST(9), event=PORT_EVENT_LOCAL_FAULT_REQ(8) */
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].nextState = FM10000_PORT_STATE_ADMIN_FAULT;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].transitionCallback = BasicStateMachineS9E8Callback;

    /* transition for state=PORT_STATE_BIST(9), event=PORT_EVENT_BIST_REQ(9) */
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_BIST_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_BIST_REQ].nextState = FM10000_PORT_STATE_BIST;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_BIST_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_BIST_REQ].transitionCallback = BasicStateMachineS9E9Callback;

    /* transition for state=PORT_STATE_BIST(9), event=PORT_EVENT_CONFIGURE_DFE_REQ(10) */
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_CONFIGURE_DFE_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_CONFIGURE_DFE_REQ].nextState = FM10000_PORT_STATE_BIST;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_CONFIGURE_DFE_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_BIST]
       [FM10000_PORT_EVENT_CONFIGURE_DFE_REQ].transitionCallback = BasicStateMachineS9E10Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_CONFIG_REQ(0) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_CONFIG_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_CONFIG_REQ].nextState = FM10000_PORT_STATE_POWERING_UP;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_CONFIG_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_CONFIG_REQ].transitionCallback = BasicStateMachineS11E0Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_DISABLE_REQ(1) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_DISABLE_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_DISABLE_REQ].nextState = FM10000_PORT_STATE_NEED_CONFIG;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_DISABLE_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_DISABLE_REQ].transitionCallback = BasicStateMachineS11E1Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_LOOPBACK_ON_REQ(2) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].transitionCallback = BasicStateMachineS11E2Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_LOOPBACK_OFF_REQ(3) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].transitionCallback = BasicStateMachineS11E3Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_FABRIC_LOOPBACK_ON_REQ(26) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_FABRIC_LOOPBACK_ON_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_FABRIC_LOOPBACK_ON_REQ].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_FABRIC_LOOPBACK_ON_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_FABRIC_LOOPBACK_ON_REQ].transitionCallback = BasicStateMachineS11E26Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_FABRIC_LOOPBACK_OFF_REQ(27) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_FABRIC_LOOPBACK_OFF_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_FABRIC_LOOPBACK_OFF_REQ].nextState = FM_STATE_UNSPECIFIED;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_FABRIC_LOOPBACK_OFF_REQ].conditionCallback = ProcessDisableFabricLoopback;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_FABRIC_LOOPBACK_OFF_REQ].transitionCallback = NULL;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_ADMIN_DOWN_REQ(5) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].nextState = FM10000_PORT_STATE_ADMIN_FAULT;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].transitionCallback = BasicStateMachineS11E5Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_ADMIN_PWRDOWN_REQ(6) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].nextState = FM10000_PORT_STATE_CONFIGURED;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].transitionCallback = BasicStateMachineS11E6Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_REMOTE_FAULT_REQ(7) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].nextState = FM10000_PORT_STATE_ADMIN_FAULT;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].transitionCallback = BasicStateMachineS11E7Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_LOCAL_FAULT_REQ(8) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].nextState = FM10000_PORT_STATE_ADMIN_FAULT;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].transitionCallback = BasicStateMachineS11E8Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_BIST_REQ(9) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_BIST_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_BIST_REQ].nextState = FM10000_PORT_STATE_BIST;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_BIST_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_BIST_REQ].transitionCallback = BasicStateMachineS11E9Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_CONFIGURE_DFE_REQ(10) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_CONFIGURE_DFE_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_CONFIGURE_DFE_REQ].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_CONFIGURE_DFE_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_CONFIGURE_DFE_REQ].transitionCallback = BasicStateMachineS11E10Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_REMOTE_FAULT_IND(11) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].nextState = FM10000_PORT_STATE_REMOTE_FAULT;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].transitionCallback = BasicStateMachineS11E11Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_LOCAL_FAULT_IND(12) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].nextState = FM10000_PORT_STATE_LOCAL_FAULT;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].transitionCallback = BasicStateMachineS11E12Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_EEE_SILENT_IND(28) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_EEE_SILENT_IND].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_EEE_SILENT_IND].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_EEE_SILENT_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_EEE_SILENT_IND].transitionCallback = BasicStateMachineS11E28Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_DEFTIMER_EXP_IND(21) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_DEFTIMER_EXP_IND].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_DEFTIMER_EXP_IND].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_DEFTIMER_EXP_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_DEFTIMER_EXP_IND].transitionCallback = BasicStateMachineS11E21Callback;

    /* fill out the state transition table for this state machine type */
    for (i = 0 ; i < FM10000_PORT_STATE_MAX  ; i++)
    {
        dynstt[i] = &stt[i][0];
    }

    /* register this state machine type */
    status = fmRegisterStateTransitionTable( FM10000_BASIC_PORT_STATE_MACHINE,
                                             FM10000_PORT_STATE_MAX,
                                             FM10000_PORT_EVENT_MAX,
                                             dynstt,
                                             logCallback,
                                             TRUE ); 
    return status;

}   /* end  fm10000RegisterBasicPortStateMachine */


/*****************************************************************************/
/** fm10000RegisterPciePortStateMachine
 * \ingroup intPortStateMachine
 *
 * \chips           FM10000
 *
 * \desc            This function registers with the Generic State Machine
 *                  Engine state machine type ''FM10000_PCIE_PORT_STATE_MACHINE''
 * 
 * \return          FM_OK if the state machine was created successfully
 * 
 * \return          FM_ERR_INVALID_ARGUMENT if one of the arguments is invalid
 *
 * \return          FM_ERR_NO_MEM if there was a memory allocation failure
 *                  while creating one of the state machine internal structures
 * 
 * \return          FM_ERR_STATE_MACHINE_TYPE if this state machine type is
 *                  already registered 
 *
 *****************************************************************************/
fm_status fm10000RegisterPciePortStateMachine( void )
{
    fm_int      i;
    fm_status   status;
    fm_smTransitionEntry  stt[FM10000_PORT_STATE_MAX][FM10000_PORT_EVENT_MAX];
    fm_smTransitionEntry *dynstt[FM10000_PORT_STATE_MAX];
    fm_smTransitionLogCallback logCallback;

    
    /* log callback for this type */
    logCallback = fm10000LogPortStateTransition;
    

    /* clear out the temporary state transition table */
    FM_MEMSET_S( stt, sizeof(stt), 0, sizeof(stt));

    /* transition for state=PORT_STATE_DISABLED(0), event=PORT_EVENT_CONFIG_REQ(0) */
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_CONFIG_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_CONFIG_REQ].nextState = FM_STATE_UNSPECIFIED;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_CONFIG_REQ].conditionCallback = ConfigureDeviceAndCheckState;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_CONFIG_REQ].transitionCallback = NULL;

    /* transition for state=PORT_STATE_DISABLED(0), event=PORT_EVENT_LINK_UP_IND(20) */
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LINK_UP_IND].used = TRUE;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LINK_UP_IND].nextState = FM10000_PORT_STATE_DISABLED;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LINK_UP_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LINK_UP_IND].transitionCallback = PcieStateMachineS0E20Callback;

    /* transition for state=PORT_STATE_DISABLED(0), event=PORT_EVENT_LINK_DOWN_IND(19) */
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LINK_DOWN_IND].used = TRUE;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LINK_DOWN_IND].nextState = FM10000_PORT_STATE_DISABLED;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LINK_DOWN_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LINK_DOWN_IND].transitionCallback = PcieStateMachineS0E19Callback;

    /* transition for state=PORT_STATE_DISABLED(0), event=PORT_EVENT_LOOPBACK_ON_REQ(2) */
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].nextState = FM10000_PORT_STATE_DISABLED;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].transitionCallback = PcieStateMachineS0E2Callback;

    /* transition for state=PORT_STATE_DISABLED(0), event=PORT_EVENT_LOOPBACK_OFF_REQ(3) */
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].nextState = FM10000_PORT_STATE_DISABLED;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].transitionCallback = PcieStateMachineS0E3Callback;

    /* transition for state=PORT_STATE_DISABLED(0), event=PORT_EVENT_ADMIN_UP_REQ(4) */
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].nextState = FM10000_PORT_STATE_DISABLED;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].transitionCallback = PcieStateMachineS0E4Callback;

    /* transition for state=PORT_STATE_DISABLED(0), event=PORT_EVENT_ADMIN_DOWN_REQ(5) */
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].nextState = FM10000_PORT_STATE_DISABLED;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].transitionCallback = PcieStateMachineS0E5Callback;

    /* transition for state=PORT_STATE_DISABLED(0), event=PORT_EVENT_ADMIN_PWRDOWN_REQ(6) */
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].nextState = FM10000_PORT_STATE_DISABLED;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].transitionCallback = PcieStateMachineS0E6Callback;

    /* transition for state=PORT_STATE_DISABLED(0), event=PORT_EVENT_REMOTE_FAULT_REQ(7) */
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].nextState = FM10000_PORT_STATE_DISABLED;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].transitionCallback = PcieStateMachineS0E7Callback;

    /* transition for state=PORT_STATE_DISABLED(0), event=PORT_EVENT_LOCAL_FAULT_REQ(8) */
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].nextState = FM10000_PORT_STATE_DISABLED;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].transitionCallback = PcieStateMachineS0E8Callback;

    /* transition for state=PORT_STATE_DISABLED(0), event=PORT_EVENT_BIST_REQ(9) */
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_BIST_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_BIST_REQ].nextState = FM10000_PORT_STATE_DISABLED;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_BIST_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_BIST_REQ].transitionCallback = PcieStateMachineS0E9Callback;

    /* transition for state=PORT_STATE_DISABLED(0), event=PORT_EVENT_REMOTE_FAULT_IND(11) */
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].used = TRUE;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].nextState = FM10000_PORT_STATE_DISABLED;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].transitionCallback = PcieStateMachineS0E11Callback;

    /* transition for state=PORT_STATE_DISABLED(0), event=PORT_EVENT_LOCAL_FAULT_IND(12) */
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].used = TRUE;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].nextState = FM10000_PORT_STATE_DISABLED;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].transitionCallback = PcieStateMachineS0E12Callback;

    /* transition for state=PORT_STATE_DISABLED(0), event=PORT_EVENT_LANE_DFE_COMPLETE_IND(13) */
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LANE_DFE_COMPLETE_IND].used = TRUE;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LANE_DFE_COMPLETE_IND].nextState = FM10000_PORT_STATE_DISABLED;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LANE_DFE_COMPLETE_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LANE_DFE_COMPLETE_IND].transitionCallback = PcieStateMachineS0E13Callback;

    /* transition for state=PORT_STATE_DISABLED(0), event=PORT_EVENT_LANE_DFE_FAILED_IND(14) */
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LANE_DFE_FAILED_IND].used = TRUE;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LANE_DFE_FAILED_IND].nextState = FM10000_PORT_STATE_DISABLED;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LANE_DFE_FAILED_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LANE_DFE_FAILED_IND].transitionCallback = PcieStateMachineS0E14Callback;

    /* transition for state=PORT_STATE_DISABLED(0), event=PORT_EVENT_LANE_KR_COMPLETE_IND(15) */
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LANE_KR_COMPLETE_IND].used = TRUE;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LANE_KR_COMPLETE_IND].nextState = FM10000_PORT_STATE_DISABLED;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LANE_KR_COMPLETE_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LANE_KR_COMPLETE_IND].transitionCallback = PcieStateMachineS0E15Callback;

    /* transition for state=PORT_STATE_DISABLED(0), event=PORT_EVENT_LANE_KR_FAILED_IND(16) */
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LANE_KR_FAILED_IND].used = TRUE;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LANE_KR_FAILED_IND].nextState = FM10000_PORT_STATE_DISABLED;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LANE_KR_FAILED_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LANE_KR_FAILED_IND].transitionCallback = PcieStateMachineS0E16Callback;

    /* transition for state=PORT_STATE_DISABLED(0), event=PORT_EVENT_LANE_READY_IND(17) */
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LANE_READY_IND].used = TRUE;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LANE_READY_IND].nextState = FM10000_PORT_STATE_DISABLED;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LANE_READY_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LANE_READY_IND].transitionCallback = PcieStateMachineS0E17Callback;

    /* transition for state=PORT_STATE_DISABLED(0), event=PORT_EVENT_LANE_NOT_READY_IND(18) */
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LANE_NOT_READY_IND].used = TRUE;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LANE_NOT_READY_IND].nextState = FM10000_PORT_STATE_DISABLED;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LANE_NOT_READY_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_LANE_NOT_READY_IND].transitionCallback = PcieStateMachineS0E18Callback;

    /* transition for state=PORT_STATE_DISABLED(0), event=PORT_EVENT_DEFTIMER_EXP_IND(21) */
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_DEFTIMER_EXP_IND].used = TRUE;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_DEFTIMER_EXP_IND].nextState = FM10000_PORT_STATE_DISABLED;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_DEFTIMER_EXP_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DISABLED]
       [FM10000_PORT_EVENT_DEFTIMER_EXP_IND].transitionCallback = PcieStateMachineS0E21Callback;

    /* transition for state=PORT_STATE_DOWN(10), event=PORT_EVENT_CONFIG_REQ(0) */
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_CONFIG_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_CONFIG_REQ].nextState = FM10000_PORT_STATE_DOWN;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_CONFIG_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_CONFIG_REQ].transitionCallback = PcieStateMachineS10E0Callback;

    /* transition for state=PORT_STATE_DOWN(10), event=PORT_EVENT_DISABLE_REQ(1) */
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_DISABLE_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_DISABLE_REQ].nextState = FM10000_PORT_STATE_DISABLED;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_DISABLE_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_DISABLE_REQ].transitionCallback = PcieStateMachineS10E1Callback;

    /* transition for state=PORT_STATE_DOWN(10), event=PORT_EVENT_LINK_UP_IND(20) */
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LINK_UP_IND].used = TRUE;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LINK_UP_IND].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LINK_UP_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LINK_UP_IND].transitionCallback = PcieStateMachineS10E20Callback;

    /* transition for state=PORT_STATE_DOWN(10), event=PORT_EVENT_LINK_DOWN_IND(19) */
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LINK_DOWN_IND].used = TRUE;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LINK_DOWN_IND].nextState = FM10000_PORT_STATE_DOWN;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LINK_DOWN_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LINK_DOWN_IND].transitionCallback = PcieStateMachineS10E19Callback;

    /* transition for state=PORT_STATE_DOWN(10), event=PORT_EVENT_LOOPBACK_ON_REQ(2) */
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].nextState = FM10000_PORT_STATE_DOWN;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].transitionCallback = PcieStateMachineS10E2Callback;

    /* transition for state=PORT_STATE_DOWN(10), event=PORT_EVENT_LOOPBACK_OFF_REQ(3) */
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].nextState = FM10000_PORT_STATE_DOWN;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].transitionCallback = PcieStateMachineS10E3Callback;

    /* transition for state=PORT_STATE_DOWN(10), event=PORT_EVENT_ADMIN_UP_REQ(4) */
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].nextState = FM10000_PORT_STATE_DOWN;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].transitionCallback = PcieStateMachineS10E4Callback;

    /* transition for state=PORT_STATE_DOWN(10), event=PORT_EVENT_ADMIN_DOWN_REQ(5) */
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].nextState = FM10000_PORT_STATE_DOWN;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].transitionCallback = PcieStateMachineS10E5Callback;

    /* transition for state=PORT_STATE_DOWN(10), event=PORT_EVENT_ADMIN_PWRDOWN_REQ(6) */
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].nextState = FM10000_PORT_STATE_DOWN;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].transitionCallback = PcieStateMachineS10E6Callback;

    /* transition for state=PORT_STATE_DOWN(10), event=PORT_EVENT_REMOTE_FAULT_REQ(7) */
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].nextState = FM10000_PORT_STATE_DOWN;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].transitionCallback = PcieStateMachineS10E7Callback;

    /* transition for state=PORT_STATE_DOWN(10), event=PORT_EVENT_LOCAL_FAULT_REQ(8) */
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].nextState = FM10000_PORT_STATE_DOWN;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].transitionCallback = PcieStateMachineS10E8Callback;

    /* transition for state=PORT_STATE_DOWN(10), event=PORT_EVENT_BIST_REQ(9) */
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_BIST_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_BIST_REQ].nextState = FM10000_PORT_STATE_DOWN;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_BIST_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_BIST_REQ].transitionCallback = PcieStateMachineS10E9Callback;

    /* transition for state=PORT_STATE_DOWN(10), event=PORT_EVENT_REMOTE_FAULT_IND(11) */
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].used = TRUE;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].nextState = FM10000_PORT_STATE_DOWN;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].transitionCallback = PcieStateMachineS10E11Callback;

    /* transition for state=PORT_STATE_DOWN(10), event=PORT_EVENT_LOCAL_FAULT_IND(12) */
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].used = TRUE;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].nextState = FM10000_PORT_STATE_DOWN;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].transitionCallback = PcieStateMachineS10E12Callback;

    /* transition for state=PORT_STATE_DOWN(10), event=PORT_EVENT_LANE_DFE_COMPLETE_IND(13) */
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LANE_DFE_COMPLETE_IND].used = TRUE;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LANE_DFE_COMPLETE_IND].nextState = FM10000_PORT_STATE_DOWN;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LANE_DFE_COMPLETE_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LANE_DFE_COMPLETE_IND].transitionCallback = PcieStateMachineS10E13Callback;

    /* transition for state=PORT_STATE_DOWN(10), event=PORT_EVENT_LANE_DFE_FAILED_IND(14) */
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LANE_DFE_FAILED_IND].used = TRUE;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LANE_DFE_FAILED_IND].nextState = FM10000_PORT_STATE_DOWN;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LANE_DFE_FAILED_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LANE_DFE_FAILED_IND].transitionCallback = PcieStateMachineS10E14Callback;

    /* transition for state=PORT_STATE_DOWN(10), event=PORT_EVENT_LANE_KR_COMPLETE_IND(15) */
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LANE_KR_COMPLETE_IND].used = TRUE;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LANE_KR_COMPLETE_IND].nextState = FM10000_PORT_STATE_DOWN;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LANE_KR_COMPLETE_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LANE_KR_COMPLETE_IND].transitionCallback = PcieStateMachineS10E15Callback;

    /* transition for state=PORT_STATE_DOWN(10), event=PORT_EVENT_LANE_KR_FAILED_IND(16) */
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LANE_KR_FAILED_IND].used = TRUE;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LANE_KR_FAILED_IND].nextState = FM10000_PORT_STATE_DOWN;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LANE_KR_FAILED_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LANE_KR_FAILED_IND].transitionCallback = PcieStateMachineS10E16Callback;

    /* transition for state=PORT_STATE_DOWN(10), event=PORT_EVENT_LANE_READY_IND(17) */
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LANE_READY_IND].used = TRUE;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LANE_READY_IND].nextState = FM10000_PORT_STATE_DOWN;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LANE_READY_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LANE_READY_IND].transitionCallback = PcieStateMachineS10E17Callback;

    /* transition for state=PORT_STATE_DOWN(10), event=PORT_EVENT_LANE_NOT_READY_IND(18) */
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LANE_NOT_READY_IND].used = TRUE;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LANE_NOT_READY_IND].nextState = FM10000_PORT_STATE_DOWN;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LANE_NOT_READY_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_LANE_NOT_READY_IND].transitionCallback = PcieStateMachineS10E18Callback;

    /* transition for state=PORT_STATE_DOWN(10), event=PORT_EVENT_DEFTIMER_EXP_IND(21) */
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_DEFTIMER_EXP_IND].used = TRUE;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_DEFTIMER_EXP_IND].nextState = FM10000_PORT_STATE_DOWN;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_DEFTIMER_EXP_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_DEFTIMER_EXP_IND].transitionCallback = PcieStateMachineS10E21Callback;

    /* transition for state=PORT_STATE_DOWN(10), event=PORT_EVENT_FABRIC_LOOPBACK_ON_REQ(26) */
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_FABRIC_LOOPBACK_ON_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_FABRIC_LOOPBACK_ON_REQ].nextState = FM10000_PORT_STATE_DOWN;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_FABRIC_LOOPBACK_ON_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_FABRIC_LOOPBACK_ON_REQ].transitionCallback = PcieStateMachineS10E26Callback;

    /* transition for state=PORT_STATE_DOWN(10), event=PORT_EVENT_FABRIC_LOOPBACK_OFF_REQ(27) */
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_FABRIC_LOOPBACK_OFF_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_FABRIC_LOOPBACK_OFF_REQ].nextState = FM10000_PORT_STATE_DOWN;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_FABRIC_LOOPBACK_OFF_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_DOWN]
       [FM10000_PORT_EVENT_FABRIC_LOOPBACK_OFF_REQ].transitionCallback = PcieStateMachineS10E27Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_CONFIG_REQ(0) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_CONFIG_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_CONFIG_REQ].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_CONFIG_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_CONFIG_REQ].transitionCallback = PcieStateMachineS11E0Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_DISABLE_REQ(1) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_DISABLE_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_DISABLE_REQ].nextState = FM10000_PORT_STATE_DISABLED;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_DISABLE_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_DISABLE_REQ].transitionCallback = PcieStateMachineS11E1Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_LINK_UP_IND(20) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LINK_UP_IND].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LINK_UP_IND].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LINK_UP_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LINK_UP_IND].transitionCallback = PcieStateMachineS11E20Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_LINK_DOWN_IND(19) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LINK_DOWN_IND].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LINK_DOWN_IND].nextState = FM10000_PORT_STATE_DOWN;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LINK_DOWN_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LINK_DOWN_IND].transitionCallback = PcieStateMachineS11E19Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_LOOPBACK_ON_REQ(2) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOOPBACK_ON_REQ].transitionCallback = PcieStateMachineS11E2Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_LOOPBACK_OFF_REQ(3) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOOPBACK_OFF_REQ].transitionCallback = PcieStateMachineS11E3Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_ADMIN_UP_REQ(4) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_ADMIN_UP_REQ].transitionCallback = PcieStateMachineS11E4Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_ADMIN_DOWN_REQ(5) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_ADMIN_DOWN_REQ].transitionCallback = PcieStateMachineS11E5Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_ADMIN_PWRDOWN_REQ(6) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_ADMIN_PWRDOWN_REQ].transitionCallback = PcieStateMachineS11E6Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_REMOTE_FAULT_REQ(7) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_REQ].transitionCallback = PcieStateMachineS11E7Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_LOCAL_FAULT_REQ(8) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_REQ].transitionCallback = PcieStateMachineS11E8Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_BIST_REQ(9) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_BIST_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_BIST_REQ].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_BIST_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_BIST_REQ].transitionCallback = PcieStateMachineS11E9Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_REMOTE_FAULT_IND(11) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_REMOTE_FAULT_IND].transitionCallback = PcieStateMachineS11E11Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_LOCAL_FAULT_IND(12) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LOCAL_FAULT_IND].transitionCallback = PcieStateMachineS11E12Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_LANE_DFE_COMPLETE_IND(13) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LANE_DFE_COMPLETE_IND].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LANE_DFE_COMPLETE_IND].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LANE_DFE_COMPLETE_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LANE_DFE_COMPLETE_IND].transitionCallback = PcieStateMachineS11E13Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_LANE_DFE_FAILED_IND(14) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LANE_DFE_FAILED_IND].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LANE_DFE_FAILED_IND].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LANE_DFE_FAILED_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LANE_DFE_FAILED_IND].transitionCallback = PcieStateMachineS11E14Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_LANE_KR_COMPLETE_IND(15) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LANE_KR_COMPLETE_IND].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LANE_KR_COMPLETE_IND].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LANE_KR_COMPLETE_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LANE_KR_COMPLETE_IND].transitionCallback = PcieStateMachineS11E15Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_LANE_KR_FAILED_IND(16) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LANE_KR_FAILED_IND].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LANE_KR_FAILED_IND].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LANE_KR_FAILED_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LANE_KR_FAILED_IND].transitionCallback = PcieStateMachineS11E16Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_LANE_READY_IND(17) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LANE_READY_IND].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LANE_READY_IND].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LANE_READY_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LANE_READY_IND].transitionCallback = PcieStateMachineS11E17Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_LANE_NOT_READY_IND(18) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LANE_NOT_READY_IND].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LANE_NOT_READY_IND].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LANE_NOT_READY_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_LANE_NOT_READY_IND].transitionCallback = PcieStateMachineS11E18Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_DEFTIMER_EXP_IND(21) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_DEFTIMER_EXP_IND].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_DEFTIMER_EXP_IND].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_DEFTIMER_EXP_IND].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_DEFTIMER_EXP_IND].transitionCallback = PcieStateMachineS11E21Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_FABRIC_LOOPBACK_ON_REQ(26) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_FABRIC_LOOPBACK_ON_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_FABRIC_LOOPBACK_ON_REQ].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_FABRIC_LOOPBACK_ON_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_FABRIC_LOOPBACK_ON_REQ].transitionCallback = PcieStateMachineS11E26Callback;

    /* transition for state=PORT_STATE_UP(11), event=PORT_EVENT_FABRIC_LOOPBACK_OFF_REQ(27) */
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_FABRIC_LOOPBACK_OFF_REQ].used = TRUE;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_FABRIC_LOOPBACK_OFF_REQ].nextState = FM10000_PORT_STATE_UP;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_FABRIC_LOOPBACK_OFF_REQ].conditionCallback = NULL;
    stt[FM10000_PORT_STATE_UP]
       [FM10000_PORT_EVENT_FABRIC_LOOPBACK_OFF_REQ].transitionCallback = PcieStateMachineS11E27Callback;

    /* fill out the state transition table for this state machine type */
    for (i = 0 ; i < FM10000_PORT_STATE_MAX  ; i++)
    {
        dynstt[i] = &stt[i][0];
    }

    /* register this state machine type */
    status = fmRegisterStateTransitionTable( FM10000_PCIE_PORT_STATE_MACHINE,
                                             FM10000_PORT_STATE_MAX,
                                             FM10000_PORT_EVENT_MAX,
                                             dynstt,
                                             logCallback,
                                             TRUE ); 
    return status;

}   /* end  fm10000RegisterPciePortStateMachine */



