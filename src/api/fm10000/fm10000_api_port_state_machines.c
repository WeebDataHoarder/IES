/* vim:ts=4:sw=4:expandtab
 * (No tabs, indent level is 4 spaces) */
/*****************************************************************************
 * File:            fm10000_api_port_state_machines.c
 * Creation Date:   October 30, 2013
 * Description:     Source file for the port-level state machine
 * 
 *                  ------------------------------------------------------
 *                  THIS FILE IS AUTO-GENERATED BY THE BUILD SYSTEM. DO
 *                  NOT MODIFY THIS FILE. MODIFY THE FOLLOWING INSTEAD
 * 
 *                  1) fm10000_api_port_state_machines.xml
 *                  2) templates/fm10000_api_port_state_machines.c
 *                  ------------------------------------------------------
 *
 * Copyright (c) 2007 - 2015, Intel Corporation
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Intel Corporation nor the names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

#include <fm_sdk_fm10000_int.h>


/*****************************************************************************
 * Macros, Constants & Types
 *****************************************************************************/

#define ST(s) FM10000_PORT_STATE_ ## s
#define EV(e) FM10000_PORT_EVENT_ ## e
#define TG(g) TransitionGroup ## g
#define FN(n) (genericFunction) n

typedef void (*genericFunction)(void);

/****************************************************************/
/** \ingroup intPortStateMachine 
 * Definition of the State Machine Transition Table values.
 ****************************************************************/
typedef struct _fm_smTable
{
    /* callback for transition or condition */
    genericFunction         callback;
    
    /** current state identifier */
    fm_int                  current;

    /** event identifier */
    fm_int                  event;

    /** next state identifier */
    fm_int                  next;

} fm_smTable;


/*****************************************************************************
 * Local function prototypes
 *****************************************************************************/

/* declaration of all action callbacks */
static fm_status PowerUpLane( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PowerUpLaneRx( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PowerUpLaneTx( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PowerDownLane( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PowerDownLaneRx( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PowerDownLaneTx( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status ReleaseSchedBwAdmDown( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status RequestSchedBwAdmUp( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status ReleaseSchedBwLnkDown( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status RequestSchedBwLnkUp( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status ConfigureLane( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status ConfigureLaneForAn73( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status NotifyApiPortUp( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status NotifyApiPortDown( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status ConfigureLoopback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status RestoreTxFaultMode( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SetTxFaultMode( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SetTxFaultModeToNormal( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status InitPcs( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Init1000BaseX( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Init10GBaseR( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status InitMlBaseR( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status InitAn73( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status WriteEplCfgA( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status WriteEplCfgB( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status WriteMac( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status EnableDrainMode( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status DisableDrainMode( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status EnablePhy( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status DisablePhy( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status EnableLinkInterrupts( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status DisableLinkInterrupts( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status ResetPortModuleState( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status EnableLoopback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status DisableLoopback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status EnableFabricLoopback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status DisableFabricLoopback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status ClearEplFifo( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status EnableBistMode( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status DisableBistMode( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Restart100gSyncDetection( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status StartDeferralTimer( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status StopDeferralTimer( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status FlagError( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status ConfigureDfe( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status LinkPortToLanes( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status UnlinkPortFromLanes( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status UpdatePcieModeAndSpeed( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status UpdatePcieLaneReversal( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status EnablePcieInterrupts( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status DisablePcieInterrupts( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStart( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status AnStop( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status ReconfigurePortForAn( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status RestoreDfe( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status ReconfigureScheduler( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status ConfigureFarLoopback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status EnableLowPowerIdle( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status InitPepMailbox( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status EnablePepLoopback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status DisablePepLoopback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status NotifyEthModeChange( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status EnablePhyAutoneg( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status DisablePhyAutoneg( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status StartAnWatchDogTimer( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status StopAnWatchDogTimer( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status StartDeferredLpiTimer( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status StopDeferredLpiTimer( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status DeferredLpiMode( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status StartPortStatusPollingTimer( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status StopPortStatusPollingTimer( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status CheckAndPreReserveSchedBw( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status RequestSchedBwAdmUpAn( fm_smEventInfo *eventInfo, void *userInfo );



/* declaration of all condition callbacks */
static fm_status CheckLanesReady( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status ProcessDeferralTimer( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status ProcessDeferralTimerWithAn( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status ProcessPortStatusPollingTimer( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status ProcessPortStatus( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status ConfigureDeviceAndCheckState( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status CheckPortStatus( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status AnRestart( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status EnterNegotiatedMode( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status SetupAdminModeUp( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status ExitBistMode( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status ExitAdminFaultMode( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status ProcessDisableFabricLoopback( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );



/* declaration of transition group callbacks */
static fm_status TG(0)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(1)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(2)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(3)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(4)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(5)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(6)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(7)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(8)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(9)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(10)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(11)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(12)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(13)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(14)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(15)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(16)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(17)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(18)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(19)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(20)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(21)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(22)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(23)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(24)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(25)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(26)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(27)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(28)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(29)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(30)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(31)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(32)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(33)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(34)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(35)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(36)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(37)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(38)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(39)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(40)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(41)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(42)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(43)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(44)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(45)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(46)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(47)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(48)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(49)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(50)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(51)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(52)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(53)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(54)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(55)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(56)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(57)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(58)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(59)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(60)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(61)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(62)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(63)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(64)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(65)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(66)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(67)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(68)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(69)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(70)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(71)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(72)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(73)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(74)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(75)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(76)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(77)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(78)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(79)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(80)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(81)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(82)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(83)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(84)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(85)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(86)( fm_smEventInfo *eventInfo, void *userInfo );


/*****************************************************************************
 * Global Variables
 *****************************************************************************/

/* array containing descriptive names for each of the port states */
fm_text fm10000PortStatesMap[FM10000_PORT_STATE_MAX] =
{
    "PORT_STATE_DISABLED",
    "PORT_STATE_NEED_CONFIG",
    "PORT_STATE_CONFIGURED",
    "PORT_STATE_POWERING_UP",
    "PORT_STATE_DEFERRED_UP",
    "PORT_STATE_AUTONEG",
    "PORT_STATE_ADMIN_FAULT",
    "PORT_STATE_LOCAL_FAULT",
    "PORT_STATE_REMOTE_FAULT",
    "PORT_STATE_BIST",
    "PORT_STATE_DOWN",
    "PORT_STATE_UP"

};

/* array containing descriptive names for each of the port events */
fm_text fm10000PortEventsMap[FM10000_PORT_EVENT_MAX] =
{
    "PORT_EVENT_CONFIG_REQ",
    "PORT_EVENT_DISABLE_REQ",
    "PORT_EVENT_LOOPBACK_ON_REQ",
    "PORT_EVENT_LOOPBACK_OFF_REQ",
    "PORT_EVENT_ADMIN_UP_REQ",
    "PORT_EVENT_ADMIN_DOWN_REQ",
    "PORT_EVENT_ADMIN_PWRDOWN_REQ",
    "PORT_EVENT_REMOTE_FAULT_REQ",
    "PORT_EVENT_LOCAL_FAULT_REQ",
    "PORT_EVENT_BIST_REQ",
    "PORT_EVENT_CONFIGURE_DFE_REQ",
    "PORT_EVENT_REMOTE_FAULT_IND",
    "PORT_EVENT_LOCAL_FAULT_IND",
    "PORT_EVENT_LANE_DFE_COMPLETE_IND",
    "PORT_EVENT_LANE_DFE_FAILED_IND",
    "PORT_EVENT_LANE_KR_COMPLETE_IND",
    "PORT_EVENT_LANE_KR_FAILED_IND",
    "PORT_EVENT_LANE_READY_IND",
    "PORT_EVENT_LANE_NOT_READY_IND",
    "PORT_EVENT_LINK_DOWN_IND",
    "PORT_EVENT_LINK_UP_IND",
    "PORT_EVENT_DEFTIMER_EXP_IND",
    "PORT_EVENT_POLLING_TIMER_EXP_IND",
    "PORT_EVENT_AN_CONFIG_REQ",
    "PORT_EVENT_AN_DISABLE_REQ",
    "PORT_EVENT_AN_COMPLETE_IND",
    "PORT_EVENT_AN_RESTARTED_IND",
    "PORT_EVENT_FABRIC_LOOPBACK_ON_REQ",
    "PORT_EVENT_FABRIC_LOOPBACK_OFF_REQ",
    "PORT_EVENT_EEE_SILENT_IND",
    "PORT_EVENT_EEE_CONFIG_REQ"

};

/*****************************************************************************
 * Local Variables
 *****************************************************************************/


static const fm_smTable fm10000AnSmTable[] = {
    { FN(TG(42))                    , ST(AUTONEG)     , EV(ADMIN_PWRDOWN_REQ) , ST(CONFIGURED)       },
    { FN(TG(23))                    , ST(UP)          , EV(EEE_SILENT_IND)    , ST(UP)               },
    { FN(TG(43))                    , ST(POWERING_UP) , EV(CONFIG_REQ)        , ST(POWERING_UP)      },
    { FN(TG(44))                    , ST(ADMIN_FAULT) , EV(CONFIG_REQ)        , ST(POWERING_UP)      },
    { FN(TG(45))                    , ST(UP)          , EV(REMOTE_FAULT_IND)  , ST(REMOTE_FAULT)     },
    { FN(TG(45))                    , ST(UP)          , EV(LOCAL_FAULT_IND)   , ST(LOCAL_FAULT)      },
    { FN(TG(46))                    , ST(AUTONEG)     , EV(LOOPBACK_ON_REQ)   , ST(AUTONEG)          },
    { FN(TG(46))                    , ST(AUTONEG)     , EV(LOOPBACK_OFF_REQ)  , ST(AUTONEG)          },
    { FN(TG(47))                    , ST(LOCAL_FAULT) , EV(ADMIN_PWRDOWN_REQ) , ST(CONFIGURED)       },
    { FN(TG(47))                    , ST(REMOTE_FAULT), EV(ADMIN_PWRDOWN_REQ) , ST(CONFIGURED)       },
    { FN(TG(48))                    , ST(AUTONEG)     , EV(AN_CONFIG_REQ)     , ST(AUTONEG)          },
    { FN(TG(49))                    , ST(UP)          , EV(REMOTE_FAULT_REQ)  , ST(ADMIN_FAULT)      },
    { FN(TG(49))                    , ST(UP)          , EV(LOCAL_FAULT_REQ)   , ST(ADMIN_FAULT)      },
    { NULL                          , ST(DISABLED)    , EV(ADMIN_UP_REQ)      , ST(NEED_CONFIG)      },
    { NULL                          , ST(DISABLED)    , EV(ADMIN_DOWN_REQ)    , ST(NEED_CONFIG)      },
    { NULL                          , ST(DISABLED)    , EV(REMOTE_FAULT_REQ)  , ST(NEED_CONFIG)      },
    { NULL                          , ST(DISABLED)    , EV(LOCAL_FAULT_REQ)   , ST(NEED_CONFIG)      },
    { NULL                          , ST(DISABLED)    , EV(BIST_REQ)          , ST(NEED_CONFIG)      },
    { NULL                          , ST(NEED_CONFIG) , EV(ADMIN_PWRDOWN_REQ) , ST(DISABLED)         },
    { FN(CheckLanesReady)           , ST(POWERING_UP) , EV(LANE_READY_IND)    , FM_STATE_UNSPECIFIED },
    { FN(AnRestart)                 , ST(POWERING_UP) , EV(AN_RESTARTED_IND)  , FM_STATE_UNSPECIFIED },
    { FN(ProcessDeferralTimerWithAn), ST(DEFERRED_UP) , EV(DEFTIMER_EXP_IND)  , FM_STATE_UNSPECIFIED },
    { FN(AnRestart)                 , ST(DEFERRED_UP) , EV(AN_RESTARTED_IND)  , FM_STATE_UNSPECIFIED },
    { FN(AnRestart)                 , ST(AUTONEG)     , EV(DEFTIMER_EXP_IND)  , FM_STATE_UNSPECIFIED },
    { FN(EnterNegotiatedMode)       , ST(AUTONEG)     , EV(AN_COMPLETE_IND)   , FM_STATE_UNSPECIFIED },
    { FN(AnRestart)                 , ST(ADMIN_FAULT) , EV(ADMIN_UP_REQ)      , FM_STATE_UNSPECIFIED },
    { FN(AnRestart)                 , ST(ADMIN_FAULT) , EV(AN_CONFIG_REQ)     , FM_STATE_UNSPECIFIED },
    { FN(AnRestart)                 , ST(ADMIN_FAULT) , EV(AN_RESTARTED_IND)  , FM_STATE_UNSPECIFIED },
    { FN(AnRestart)                 , ST(LOCAL_FAULT) , EV(LOOPBACK_ON_REQ)   , FM_STATE_UNSPECIFIED },
    { FN(AnRestart)                 , ST(LOCAL_FAULT) , EV(LOOPBACK_OFF_REQ)  , FM_STATE_UNSPECIFIED },
    { FN(AnRestart)                 , ST(LOCAL_FAULT) , EV(AN_CONFIG_REQ)     , FM_STATE_UNSPECIFIED },
    { NULL                          , ST(LOCAL_FAULT) , EV(REMOTE_FAULT_IND)  , ST(REMOTE_FAULT)     },
    { FN(AnRestart)                 , ST(LOCAL_FAULT) , EV(AN_RESTARTED_IND)  , FM_STATE_UNSPECIFIED },
    { FN(AnRestart)                 , ST(REMOTE_FAULT), EV(LOOPBACK_ON_REQ)   , FM_STATE_UNSPECIFIED },
    { FN(AnRestart)                 , ST(REMOTE_FAULT), EV(LOOPBACK_OFF_REQ)  , FM_STATE_UNSPECIFIED },
    { FN(AnRestart)                 , ST(REMOTE_FAULT), EV(AN_CONFIG_REQ)     , FM_STATE_UNSPECIFIED },
    { NULL                          , ST(REMOTE_FAULT), EV(LOCAL_FAULT_IND)   , ST(LOCAL_FAULT)      },
    { FN(AnRestart)                 , ST(REMOTE_FAULT), EV(AN_RESTARTED_IND)  , FM_STATE_UNSPECIFIED },
    { FN(AnRestart)                 , ST(BIST)        , EV(LOOPBACK_ON_REQ)   , FM_STATE_UNSPECIFIED },
    { FN(AnRestart)                 , ST(BIST)        , EV(LOOPBACK_OFF_REQ)  , FM_STATE_UNSPECIFIED },
    { FN(AnRestart)                 , ST(BIST)        , EV(ADMIN_UP_REQ)      , FM_STATE_UNSPECIFIED },
    { FN(AnRestart)                 , ST(BIST)        , EV(AN_CONFIG_REQ)     , FM_STATE_UNSPECIFIED },
    { FN(AnRestart)                 , ST(BIST)        , EV(AN_RESTARTED_IND)  , FM_STATE_UNSPECIFIED },
    { FN(AnRestart)                 , ST(UP)          , EV(LOOPBACK_ON_REQ)   , FM_STATE_UNSPECIFIED },
    { FN(AnRestart)                 , ST(UP)          , EV(LOOPBACK_OFF_REQ)  , FM_STATE_UNSPECIFIED },
    { FN(AnRestart)                 , ST(UP)          , EV(AN_CONFIG_REQ)     , FM_STATE_UNSPECIFIED },
    { FN(AnRestart)                 , ST(UP)          , EV(AN_RESTARTED_IND)  , FM_STATE_UNSPECIFIED },
    { FN(AnRestart)                 , ST(UP)          , EV(EEE_CONFIG_REQ)    , FM_STATE_UNSPECIFIED },
    { FN(TG(50))                    , ST(AUTONEG)     , EV(CONFIG_REQ)        , ST(POWERING_UP)      },
    { FN(TG(51))                    , ST(DEFERRED_UP) , EV(CONFIG_REQ)        , ST(POWERING_UP)      },
    { FN(TG(52))                    , ST(ADMIN_FAULT) , EV(BIST_REQ)          , ST(POWERING_UP)      },
    { FN(TG(8))                     , ST(BIST)        , EV(ADMIN_DOWN_REQ)    , ST(ADMIN_FAULT)      },
    { FN(TG(8))                     , ST(BIST)        , EV(REMOTE_FAULT_REQ)  , ST(ADMIN_FAULT)      },
    { FN(TG(8))                     , ST(BIST)        , EV(LOCAL_FAULT_REQ)   , ST(ADMIN_FAULT)      },
    { FN(TG(53))                    , ST(UP)          , EV(CONFIG_REQ)        , ST(POWERING_UP)      },
    { FN(TG(54))                    , ST(BIST)        , EV(ADMIN_PWRDOWN_REQ) , ST(CONFIGURED)       },
    { FN(TG(24))                    , ST(CONFIGURED)  , EV(DISABLE_REQ)       , ST(DISABLED)         },
    { FN(TG(55))                    , ST(LOCAL_FAULT) , EV(ADMIN_DOWN_REQ)    , ST(ADMIN_FAULT)      },
    { FN(TG(55))                    , ST(LOCAL_FAULT) , EV(REMOTE_FAULT_REQ)  , ST(ADMIN_FAULT)      },
    { FN(TG(55))                    , ST(LOCAL_FAULT) , EV(LOCAL_FAULT_REQ)   , ST(ADMIN_FAULT)      },
    { FN(TG(55))                    , ST(REMOTE_FAULT), EV(ADMIN_DOWN_REQ)    , ST(ADMIN_FAULT)      },
    { FN(TG(55))                    , ST(REMOTE_FAULT), EV(REMOTE_FAULT_REQ)  , ST(ADMIN_FAULT)      },
    { FN(TG(55))                    , ST(REMOTE_FAULT), EV(LOCAL_FAULT_REQ)   , ST(ADMIN_FAULT)      },
    { FN(TG(56))                    , ST(UP)          , EV(ADMIN_DOWN_REQ)    , ST(ADMIN_FAULT)      },
    { FN(TG(57))                    , ST(ADMIN_FAULT) , EV(DISABLE_REQ)       , ST(NEED_CONFIG)      },
    { FN(TG(57))                    , ST(LOCAL_FAULT) , EV(DISABLE_REQ)       , ST(NEED_CONFIG)      },
    { FN(TG(57))                    , ST(REMOTE_FAULT), EV(DISABLE_REQ)       , ST(NEED_CONFIG)      },
    { FN(TG(58))                    , ST(CONFIGURED)  , EV(ADMIN_UP_REQ)      , ST(POWERING_UP)      },
    { FN(TG(58))                    , ST(CONFIGURED)  , EV(ADMIN_DOWN_REQ)    , ST(POWERING_UP)      },
    { FN(TG(58))                    , ST(CONFIGURED)  , EV(REMOTE_FAULT_REQ)  , ST(POWERING_UP)      },
    { FN(TG(58))                    , ST(CONFIGURED)  , EV(LOCAL_FAULT_REQ)   , ST(POWERING_UP)      },
    { FN(TG(58))                    , ST(CONFIGURED)  , EV(BIST_REQ)          , ST(POWERING_UP)      },
    { FN(TG(59))                    , ST(AUTONEG)     , EV(DISABLE_REQ)       , ST(NEED_CONFIG)      },
    { FN(TG(60))                    , ST(AUTONEG)     , EV(AN_DISABLE_REQ)    , ST(AUTONEG)          },
    { FN(TG(61))                    , ST(POWERING_UP) , EV(ADMIN_PWRDOWN_REQ) , ST(CONFIGURED)       },
    { FN(TG(61))                    , ST(ADMIN_FAULT) , EV(ADMIN_PWRDOWN_REQ) , ST(CONFIGURED)       },
    { FN(TG(62))                    , ST(BIST)        , EV(DISABLE_REQ)       , ST(NEED_CONFIG)      },
    { FN(TG(63))                    , ST(UP)          , EV(DISABLE_REQ)       , ST(NEED_CONFIG)      },
    { FN(TG(64))                    , ST(ADMIN_FAULT) , EV(AN_DISABLE_REQ)    , ST(ADMIN_FAULT)      },
    { FN(TG(64))                    , ST(LOCAL_FAULT) , EV(AN_DISABLE_REQ)    , ST(LOCAL_FAULT)      },
    { FN(TG(64))                    , ST(REMOTE_FAULT), EV(AN_DISABLE_REQ)    , ST(REMOTE_FAULT)     },
    { FN(TG(64))                    , ST(BIST)        , EV(AN_DISABLE_REQ)    , ST(BIST)             },
    { FN(TG(64))                    , ST(UP)          , EV(AN_DISABLE_REQ)    , ST(UP)               },
    { FN(TG(65))                    , ST(LOCAL_FAULT) , EV(BIST_REQ)          , ST(BIST)             },
    { FN(TG(65))                    , ST(REMOTE_FAULT), EV(BIST_REQ)          , ST(BIST)             },
    { FN(TG(66))                    , ST(DEFERRED_UP) , EV(DISABLE_REQ)       , ST(NEED_CONFIG)      },
    { FN(TG(31))                    , ST(ADMIN_FAULT) , EV(ADMIN_DOWN_REQ)    , ST(ADMIN_FAULT)      },
    { FN(TG(31))                    , ST(ADMIN_FAULT) , EV(REMOTE_FAULT_REQ)  , ST(ADMIN_FAULT)      },
    { FN(TG(31))                    , ST(ADMIN_FAULT) , EV(LOCAL_FAULT_REQ)   , ST(ADMIN_FAULT)      },
    { FN(TG(67))                    , ST(DEFERRED_UP) , EV(ADMIN_PWRDOWN_REQ) , ST(CONFIGURED)       },
    { FN(TG(68))                    , ST(BIST)        , EV(BIST_REQ)          , ST(BIST)             },
    { FN(TG(69))                    , ST(LOCAL_FAULT) , EV(CONFIG_REQ)        , ST(POWERING_UP)      },
    { FN(TG(69))                    , ST(REMOTE_FAULT), EV(CONFIG_REQ)        , ST(POWERING_UP)      },
    { FN(TG(70))                    , ST(BIST)        , EV(CONFIG_REQ)        , ST(POWERING_UP)      },
    { FN(TG(34))                    , ST(LOCAL_FAULT) , EV(LINK_UP_IND)       , ST(UP)               },
    { FN(TG(34))                    , ST(REMOTE_FAULT), EV(LINK_UP_IND)       , ST(UP)               },
    { FN(TG(41))                    , ST(UP)          , EV(DEFTIMER_EXP_IND)  , ST(UP)               },
    { FN(TG(71))                    , ST(UP)          , EV(ADMIN_PWRDOWN_REQ) , ST(CONFIGURED)       },
    { FN(TG(72))                    , ST(NEED_CONFIG) , EV(CONFIG_REQ)        , ST(POWERING_UP)      },
    { FN(TG(73))                    , ST(POWERING_UP) , EV(DISABLE_REQ)       , ST(NEED_CONFIG)      },
    { FN(TG(37))                    , ST(POWERING_UP) , EV(LANE_NOT_READY_IND), ST(POWERING_UP)      },
    { FN(TG(74))                    , ST(DISABLED)    , EV(CONFIG_REQ)        , ST(CONFIGURED)       },
    { FN(TG(74))                    , ST(CONFIGURED)  , EV(CONFIG_REQ)        , ST(CONFIGURED)       },
    { FN(TG(75))                    , ST(UP)          , EV(BIST_REQ)          , ST(BIST)             }
};

static const fm_smTable fm10000BasicSmTable[] = {
    { FN(TG(0))                        , ST(REMOTE_FAULT), EV(LOCAL_FAULT_IND)        , ST(LOCAL_FAULT)      },
    { FN(TG(1))                        , ST(POWERING_UP) , EV(CONFIG_REQ)             , ST(POWERING_UP)      },
    { FN(TG(1))                        , ST(ADMIN_FAULT) , EV(CONFIG_REQ)             , ST(POWERING_UP)      },
    { FN(TG(2))                        , ST(UP)          , EV(CONFIGURE_DFE_REQ)      , ST(UP)               },
    { FN(TG(3))                        , ST(POWERING_UP) , EV(LOOPBACK_OFF_REQ)       , ST(POWERING_UP)      },
    { FN(TG(3))                        , ST(DEFERRED_UP) , EV(LOOPBACK_OFF_REQ)       , ST(DEFERRED_UP)      },
    { FN(TG(3))                        , ST(LOCAL_FAULT) , EV(LOOPBACK_OFF_REQ)       , ST(LOCAL_FAULT)      },
    { FN(TG(3))                        , ST(REMOTE_FAULT), EV(LOOPBACK_OFF_REQ)       , ST(REMOTE_FAULT)     },
    { FN(TG(3))                        , ST(BIST)        , EV(LOOPBACK_OFF_REQ)       , ST(BIST)             },
    { FN(TG(3))                        , ST(UP)          , EV(LOOPBACK_OFF_REQ)       , ST(UP)               },
    { FN(TG(4))                        , ST(DEFERRED_UP) , EV(BIST_REQ)               , ST(DEFERRED_UP)      },
    { NULL                             , ST(DISABLED)    , EV(ADMIN_UP_REQ)           , ST(NEED_CONFIG)      },
    { NULL                             , ST(DISABLED)    , EV(ADMIN_DOWN_REQ)         , ST(NEED_CONFIG)      },
    { NULL                             , ST(DISABLED)    , EV(REMOTE_FAULT_REQ)       , ST(NEED_CONFIG)      },
    { NULL                             , ST(DISABLED)    , EV(LOCAL_FAULT_REQ)        , ST(NEED_CONFIG)      },
    { NULL                             , ST(DISABLED)    , EV(BIST_REQ)               , ST(NEED_CONFIG)      },
    { NULL                             , ST(NEED_CONFIG) , EV(ADMIN_PWRDOWN_REQ)      , ST(DISABLED)         },
    { FN(CheckLanesReady)              , ST(POWERING_UP) , EV(LANE_READY_IND)         , FM_STATE_UNSPECIFIED },
    { FN(ProcessDeferralTimer)         , ST(DEFERRED_UP) , EV(DEFTIMER_EXP_IND)       , FM_STATE_UNSPECIFIED },
    { FN(AnRestart)                    , ST(DEFERRED_UP) , EV(AN_RESTARTED_IND)       , FM_STATE_UNSPECIFIED },
    { FN(ExitAdminFaultMode)           , ST(ADMIN_FAULT) , EV(ADMIN_UP_REQ)           , FM_STATE_UNSPECIFIED },
    { FN(ProcessPortStatusPollingTimer), ST(LOCAL_FAULT) , EV(POLLING_TIMER_EXP_IND)  , FM_STATE_UNSPECIFIED },
    { FN(ProcessPortStatusPollingTimer), ST(REMOTE_FAULT), EV(POLLING_TIMER_EXP_IND)  , FM_STATE_UNSPECIFIED },
    { FN(ExitBistMode)                 , ST(BIST)        , EV(ADMIN_UP_REQ)           , FM_STATE_UNSPECIFIED },
    { FN(ProcessDisableFabricLoopback) , ST(UP)          , EV(FABRIC_LOOPBACK_OFF_REQ), FM_STATE_UNSPECIFIED },
    { FN(ProcessPortStatusPollingTimer), ST(UP)          , EV(POLLING_TIMER_EXP_IND)  , FM_STATE_UNSPECIFIED },
    { FN(TG(5))                        , ST(LOCAL_FAULT) , EV(DISABLE_REQ)            , ST(NEED_CONFIG)      },
    { FN(TG(5))                        , ST(REMOTE_FAULT), EV(DISABLE_REQ)            , ST(NEED_CONFIG)      },
    { FN(TG(6))                        , ST(DEFERRED_UP) , EV(CONFIG_REQ)             , ST(POWERING_UP)      },
    { FN(TG(7))                        , ST(LOCAL_FAULT) , EV(ADMIN_PWRDOWN_REQ)      , ST(CONFIGURED)       },
    { FN(TG(7))                        , ST(REMOTE_FAULT), EV(ADMIN_PWRDOWN_REQ)      , ST(CONFIGURED)       },
    { FN(TG(8))                        , ST(BIST)        , EV(ADMIN_DOWN_REQ)         , ST(ADMIN_FAULT)      },
    { FN(TG(8))                        , ST(BIST)        , EV(REMOTE_FAULT_REQ)       , ST(ADMIN_FAULT)      },
    { FN(TG(8))                        , ST(BIST)        , EV(LOCAL_FAULT_REQ)        , ST(ADMIN_FAULT)      },
    { FN(TG(9))                        , ST(POWERING_UP) , EV(CONFIGURE_DFE_REQ)      , ST(POWERING_UP)      },
    { FN(TG(9))                        , ST(DEFERRED_UP) , EV(CONFIGURE_DFE_REQ)      , ST(DEFERRED_UP)      },
    { FN(TG(9))                        , ST(ADMIN_FAULT) , EV(CONFIGURE_DFE_REQ)      , ST(ADMIN_FAULT)      },
    { FN(TG(9))                        , ST(LOCAL_FAULT) , EV(CONFIGURE_DFE_REQ)      , ST(LOCAL_FAULT)      },
    { FN(TG(9))                        , ST(REMOTE_FAULT), EV(CONFIGURE_DFE_REQ)      , ST(REMOTE_FAULT)     },
    { FN(TG(9))                        , ST(BIST)        , EV(CONFIGURE_DFE_REQ)      , ST(BIST)             },
    { FN(TG(10))                       , ST(UP)          , EV(DISABLE_REQ)            , ST(NEED_CONFIG)      },
    { FN(TG(11))                       , ST(POWERING_UP) , EV(LOOPBACK_ON_REQ)        , ST(POWERING_UP)      },
    { FN(TG(11))                       , ST(DEFERRED_UP) , EV(LOOPBACK_ON_REQ)        , ST(DEFERRED_UP)      },
    { FN(TG(11))                       , ST(LOCAL_FAULT) , EV(LOOPBACK_ON_REQ)        , ST(LOCAL_FAULT)      },
    { FN(TG(11))                       , ST(REMOTE_FAULT), EV(LOOPBACK_ON_REQ)        , ST(REMOTE_FAULT)     },
    { FN(TG(11))                       , ST(BIST)        , EV(LOOPBACK_ON_REQ)        , ST(BIST)             },
    { FN(TG(11))                       , ST(UP)          , EV(LOOPBACK_ON_REQ)        , ST(UP)               },
    { FN(TG(12))                       , ST(UP)          , EV(REMOTE_FAULT_IND)       , ST(REMOTE_FAULT)     },
    { FN(TG(12))                       , ST(UP)          , EV(LOCAL_FAULT_IND)        , ST(LOCAL_FAULT)      },
    { FN(TG(13))                       , ST(CONFIGURED)  , EV(REMOTE_FAULT_REQ)       , ST(POWERING_UP)      },
    { FN(TG(13))                       , ST(CONFIGURED)  , EV(LOCAL_FAULT_REQ)        , ST(POWERING_UP)      },
    { FN(TG(13))                       , ST(CONFIGURED)  , EV(BIST_REQ)               , ST(POWERING_UP)      },
    { FN(TG(14))                       , ST(UP)          , EV(ADMIN_PWRDOWN_REQ)      , ST(CONFIGURED)       },
    { FN(TG(15))                       , ST(LOCAL_FAULT) , EV(REMOTE_FAULT_IND)       , ST(REMOTE_FAULT)     },
    { FN(TG(16))                       , ST(DEFERRED_UP) , EV(ADMIN_PWRDOWN_REQ)      , ST(CONFIGURED)       },
    { FN(TG(17))                       , ST(LOCAL_FAULT) , EV(CONFIG_REQ)             , ST(POWERING_UP)      },
    { FN(TG(17))                       , ST(REMOTE_FAULT), EV(CONFIG_REQ)             , ST(POWERING_UP)      },
    { FN(TG(18))                       , ST(LOCAL_FAULT) , EV(FABRIC_LOOPBACK_ON_REQ) , ST(UP)               },
    { FN(TG(18))                       , ST(REMOTE_FAULT), EV(FABRIC_LOOPBACK_ON_REQ) , ST(UP)               },
    { FN(TG(19))                       , ST(ADMIN_FAULT) , EV(BIST_REQ)               , ST(BIST)             },
    { FN(TG(20))                       , ST(DISABLED)    , EV(CONFIG_REQ)             , ST(CONFIGURED)       },
    { FN(TG(20))                       , ST(CONFIGURED)  , EV(CONFIG_REQ)             , ST(CONFIGURED)       },
    { FN(TG(21))                       , ST(BIST)        , EV(BIST_REQ)               , ST(BIST)             },
    { FN(TG(22))                       , ST(REMOTE_FAULT), EV(REMOTE_FAULT_REQ)       , ST(ADMIN_FAULT)      },
    { FN(TG(22))                       , ST(REMOTE_FAULT), EV(LOCAL_FAULT_REQ)        , ST(ADMIN_FAULT)      },
    { FN(TG(23))                       , ST(UP)          , EV(EEE_SILENT_IND)         , ST(UP)               },
    { FN(TG(24))                       , ST(CONFIGURED)  , EV(DISABLE_REQ)            , ST(DISABLED)         },
    { FN(TG(25))                       , ST(POWERING_UP) , EV(ADMIN_PWRDOWN_REQ)      , ST(CONFIGURED)       },
    { FN(TG(25))                       , ST(ADMIN_FAULT) , EV(ADMIN_PWRDOWN_REQ)      , ST(CONFIGURED)       },
    { FN(TG(26))                       , ST(DEFERRED_UP) , EV(DISABLE_REQ)            , ST(NEED_CONFIG)      },
    { FN(TG(27))                       , ST(UP)          , EV(ADMIN_DOWN_REQ)         , ST(ADMIN_FAULT)      },
    { FN(TG(27))                       , ST(UP)          , EV(REMOTE_FAULT_REQ)       , ST(ADMIN_FAULT)      },
    { FN(TG(27))                       , ST(UP)          , EV(LOCAL_FAULT_REQ)        , ST(ADMIN_FAULT)      },
    { FN(TG(28))                       , ST(NEED_CONFIG) , EV(CONFIG_REQ)             , ST(POWERING_UP)      },
    { FN(TG(29))                       , ST(LOCAL_FAULT) , EV(BIST_REQ)               , ST(BIST)             },
    { FN(TG(29))                       , ST(REMOTE_FAULT), EV(BIST_REQ)               , ST(BIST)             },
    { FN(TG(30))                       , ST(UP)          , EV(FABRIC_LOOPBACK_ON_REQ) , ST(UP)               },
    { FN(TG(31))                       , ST(POWERING_UP) , EV(ADMIN_UP_REQ)           , ST(POWERING_UP)      },
    { FN(TG(31))                       , ST(POWERING_UP) , EV(ADMIN_DOWN_REQ)         , ST(POWERING_UP)      },
    { FN(TG(31))                       , ST(POWERING_UP) , EV(REMOTE_FAULT_REQ)       , ST(POWERING_UP)      },
    { FN(TG(31))                       , ST(POWERING_UP) , EV(LOCAL_FAULT_REQ)        , ST(POWERING_UP)      },
    { FN(TG(31))                       , ST(POWERING_UP) , EV(BIST_REQ)               , ST(POWERING_UP)      },
    { FN(TG(31))                       , ST(DEFERRED_UP) , EV(ADMIN_UP_REQ)           , ST(DEFERRED_UP)      },
    { FN(TG(31))                       , ST(DEFERRED_UP) , EV(ADMIN_DOWN_REQ)         , ST(DEFERRED_UP)      },
    { FN(TG(31))                       , ST(DEFERRED_UP) , EV(REMOTE_FAULT_REQ)       , ST(DEFERRED_UP)      },
    { FN(TG(31))                       , ST(DEFERRED_UP) , EV(LOCAL_FAULT_REQ)        , ST(DEFERRED_UP)      },
    { FN(TG(31))                       , ST(ADMIN_FAULT) , EV(ADMIN_DOWN_REQ)         , ST(ADMIN_FAULT)      },
    { FN(TG(31))                       , ST(ADMIN_FAULT) , EV(REMOTE_FAULT_REQ)       , ST(ADMIN_FAULT)      },
    { FN(TG(31))                       , ST(ADMIN_FAULT) , EV(LOCAL_FAULT_REQ)        , ST(ADMIN_FAULT)      },
    { FN(TG(31))                       , ST(LOCAL_FAULT) , EV(ADMIN_DOWN_REQ)         , ST(ADMIN_FAULT)      },
    { FN(TG(31))                       , ST(LOCAL_FAULT) , EV(REMOTE_FAULT_REQ)       , ST(ADMIN_FAULT)      },
    { FN(TG(31))                       , ST(LOCAL_FAULT) , EV(LOCAL_FAULT_REQ)        , ST(ADMIN_FAULT)      },
    { FN(TG(31))                       , ST(REMOTE_FAULT), EV(ADMIN_DOWN_REQ)         , ST(ADMIN_FAULT)      },
    { FN(TG(32))                       , ST(UP)          , EV(CONFIG_REQ)             , ST(POWERING_UP)      },
    { FN(TG(33))                       , ST(BIST)        , EV(DISABLE_REQ)            , ST(NEED_CONFIG)      },
    { FN(TG(34))                       , ST(LOCAL_FAULT) , EV(LINK_UP_IND)            , ST(UP)               },
    { FN(TG(34))                       , ST(REMOTE_FAULT), EV(LINK_UP_IND)            , ST(UP)               },
    { FN(TG(35))                       , ST(BIST)        , EV(ADMIN_PWRDOWN_REQ)      , ST(CONFIGURED)       },
    { FN(TG(36))                       , ST(UP)          , EV(BIST_REQ)               , ST(BIST)             },
    { FN(TG(37))                       , ST(POWERING_UP) , EV(LANE_NOT_READY_IND)     , ST(POWERING_UP)      },
    { FN(TG(37))                       , ST(DEFERRED_UP) , EV(LANE_NOT_READY_IND)     , ST(DEFERRED_UP)      },
    { FN(TG(38))                       , ST(CONFIGURED)  , EV(ADMIN_UP_REQ)           , ST(POWERING_UP)      },
    { FN(TG(38))                       , ST(CONFIGURED)  , EV(ADMIN_DOWN_REQ)         , ST(POWERING_UP)      },
    { FN(TG(39))                       , ST(BIST)        , EV(CONFIG_REQ)             , ST(POWERING_UP)      },
    { FN(TG(40))                       , ST(POWERING_UP) , EV(DISABLE_REQ)            , ST(NEED_CONFIG)      },
    { FN(TG(40))                       , ST(ADMIN_FAULT) , EV(DISABLE_REQ)            , ST(NEED_CONFIG)      },
    { FN(TG(41))                       , ST(UP)          , EV(DEFTIMER_EXP_IND)       , ST(UP)               }
};

static const fm_smTable fm10000PcieSmTable[] = {
    { FN(TG(76))                      , ST(DISABLED), EV(LINK_DOWN_IND)          , ST(DISABLED)         },
    { FN(TG(76))                      , ST(DOWN)    , EV(LINK_DOWN_IND)          , ST(DOWN)             },
    { FN(TG(77))                      , ST(DOWN)    , EV(FABRIC_LOOPBACK_OFF_REQ), ST(DOWN)             },
    { FN(TG(77))                      , ST(UP)      , EV(FABRIC_LOOPBACK_OFF_REQ), ST(UP)               },
    { FN(TG(78))                      , ST(UP)      , EV(LINK_UP_IND)            , ST(UP)               },
    { FN(TG(79))                      , ST(DOWN)    , EV(FABRIC_LOOPBACK_ON_REQ) , ST(DOWN)             },
    { FN(TG(80))                      , ST(DOWN)    , EV(DISABLE_REQ)            , ST(DISABLED)         },
    { FN(TG(80))                      , ST(UP)      , EV(DISABLE_REQ)            , ST(DISABLED)         },
    { FN(TG(81))                      , ST(DOWN)    , EV(LINK_UP_IND)            , ST(UP)               },
    { FN(TG(37))                      , ST(DISABLED), EV(LOOPBACK_ON_REQ)        , ST(DISABLED)         },
    { FN(TG(37))                      , ST(DISABLED), EV(LOOPBACK_OFF_REQ)       , ST(DISABLED)         },
    { FN(TG(37))                      , ST(DISABLED), EV(ADMIN_PWRDOWN_REQ)      , ST(DISABLED)         },
    { FN(TG(37))                      , ST(DISABLED), EV(REMOTE_FAULT_REQ)       , ST(DISABLED)         },
    { FN(TG(37))                      , ST(DISABLED), EV(LOCAL_FAULT_REQ)        , ST(DISABLED)         },
    { FN(TG(37))                      , ST(DISABLED), EV(BIST_REQ)               , ST(DISABLED)         },
    { FN(TG(37))                      , ST(DISABLED), EV(REMOTE_FAULT_IND)       , ST(DISABLED)         },
    { FN(TG(37))                      , ST(DISABLED), EV(LOCAL_FAULT_IND)        , ST(DISABLED)         },
    { FN(TG(37))                      , ST(DISABLED), EV(LANE_DFE_COMPLETE_IND)  , ST(DISABLED)         },
    { FN(TG(37))                      , ST(DISABLED), EV(LANE_DFE_FAILED_IND)    , ST(DISABLED)         },
    { FN(TG(37))                      , ST(DISABLED), EV(LANE_KR_COMPLETE_IND)   , ST(DISABLED)         },
    { FN(TG(37))                      , ST(DISABLED), EV(LANE_KR_FAILED_IND)     , ST(DISABLED)         },
    { FN(TG(37))                      , ST(DISABLED), EV(LANE_READY_IND)         , ST(DISABLED)         },
    { FN(TG(37))                      , ST(DISABLED), EV(LANE_NOT_READY_IND)     , ST(DISABLED)         },
    { FN(TG(37))                      , ST(DISABLED), EV(DEFTIMER_EXP_IND)       , ST(DISABLED)         },
    { FN(TG(37))                      , ST(DOWN)    , EV(CONFIG_REQ)             , ST(DOWN)             },
    { FN(TG(37))                      , ST(DOWN)    , EV(LOOPBACK_ON_REQ)        , ST(DOWN)             },
    { FN(TG(37))                      , ST(DOWN)    , EV(LOOPBACK_OFF_REQ)       , ST(DOWN)             },
    { FN(TG(37))                      , ST(DOWN)    , EV(ADMIN_PWRDOWN_REQ)      , ST(DOWN)             },
    { FN(TG(37))                      , ST(DOWN)    , EV(REMOTE_FAULT_REQ)       , ST(DOWN)             },
    { FN(TG(37))                      , ST(DOWN)    , EV(LOCAL_FAULT_REQ)        , ST(DOWN)             },
    { FN(TG(37))                      , ST(DOWN)    , EV(BIST_REQ)               , ST(DOWN)             },
    { FN(TG(37))                      , ST(DOWN)    , EV(REMOTE_FAULT_IND)       , ST(DOWN)             },
    { FN(TG(37))                      , ST(DOWN)    , EV(LOCAL_FAULT_IND)        , ST(DOWN)             },
    { FN(TG(37))                      , ST(DOWN)    , EV(LANE_DFE_COMPLETE_IND)  , ST(DOWN)             },
    { FN(TG(37))                      , ST(DOWN)    , EV(LANE_DFE_FAILED_IND)    , ST(DOWN)             },
    { FN(TG(37))                      , ST(DOWN)    , EV(LANE_KR_COMPLETE_IND)   , ST(DOWN)             },
    { FN(TG(37))                      , ST(DOWN)    , EV(LANE_KR_FAILED_IND)     , ST(DOWN)             },
    { FN(TG(37))                      , ST(DOWN)    , EV(LANE_READY_IND)         , ST(DOWN)             },
    { FN(TG(37))                      , ST(DOWN)    , EV(LANE_NOT_READY_IND)     , ST(DOWN)             },
    { FN(TG(37))                      , ST(DOWN)    , EV(DEFTIMER_EXP_IND)       , ST(DOWN)             },
    { FN(TG(37))                      , ST(UP)      , EV(CONFIG_REQ)             , ST(UP)               },
    { FN(TG(37))                      , ST(UP)      , EV(LOOPBACK_ON_REQ)        , ST(UP)               },
    { FN(TG(37))                      , ST(UP)      , EV(LOOPBACK_OFF_REQ)       , ST(UP)               },
    { FN(TG(37))                      , ST(UP)      , EV(ADMIN_PWRDOWN_REQ)      , ST(UP)               },
    { FN(TG(37))                      , ST(UP)      , EV(REMOTE_FAULT_REQ)       , ST(UP)               },
    { FN(TG(37))                      , ST(UP)      , EV(LOCAL_FAULT_REQ)        , ST(UP)               },
    { FN(TG(37))                      , ST(UP)      , EV(BIST_REQ)               , ST(UP)               },
    { FN(TG(37))                      , ST(UP)      , EV(REMOTE_FAULT_IND)       , ST(UP)               },
    { FN(TG(37))                      , ST(UP)      , EV(LOCAL_FAULT_IND)        , ST(UP)               },
    { FN(TG(37))                      , ST(UP)      , EV(LANE_DFE_COMPLETE_IND)  , ST(UP)               },
    { FN(TG(37))                      , ST(UP)      , EV(LANE_DFE_FAILED_IND)    , ST(UP)               },
    { FN(TG(37))                      , ST(UP)      , EV(LANE_KR_COMPLETE_IND)   , ST(UP)               },
    { FN(TG(37))                      , ST(UP)      , EV(LANE_KR_FAILED_IND)     , ST(UP)               },
    { FN(TG(37))                      , ST(UP)      , EV(LANE_READY_IND)         , ST(UP)               },
    { FN(TG(37))                      , ST(UP)      , EV(LANE_NOT_READY_IND)     , ST(UP)               },
    { FN(TG(37))                      , ST(UP)      , EV(DEFTIMER_EXP_IND)       , ST(UP)               },
    { FN(TG(82))                      , ST(UP)      , EV(FABRIC_LOOPBACK_ON_REQ) , ST(UP)               },
    { FN(TG(83))                      , ST(DISABLED), EV(LINK_UP_IND)            , ST(DISABLED)         },
    { FN(TG(84))                      , ST(DOWN)    , EV(ADMIN_DOWN_REQ)         , ST(DOWN)             },
    { FN(TG(84))                      , ST(UP)      , EV(ADMIN_DOWN_REQ)         , ST(UP)               },
    { FN(ConfigureDeviceAndCheckState), ST(DISABLED), EV(CONFIG_REQ)             , FM_STATE_UNSPECIFIED },
    { FN(TG(85))                      , ST(DOWN)    , EV(ADMIN_UP_REQ)           , ST(DOWN)             },
    { FN(TG(85))                      , ST(UP)      , EV(ADMIN_UP_REQ)           , ST(UP)               },
    { FN(TG(86))                      , ST(UP)      , EV(LINK_DOWN_IND)          , ST(DOWN)             }
};



/*****************************************************************************
 * Local Functions
 *****************************************************************************/

/*****************************************************************************/
/* PowerUpLane
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status PowerUpLane( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing PowerUpLane\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000PowerUpLane( eventInfo, userInfo );

    return status;

}   /* end PowerUpLane */


/*****************************************************************************/
/* PowerUpLaneRx
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status PowerUpLaneRx( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing PowerUpLaneRx\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000PowerUpLaneRx( eventInfo, userInfo );

    return status;

}   /* end PowerUpLaneRx */


/*****************************************************************************/
/* PowerUpLaneTx
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status PowerUpLaneTx( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing PowerUpLaneTx\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000PowerUpLaneTx( eventInfo, userInfo );

    return status;

}   /* end PowerUpLaneTx */


/*****************************************************************************/
/* PowerDownLane
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status PowerDownLane( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing PowerDownLane\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000PowerDownLane( eventInfo, userInfo );

    return status;

}   /* end PowerDownLane */


/*****************************************************************************/
/* PowerDownLaneRx
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status PowerDownLaneRx( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing PowerDownLaneRx\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000PowerDownLaneRx( eventInfo, userInfo );

    return status;

}   /* end PowerDownLaneRx */


/*****************************************************************************/
/* PowerDownLaneTx
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status PowerDownLaneTx( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing PowerDownLaneTx\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000PowerDownLaneTx( eventInfo, userInfo );

    return status;

}   /* end PowerDownLaneTx */


/*****************************************************************************/
/* ReleaseSchedBwAdmDown
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status ReleaseSchedBwAdmDown( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing ReleaseSchedBwAdmDown\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ReleaseSchedBwAdmDown( eventInfo, userInfo );

    return status;

}   /* end ReleaseSchedBwAdmDown */


/*****************************************************************************/
/* RequestSchedBwAdmUp
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status RequestSchedBwAdmUp( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing RequestSchedBwAdmUp\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000RequestSchedBwAdmUp( eventInfo, userInfo );

    return status;

}   /* end RequestSchedBwAdmUp */


/*****************************************************************************/
/* ReleaseSchedBwLnkDown
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status ReleaseSchedBwLnkDown( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing ReleaseSchedBwLnkDown\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ReleaseSchedBwLnkDown( eventInfo, userInfo );

    return status;

}   /* end ReleaseSchedBwLnkDown */


/*****************************************************************************/
/* RequestSchedBwLnkUp
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status RequestSchedBwLnkUp( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing RequestSchedBwLnkUp\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000RequestSchedBwLnkUp( eventInfo, userInfo );

    return status;

}   /* end RequestSchedBwLnkUp */


/*****************************************************************************/
/* ConfigureLane
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status ConfigureLane( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing ConfigureLane\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ConfigureLane( eventInfo, userInfo );

    return status;

}   /* end ConfigureLane */


/*****************************************************************************/
/* ConfigureLaneForAn73
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status ConfigureLaneForAn73( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing ConfigureLaneForAn73\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ConfigureLaneForAn73( eventInfo, userInfo );

    return status;

}   /* end ConfigureLaneForAn73 */


/*****************************************************************************/
/* NotifyApiPortUp
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status NotifyApiPortUp( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing NotifyApiPortUp\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000NotifyApiPortUp( eventInfo, userInfo );

    return status;

}   /* end NotifyApiPortUp */


/*****************************************************************************/
/* NotifyApiPortDown
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status NotifyApiPortDown( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing NotifyApiPortDown\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000NotifyApiPortDown( eventInfo, userInfo );

    return status;

}   /* end NotifyApiPortDown */


/*****************************************************************************/
/* ConfigureLoopback
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status ConfigureLoopback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing ConfigureLoopback\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ConfigureLoopback( eventInfo, userInfo );

    return status;

}   /* end ConfigureLoopback */


/*****************************************************************************/
/* RestoreTxFaultMode
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status RestoreTxFaultMode( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing RestoreTxFaultMode\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000RestoreTxFaultMode( eventInfo, userInfo );

    return status;

}   /* end RestoreTxFaultMode */


/*****************************************************************************/
/* SetTxFaultMode
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SetTxFaultMode( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing SetTxFaultMode\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000SetTxFaultMode( eventInfo, userInfo );

    return status;

}   /* end SetTxFaultMode */


/*****************************************************************************/
/* SetTxFaultModeToNormal
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SetTxFaultModeToNormal( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing SetTxFaultModeToNormal\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000SetTxFaultModeToNormal( eventInfo, userInfo );

    return status;

}   /* end SetTxFaultModeToNormal */


/*****************************************************************************/
/* InitPcs
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status InitPcs( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing InitPcs\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000InitPcs( eventInfo, userInfo );

    return status;

}   /* end InitPcs */


/*****************************************************************************/
/* Init1000BaseX
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status Init1000BaseX( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing Init1000BaseX\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000Init1000BaseX( eventInfo, userInfo );

    return status;

}   /* end Init1000BaseX */


/*****************************************************************************/
/* Init10GBaseR
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status Init10GBaseR( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing Init10GBaseR\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000Init10GBaseR( eventInfo, userInfo );

    return status;

}   /* end Init10GBaseR */


/*****************************************************************************/
/* InitMlBaseR
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status InitMlBaseR( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing InitMlBaseR\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000InitMlBaseR( eventInfo, userInfo );

    return status;

}   /* end InitMlBaseR */


/*****************************************************************************/
/* InitAn73
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status InitAn73( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing InitAn73\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000InitAn73( eventInfo, userInfo );

    return status;

}   /* end InitAn73 */


/*****************************************************************************/
/* WriteEplCfgA
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status WriteEplCfgA( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing WriteEplCfgA\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000WriteEplCfgA( eventInfo, userInfo );

    return status;

}   /* end WriteEplCfgA */


/*****************************************************************************/
/* WriteEplCfgB
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status WriteEplCfgB( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing WriteEplCfgB\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000WriteEplCfgB( eventInfo, userInfo );

    return status;

}   /* end WriteEplCfgB */


/*****************************************************************************/
/* WriteMac
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status WriteMac( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing WriteMac\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000WriteMac( eventInfo, userInfo );

    return status;

}   /* end WriteMac */


/*****************************************************************************/
/* EnableDrainMode
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status EnableDrainMode( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing EnableDrainMode\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000EnableDrainMode( eventInfo, userInfo );

    return status;

}   /* end EnableDrainMode */


/*****************************************************************************/
/* DisableDrainMode
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status DisableDrainMode( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing DisableDrainMode\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000DisableDrainMode( eventInfo, userInfo );

    return status;

}   /* end DisableDrainMode */


/*****************************************************************************/
/* EnablePhy
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status EnablePhy( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing EnablePhy\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000EnablePhy( eventInfo, userInfo );

    return status;

}   /* end EnablePhy */


/*****************************************************************************/
/* DisablePhy
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status DisablePhy( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing DisablePhy\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000DisablePhy( eventInfo, userInfo );

    return status;

}   /* end DisablePhy */


/*****************************************************************************/
/* EnableLinkInterrupts
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status EnableLinkInterrupts( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing EnableLinkInterrupts\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000EnableLinkInterrupts( eventInfo, userInfo );

    return status;

}   /* end EnableLinkInterrupts */


/*****************************************************************************/
/* DisableLinkInterrupts
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status DisableLinkInterrupts( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing DisableLinkInterrupts\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000DisableLinkInterrupts( eventInfo, userInfo );

    return status;

}   /* end DisableLinkInterrupts */


/*****************************************************************************/
/* ResetPortModuleState
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status ResetPortModuleState( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing ResetPortModuleState\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ResetPortModuleState( eventInfo, userInfo );

    return status;

}   /* end ResetPortModuleState */


/*****************************************************************************/
/* EnableLoopback
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status EnableLoopback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing EnableLoopback\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000EnableLoopback( eventInfo, userInfo );

    return status;

}   /* end EnableLoopback */


/*****************************************************************************/
/* DisableLoopback
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status DisableLoopback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing DisableLoopback\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000DisableLoopback( eventInfo, userInfo );

    return status;

}   /* end DisableLoopback */


/*****************************************************************************/
/* EnableFabricLoopback
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status EnableFabricLoopback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing EnableFabricLoopback\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000EnableFabricLoopback( eventInfo, userInfo );

    return status;

}   /* end EnableFabricLoopback */


/*****************************************************************************/
/* DisableFabricLoopback
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status DisableFabricLoopback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing DisableFabricLoopback\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000DisableFabricLoopback( eventInfo, userInfo );

    return status;

}   /* end DisableFabricLoopback */


/*****************************************************************************/
/* ClearEplFifo
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status ClearEplFifo( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing ClearEplFifo\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ClearEplFifo( eventInfo, userInfo );

    return status;

}   /* end ClearEplFifo */


/*****************************************************************************/
/* EnableBistMode
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status EnableBistMode( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing EnableBistMode\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000EnableBistMode( eventInfo, userInfo );

    return status;

}   /* end EnableBistMode */


/*****************************************************************************/
/* DisableBistMode
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status DisableBistMode( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing DisableBistMode\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000DisableBistMode( eventInfo, userInfo );

    return status;

}   /* end DisableBistMode */


/*****************************************************************************/
/* Restart100gSyncDetection
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status Restart100gSyncDetection( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing Restart100gSyncDetection\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000Restart100gSyncDetection( eventInfo, userInfo );

    return status;

}   /* end Restart100gSyncDetection */


/*****************************************************************************/
/* StartDeferralTimer
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status StartDeferralTimer( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing StartDeferralTimer\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000StartDeferralTimer( eventInfo, userInfo );

    return status;

}   /* end StartDeferralTimer */


/*****************************************************************************/
/* StopDeferralTimer
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status StopDeferralTimer( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing StopDeferralTimer\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000StopDeferralTimer( eventInfo, userInfo );

    return status;

}   /* end StopDeferralTimer */


/*****************************************************************************/
/* FlagError
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status FlagError( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing FlagError\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000FlagError( eventInfo, userInfo );

    return status;

}   /* end FlagError */


/*****************************************************************************/
/* ConfigureDfe
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status ConfigureDfe( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing ConfigureDfe\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ConfigureDfe( eventInfo, userInfo );

    return status;

}   /* end ConfigureDfe */


/*****************************************************************************/
/* LinkPortToLanes
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status LinkPortToLanes( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing LinkPortToLanes\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000LinkPortToLanes( eventInfo, userInfo );

    return status;

}   /* end LinkPortToLanes */


/*****************************************************************************/
/* UnlinkPortFromLanes
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status UnlinkPortFromLanes( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing UnlinkPortFromLanes\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000UnlinkPortFromLanes( eventInfo, userInfo );

    return status;

}   /* end UnlinkPortFromLanes */


/*****************************************************************************/
/* UpdatePcieModeAndSpeed
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status UpdatePcieModeAndSpeed( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing UpdatePcieModeAndSpeed\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000UpdatePcieModeAndSpeed( eventInfo, userInfo );

    return status;

}   /* end UpdatePcieModeAndSpeed */


/*****************************************************************************/
/* UpdatePcieLaneReversal
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status UpdatePcieLaneReversal( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing UpdatePcieLaneReversal\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000UpdatePcieLaneReversal( eventInfo, userInfo );

    return status;

}   /* end UpdatePcieLaneReversal */


/*****************************************************************************/
/* EnablePcieInterrupts
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status EnablePcieInterrupts( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing EnablePcieInterrupts\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000EnablePcieInterrupts( eventInfo, userInfo );

    return status;

}   /* end EnablePcieInterrupts */


/*****************************************************************************/
/* DisablePcieInterrupts
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status DisablePcieInterrupts( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing DisablePcieInterrupts\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000DisablePcieInterrupts( eventInfo, userInfo );

    return status;

}   /* end DisablePcieInterrupts */


/*****************************************************************************/
/* AnStart
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status AnStart( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing AnStart\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000AnStart( eventInfo, userInfo );

    return status;

}   /* end AnStart */


/*****************************************************************************/
/* AnStop
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status AnStop( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing AnStop\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000AnStop( eventInfo, userInfo );

    return status;

}   /* end AnStop */


/*****************************************************************************/
/* ReconfigurePortForAn
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status ReconfigurePortForAn( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing ReconfigurePortForAn\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ReconfigurePortForAn( eventInfo, userInfo );

    return status;

}   /* end ReconfigurePortForAn */


/*****************************************************************************/
/* RestoreDfe
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status RestoreDfe( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing RestoreDfe\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000RestoreDfe( eventInfo, userInfo );

    return status;

}   /* end RestoreDfe */


/*****************************************************************************/
/* ReconfigureScheduler
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status ReconfigureScheduler( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing ReconfigureScheduler\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ReconfigureScheduler( eventInfo, userInfo );

    return status;

}   /* end ReconfigureScheduler */


/*****************************************************************************/
/* ConfigureFarLoopback
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status ConfigureFarLoopback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing ConfigureFarLoopback\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ConfigureFarLoopback( eventInfo, userInfo );

    return status;

}   /* end ConfigureFarLoopback */


/*****************************************************************************/
/* EnableLowPowerIdle
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status EnableLowPowerIdle( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing EnableLowPowerIdle\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000EnableLowPowerIdle( eventInfo, userInfo );

    return status;

}   /* end EnableLowPowerIdle */


/*****************************************************************************/
/* InitPepMailbox
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status InitPepMailbox( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing InitPepMailbox\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000InitPepMailbox( eventInfo, userInfo );

    return status;

}   /* end InitPepMailbox */


/*****************************************************************************/
/* EnablePepLoopback
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status EnablePepLoopback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing EnablePepLoopback\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000EnablePepLoopback( eventInfo, userInfo );

    return status;

}   /* end EnablePepLoopback */


/*****************************************************************************/
/* DisablePepLoopback
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status DisablePepLoopback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing DisablePepLoopback\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000DisablePepLoopback( eventInfo, userInfo );

    return status;

}   /* end DisablePepLoopback */


/*****************************************************************************/
/* NotifyEthModeChange
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status NotifyEthModeChange( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing NotifyEthModeChange\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000NotifyEthModeChange( eventInfo, userInfo );

    return status;

}   /* end NotifyEthModeChange */


/*****************************************************************************/
/* EnablePhyAutoneg
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status EnablePhyAutoneg( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing EnablePhyAutoneg\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000EnablePhyAutoneg( eventInfo, userInfo );

    return status;

}   /* end EnablePhyAutoneg */


/*****************************************************************************/
/* DisablePhyAutoneg
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status DisablePhyAutoneg( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing DisablePhyAutoneg\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000DisablePhyAutoneg( eventInfo, userInfo );

    return status;

}   /* end DisablePhyAutoneg */


/*****************************************************************************/
/* StartAnWatchDogTimer
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status StartAnWatchDogTimer( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing StartAnWatchDogTimer\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000StartAnWatchDogTimer( eventInfo, userInfo );

    return status;

}   /* end StartAnWatchDogTimer */


/*****************************************************************************/
/* StopAnWatchDogTimer
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status StopAnWatchDogTimer( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing StopAnWatchDogTimer\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000StopAnWatchDogTimer( eventInfo, userInfo );

    return status;

}   /* end StopAnWatchDogTimer */


/*****************************************************************************/
/* StartDeferredLpiTimer
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status StartDeferredLpiTimer( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing StartDeferredLpiTimer\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000StartDeferredLpiTimer( eventInfo, userInfo );

    return status;

}   /* end StartDeferredLpiTimer */


/*****************************************************************************/
/* StopDeferredLpiTimer
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status StopDeferredLpiTimer( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing StopDeferredLpiTimer\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000StopDeferredLpiTimer( eventInfo, userInfo );

    return status;

}   /* end StopDeferredLpiTimer */


/*****************************************************************************/
/* DeferredLpiMode
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status DeferredLpiMode( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing DeferredLpiMode\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000DeferredLpiMode( eventInfo, userInfo );

    return status;

}   /* end DeferredLpiMode */


/*****************************************************************************/
/* StartPortStatusPollingTimer
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status StartPortStatusPollingTimer( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing StartPortStatusPollingTimer\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000StartPortStatusPollingTimer( eventInfo, userInfo );

    return status;

}   /* end StartPortStatusPollingTimer */


/*****************************************************************************/
/* StopPortStatusPollingTimer
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status StopPortStatusPollingTimer( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing StopPortStatusPollingTimer\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000StopPortStatusPollingTimer( eventInfo, userInfo );

    return status;

}   /* end StopPortStatusPollingTimer */


/*****************************************************************************/
/* CheckAndPreReserveSchedBw
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status CheckAndPreReserveSchedBw( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing CheckAndPreReserveSchedBw\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000CheckAndPreReserveSchedBw( eventInfo, userInfo );

    return status;

}   /* end CheckAndPreReserveSchedBw */


/*****************************************************************************/
/* RequestSchedBwAdmUpAn
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status RequestSchedBwAdmUpAn( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing RequestSchedBwAdmUpAn\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000RequestSchedBwAdmUpAn( eventInfo, userInfo );

    return status;

}   /* end RequestSchedBwAdmUpAn */


/*****************************************************************************/
/* CheckLanesReady
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status CheckLanesReady( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    /* this log message can be modified once the port-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing CheckLanesReady\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000CheckLanesReady( eventInfo, userInfo, nextState );

    return status;

}   /* end CheckLanesReady */


/*****************************************************************************/
/* ProcessDeferralTimer
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status ProcessDeferralTimer( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    /* this log message can be modified once the port-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing ProcessDeferralTimer\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ProcessDeferralTimer( eventInfo, userInfo, nextState );

    return status;

}   /* end ProcessDeferralTimer */


/*****************************************************************************/
/* ProcessDeferralTimerWithAn
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status ProcessDeferralTimerWithAn( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    /* this log message can be modified once the port-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing ProcessDeferralTimerWithAn\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ProcessDeferralTimerWithAn( eventInfo, userInfo, nextState );

    return status;

}   /* end ProcessDeferralTimerWithAn */


/*****************************************************************************/
/* ProcessPortStatusPollingTimer
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status ProcessPortStatusPollingTimer( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    /* this log message can be modified once the port-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing ProcessPortStatusPollingTimer\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ProcessPortStatusPollingTimer( eventInfo, userInfo, nextState );

    return status;

}   /* end ProcessPortStatusPollingTimer */


/*****************************************************************************/
/* ProcessPortStatus
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status ProcessPortStatus( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    /* this log message can be modified once the port-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing ProcessPortStatus\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ProcessPortStatus( eventInfo, userInfo, nextState );

    return status;

}   /* end ProcessPortStatus */


/*****************************************************************************/
/* ConfigureDeviceAndCheckState
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status ConfigureDeviceAndCheckState( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    /* this log message can be modified once the port-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing ConfigureDeviceAndCheckState\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ConfigureDeviceAndCheckState( eventInfo, userInfo, nextState );

    return status;

}   /* end ConfigureDeviceAndCheckState */


/*****************************************************************************/
/* CheckPortStatus
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status CheckPortStatus( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    /* this log message can be modified once the port-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing CheckPortStatus\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000CheckPortStatus( eventInfo, userInfo, nextState );

    return status;

}   /* end CheckPortStatus */


/*****************************************************************************/
/* AnRestart
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status AnRestart( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    /* this log message can be modified once the port-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing AnRestart\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000AnRestart( eventInfo, userInfo, nextState );

    return status;

}   /* end AnRestart */


/*****************************************************************************/
/* EnterNegotiatedMode
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status EnterNegotiatedMode( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    /* this log message can be modified once the port-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing EnterNegotiatedMode\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000EnterNegotiatedMode( eventInfo, userInfo, nextState );

    return status;

}   /* end EnterNegotiatedMode */


/*****************************************************************************/
/* SetupAdminModeUp
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SetupAdminModeUp( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    /* this log message can be modified once the port-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing SetupAdminModeUp\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000SetupAdminModeUp( eventInfo, userInfo, nextState );

    return status;

}   /* end SetupAdminModeUp */


/*****************************************************************************/
/* ExitBistMode
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status ExitBistMode( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    /* this log message can be modified once the port-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing ExitBistMode\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ExitBistMode( eventInfo, userInfo, nextState );

    return status;

}   /* end ExitBistMode */


/*****************************************************************************/
/* ExitAdminFaultMode
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status ExitAdminFaultMode( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    /* this log message can be modified once the port-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing ExitAdminFaultMode\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ExitAdminFaultMode( eventInfo, userInfo, nextState );

    return status;

}   /* end ExitAdminFaultMode */


/*****************************************************************************/
/* ProcessDisableFabricLoopback
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status ProcessDisableFabricLoopback( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    /* this log message can be modified once the port-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT,
                     port,
                     "Event %s occurred on port %d, executing ProcessDisableFabricLoopback\n", 
                     fm10000PortEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ProcessDisableFabricLoopback( eventInfo, userInfo, nextState );

    return status;

}   /* end ProcessDisableFabricLoopback */




/******************************************************************************
 * Definitions of transition group callbacks 
 *****************************************************************************/


/*****************************************************************************/
/* TransitionGroup0
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(0)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = StartPortStatusPollingTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup0 */


/*****************************************************************************/
/* TransitionGroup1
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(1)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureFarLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup1 */


/*****************************************************************************/
/* TransitionGroup2
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(2)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = StopDeferredLpiTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup2 */


/*****************************************************************************/
/* TransitionGroup3
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(3)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = DisableLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup3 */


/*****************************************************************************/
/* TransitionGroup4
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(4)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup4 */


/*****************************************************************************/
/* TransitionGroup5
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(5)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = StopPortStatusPollingTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = UnlinkPortFromLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup5 */


/*****************************************************************************/
/* TransitionGroup6
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(6)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = StopDeferralTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureFarLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup6 */


/*****************************************************************************/
/* TransitionGroup7
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(7)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = StopPortStatusPollingTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReleaseSchedBwAdmDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup7 */


/*****************************************************************************/
/* TransitionGroup8
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(8)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup8 */


/*****************************************************************************/
/* TransitionGroup9
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(9)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = ConfigureDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup9 */


/*****************************************************************************/
/* TransitionGroup10
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(10)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = EnableDrainMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = StopDeferredLpiTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReleaseSchedBwLnkDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisableDrainMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = UnlinkPortFromLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup10 */


/*****************************************************************************/
/* TransitionGroup11
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(11)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = EnableLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup11 */


/*****************************************************************************/
/* TransitionGroup12
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(12)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = StopDeferredLpiTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = StartPortStatusPollingTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReleaseSchedBwLnkDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup12 */


/*****************************************************************************/
/* TransitionGroup13
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(13)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = RequestSchedBwAdmUp( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup13 */


/*****************************************************************************/
/* TransitionGroup14
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(14)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = StopDeferredLpiTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReleaseSchedBwAdmDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReleaseSchedBwLnkDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup14 */


/*****************************************************************************/
/* TransitionGroup15
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(15)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = StartPortStatusPollingTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup15 */


/*****************************************************************************/
/* TransitionGroup16
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(16)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = StopDeferralTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReleaseSchedBwAdmDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup16 */


/*****************************************************************************/
/* TransitionGroup17
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(17)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = StopPortStatusPollingTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureFarLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup17 */


/*****************************************************************************/
/* TransitionGroup18
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(18)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = StopPortStatusPollingTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnableDrainMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnableFabricLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisableDrainMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = RequestSchedBwLnkUp( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyApiPortUp( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup18 */


/*****************************************************************************/
/* TransitionGroup19
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(19)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup19 */


/*****************************************************************************/
/* TransitionGroup20
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(20)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup20 */


/*****************************************************************************/
/* TransitionGroup21
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(21)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = EnableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup21 */


/*****************************************************************************/
/* TransitionGroup22
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(22)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = StopPortStatusPollingTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup22 */


/*****************************************************************************/
/* TransitionGroup23
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(23)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = EnableLowPowerIdle( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup23 */


/*****************************************************************************/
/* TransitionGroup24
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(24)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = UnlinkPortFromLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup24 */


/*****************************************************************************/
/* TransitionGroup25
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(25)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReleaseSchedBwAdmDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup25 */


/*****************************************************************************/
/* TransitionGroup26
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(26)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = StopDeferralTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = UnlinkPortFromLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup26 */


/*****************************************************************************/
/* TransitionGroup27
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(27)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = StopDeferredLpiTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReleaseSchedBwLnkDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup27 */


/*****************************************************************************/
/* TransitionGroup28
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(28)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = RestoreTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureFarLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup28 */


/*****************************************************************************/
/* TransitionGroup29
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(29)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = StopPortStatusPollingTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup29 */


/*****************************************************************************/
/* TransitionGroup30
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(30)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = DisableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnableDrainMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnableFabricLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisableDrainMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup30 */


/*****************************************************************************/
/* TransitionGroup31
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(31)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup31 */


/*****************************************************************************/
/* TransitionGroup32
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(32)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = StopDeferredLpiTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReleaseSchedBwLnkDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureFarLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup32 */


/*****************************************************************************/
/* TransitionGroup33
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(33)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = DisableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = UnlinkPortFromLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup33 */


/*****************************************************************************/
/* TransitionGroup34
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(34)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = RequestSchedBwLnkUp( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyApiPortUp( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup34 */


/*****************************************************************************/
/* TransitionGroup35
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(35)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = DisableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReleaseSchedBwAdmDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup35 */


/*****************************************************************************/
/* TransitionGroup36
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(36)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = StopDeferredLpiTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReleaseSchedBwLnkDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup36 */


/*****************************************************************************/
/* TransitionGroup37
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(37)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = FlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup37 */


/*****************************************************************************/
/* TransitionGroup38
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(38)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureFarLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = RequestSchedBwAdmUp( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup38 */


/*****************************************************************************/
/* TransitionGroup39
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(39)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = DisableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureFarLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup39 */


/*****************************************************************************/
/* TransitionGroup40
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(40)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = UnlinkPortFromLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup40 */


/*****************************************************************************/
/* TransitionGroup41
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(41)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = DeferredLpiMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup41 */


/*****************************************************************************/
/* TransitionGroup42
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(42)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = StopAnWatchDogTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReleaseSchedBwAdmDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup42 */


/*****************************************************************************/
/* TransitionGroup43
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(43)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = CheckAndPreReserveSchedBw( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup43 */


/*****************************************************************************/
/* TransitionGroup44
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(44)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = CheckAndPreReserveSchedBw( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = SetTxFaultModeToNormal( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup44 */


/*****************************************************************************/
/* TransitionGroup45
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(45)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = StopDeferredLpiTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReleaseSchedBwLnkDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup45 */


/*****************************************************************************/
/* TransitionGroup46
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(46)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = AnStart( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = StartAnWatchDogTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup46 */


/*****************************************************************************/
/* TransitionGroup47
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(47)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReleaseSchedBwAdmDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReconfigurePortForAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup47 */


/*****************************************************************************/
/* TransitionGroup48
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(48)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = CheckAndPreReserveSchedBw( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = AnStart( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = StartAnWatchDogTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup48 */


/*****************************************************************************/
/* TransitionGroup49
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(49)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = StopDeferredLpiTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReleaseSchedBwLnkDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup49 */


/*****************************************************************************/
/* TransitionGroup50
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(50)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = StopAnWatchDogTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = CheckAndPreReserveSchedBw( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup50 */


/*****************************************************************************/
/* TransitionGroup51
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(51)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = StopDeferralTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = CheckAndPreReserveSchedBw( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup51 */


/*****************************************************************************/
/* TransitionGroup52
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(52)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = SetTxFaultModeToNormal( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup52 */


/*****************************************************************************/
/* TransitionGroup53
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(53)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = StopDeferredLpiTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = CheckAndPreReserveSchedBw( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReleaseSchedBwLnkDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup53 */


/*****************************************************************************/
/* TransitionGroup54
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(54)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = DisableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReleaseSchedBwAdmDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReconfigurePortForAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup54 */


/*****************************************************************************/
/* TransitionGroup55
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(55)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup55 */


/*****************************************************************************/
/* TransitionGroup56
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(56)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = SetTxFaultMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReleaseSchedBwLnkDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup56 */


/*****************************************************************************/
/* TransitionGroup57
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(57)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = UnlinkPortFromLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup57 */


/*****************************************************************************/
/* TransitionGroup58
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(58)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = SetTxFaultModeToNormal( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = RequestSchedBwAdmUpAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup58 */


/*****************************************************************************/
/* TransitionGroup59
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(59)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = StopAnWatchDogTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = UnlinkPortFromLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup59 */


/*****************************************************************************/
/* TransitionGroup60
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(60)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = StopAnWatchDogTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup60 */


/*****************************************************************************/
/* TransitionGroup61
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(61)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReleaseSchedBwAdmDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReconfigurePortForAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup61 */


/*****************************************************************************/
/* TransitionGroup62
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(62)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = DisableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = UnlinkPortFromLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup62 */


/*****************************************************************************/
/* TransitionGroup63
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(63)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = EnableDrainMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = StopDeferredLpiTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReleaseSchedBwLnkDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisableDrainMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = UnlinkPortFromLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup63 */


/*****************************************************************************/
/* TransitionGroup64
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(64)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup64 */


/*****************************************************************************/
/* TransitionGroup65
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(65)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup65 */


/*****************************************************************************/
/* TransitionGroup66
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(66)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = StopDeferralTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = UnlinkPortFromLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup66 */


/*****************************************************************************/
/* TransitionGroup67
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(67)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = StopDeferralTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReleaseSchedBwAdmDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup67 */


/*****************************************************************************/
/* TransitionGroup68
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(68)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = DisableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup68 */


/*****************************************************************************/
/* TransitionGroup69
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(69)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = CheckAndPreReserveSchedBw( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup69 */


/*****************************************************************************/
/* TransitionGroup70
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(70)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = DisableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = CheckAndPreReserveSchedBw( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup70 */


/*****************************************************************************/
/* TransitionGroup71
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(71)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = StopDeferredLpiTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReleaseSchedBwAdmDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReleaseSchedBwLnkDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReconfigurePortForAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup71 */


/*****************************************************************************/
/* TransitionGroup72
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(72)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = CheckAndPreReserveSchedBw( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = SetTxFaultModeToNormal( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = RestoreDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerUpLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ClearEplFifo( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnableLinkInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup72 */


/*****************************************************************************/
/* TransitionGroup73
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(73)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = DisablePhy( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePhyAutoneg( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = PowerDownLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = UnlinkPortFromLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup73 */


/*****************************************************************************/
/* TransitionGroup74
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(74)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = ResetPortModuleState( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = CheckAndPreReserveSchedBw( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = LinkPortToLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgA( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteEplCfgB( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = WriteMac( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = InitPcs( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyEthModeChange( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup74 */


/*****************************************************************************/
/* TransitionGroup75
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(75)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = StopDeferredLpiTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = AnStop( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReleaseSchedBwLnkDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup75 */


/*****************************************************************************/
/* TransitionGroup76
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(76)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = EnablePcieInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup76 */


/*****************************************************************************/
/* TransitionGroup77
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(77)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = DisablePepLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup77 */


/*****************************************************************************/
/* TransitionGroup78
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(78)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = UpdatePcieModeAndSpeed( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = UpdatePcieLaneReversal( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnablePcieInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup78 */


/*****************************************************************************/
/* TransitionGroup79
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(79)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = EnablePepLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = RequestSchedBwLnkUp( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyApiPortUp( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup79 */


/*****************************************************************************/
/* TransitionGroup80
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(80)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = ConfigureLane( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReconfigureScheduler( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReleaseSchedBwLnkDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = UnlinkPortFromLanes( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePcieInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePepLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup80 */


/*****************************************************************************/
/* TransitionGroup81
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(81)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = InitPepMailbox( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = DisablePepLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = UpdatePcieModeAndSpeed( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = UpdatePcieLaneReversal( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = RequestSchedBwLnkUp( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyApiPortUp( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnablePcieInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup81 */


/*****************************************************************************/
/* TransitionGroup82
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(82)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = EnablePepLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup82 */


/*****************************************************************************/
/* TransitionGroup83
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(83)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = RequestSchedBwLnkUp( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnablePcieInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup83 */


/*****************************************************************************/
/* TransitionGroup84
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(84)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = EnableDrainMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup84 */


/*****************************************************************************/
/* TransitionGroup85
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(85)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = DisableDrainMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyApiPortUp( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup85 */


/*****************************************************************************/
/* TransitionGroup86
 *
 * \desc            Transition callback for port state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(86)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    status = UpdatePcieModeAndSpeed( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = UpdatePcieLaneReversal( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = ReleaseSchedBwLnkDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = NotifyApiPortDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

    status = EnablePcieInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT, port, status );

ABORT:
    return status;

}   /* end TransitionGroup86 */



/*****************************************************************************
 * Public Functions
 *****************************************************************************/


/*****************************************************************************/
/* fm10000RegisterAnPortStateMachine
 *
 * \desc            This function registers with the Generic State Machine
 *                  Engine state machine type ''FM10000_AN_PORT_STATE_MACHINE''.
 * 
 * \return          FM_OK if the state machine was created successfully.
 * 
 * \return          FM_ERR_INVALID_ARGUMENT if one of the arguments is invalid.
 *
 * \return          FM_ERR_NO_MEM if there was a memory allocation failure
 *                  while creating one of the state machine internal structures.
 * 
 * \return          FM_ERR_STATE_MACHINE_TYPE if this state machine type is
 *                  already registered.
 *
 *****************************************************************************/
fm_status fm10000RegisterAnPortStateMachine( void )
{
    fm_uint i;
    fm_status status;
    fm_smTransitionEntry stt[FM10000_PORT_STATE_MAX][FM10000_PORT_EVENT_MAX];
    fm_smTransitionEntry *dynstt[FM10000_PORT_STATE_MAX];
    fm_smTransitionLogCallback logCallback;

    
    /* log callback for this type */
    logCallback = fm10000LogPortStateTransition;
    

    /* clear out the temporary state transition table */
    FM_MEMSET_S( stt, sizeof(stt), 0, sizeof(stt));

    for (i = 0 ; 
         i < (sizeof(fm10000AnSmTable) / sizeof(fm_smTable)); 
         i++)
    {
        stt[fm10000AnSmTable[i].current]
           [fm10000AnSmTable[i].event].used = TRUE;

        stt[fm10000AnSmTable[i].current]
           [fm10000AnSmTable[i].event].nextState = 
               fm10000AnSmTable[i].next;

        if (fm10000AnSmTable[i].next == FM_STATE_UNSPECIFIED)
        {
            stt[fm10000AnSmTable[i].current]
               [fm10000AnSmTable[i].event].conditionCallback = 
                   (fm_smConditionCallback) fm10000AnSmTable[i].callback;

            stt[fm10000AnSmTable[i].current]
               [fm10000AnSmTable[i].event].transitionCallback = NULL;
        }
        else
        {
            stt[fm10000AnSmTable[i].current]
               [fm10000AnSmTable[i].event].conditionCallback = NULL;

            stt[fm10000AnSmTable[i].current]
               [fm10000AnSmTable[i].event].transitionCallback = 
                   (fm_smTransitionCallback) fm10000AnSmTable[i].callback;
        }
    }
    
    /* fill out the state transition table for this state machine type */
    for (i = 0 ; i < FM10000_PORT_STATE_MAX ; i++)
    {
        dynstt[i] = &stt[i][0];
    }

    /* register this state machine type */
    status = fmRegisterStateTransitionTable( FM10000_AN_PORT_STATE_MACHINE,
                                             FM10000_PORT_STATE_MAX,
                                             FM10000_PORT_EVENT_MAX,
                                             dynstt,
                                             logCallback,
                                             TRUE ); 
    return status;

}   /* end fm10000RegisterAnPortStateMachine */


/*****************************************************************************/
/* fm10000RegisterBasicPortStateMachine
 *
 * \desc            This function registers with the Generic State Machine
 *                  Engine state machine type ''FM10000_BASIC_PORT_STATE_MACHINE''.
 * 
 * \return          FM_OK if the state machine was created successfully.
 * 
 * \return          FM_ERR_INVALID_ARGUMENT if one of the arguments is invalid.
 *
 * \return          FM_ERR_NO_MEM if there was a memory allocation failure
 *                  while creating one of the state machine internal structures.
 * 
 * \return          FM_ERR_STATE_MACHINE_TYPE if this state machine type is
 *                  already registered.
 *
 *****************************************************************************/
fm_status fm10000RegisterBasicPortStateMachine( void )
{
    fm_uint i;
    fm_status status;
    fm_smTransitionEntry stt[FM10000_PORT_STATE_MAX][FM10000_PORT_EVENT_MAX];
    fm_smTransitionEntry *dynstt[FM10000_PORT_STATE_MAX];
    fm_smTransitionLogCallback logCallback;

    
    /* log callback for this type */
    logCallback = fm10000LogPortStateTransition;
    

    /* clear out the temporary state transition table */
    FM_MEMSET_S( stt, sizeof(stt), 0, sizeof(stt));

    for (i = 0 ; 
         i < (sizeof(fm10000BasicSmTable) / sizeof(fm_smTable)); 
         i++)
    {
        stt[fm10000BasicSmTable[i].current]
           [fm10000BasicSmTable[i].event].used = TRUE;

        stt[fm10000BasicSmTable[i].current]
           [fm10000BasicSmTable[i].event].nextState = 
               fm10000BasicSmTable[i].next;

        if (fm10000BasicSmTable[i].next == FM_STATE_UNSPECIFIED)
        {
            stt[fm10000BasicSmTable[i].current]
               [fm10000BasicSmTable[i].event].conditionCallback = 
                   (fm_smConditionCallback) fm10000BasicSmTable[i].callback;

            stt[fm10000BasicSmTable[i].current]
               [fm10000BasicSmTable[i].event].transitionCallback = NULL;
        }
        else
        {
            stt[fm10000BasicSmTable[i].current]
               [fm10000BasicSmTable[i].event].conditionCallback = NULL;

            stt[fm10000BasicSmTable[i].current]
               [fm10000BasicSmTable[i].event].transitionCallback = 
                   (fm_smTransitionCallback) fm10000BasicSmTable[i].callback;
        }
    }
    
    /* fill out the state transition table for this state machine type */
    for (i = 0 ; i < FM10000_PORT_STATE_MAX ; i++)
    {
        dynstt[i] = &stt[i][0];
    }

    /* register this state machine type */
    status = fmRegisterStateTransitionTable( FM10000_BASIC_PORT_STATE_MACHINE,
                                             FM10000_PORT_STATE_MAX,
                                             FM10000_PORT_EVENT_MAX,
                                             dynstt,
                                             logCallback,
                                             TRUE ); 
    return status;

}   /* end fm10000RegisterBasicPortStateMachine */


/*****************************************************************************/
/* fm10000RegisterPciePortStateMachine
 *
 * \desc            This function registers with the Generic State Machine
 *                  Engine state machine type ''FM10000_PCIE_PORT_STATE_MACHINE''.
 * 
 * \return          FM_OK if the state machine was created successfully.
 * 
 * \return          FM_ERR_INVALID_ARGUMENT if one of the arguments is invalid.
 *
 * \return          FM_ERR_NO_MEM if there was a memory allocation failure
 *                  while creating one of the state machine internal structures.
 * 
 * \return          FM_ERR_STATE_MACHINE_TYPE if this state machine type is
 *                  already registered.
 *
 *****************************************************************************/
fm_status fm10000RegisterPciePortStateMachine( void )
{
    fm_uint i;
    fm_status status;
    fm_smTransitionEntry stt[FM10000_PORT_STATE_MAX][FM10000_PORT_EVENT_MAX];
    fm_smTransitionEntry *dynstt[FM10000_PORT_STATE_MAX];
    fm_smTransitionLogCallback logCallback;

    
    /* log callback for this type */
    logCallback = fm10000LogPortStateTransition;
    

    /* clear out the temporary state transition table */
    FM_MEMSET_S( stt, sizeof(stt), 0, sizeof(stt));

    for (i = 0 ; 
         i < (sizeof(fm10000PcieSmTable) / sizeof(fm_smTable)); 
         i++)
    {
        stt[fm10000PcieSmTable[i].current]
           [fm10000PcieSmTable[i].event].used = TRUE;

        stt[fm10000PcieSmTable[i].current]
           [fm10000PcieSmTable[i].event].nextState = 
               fm10000PcieSmTable[i].next;

        if (fm10000PcieSmTable[i].next == FM_STATE_UNSPECIFIED)
        {
            stt[fm10000PcieSmTable[i].current]
               [fm10000PcieSmTable[i].event].conditionCallback = 
                   (fm_smConditionCallback) fm10000PcieSmTable[i].callback;

            stt[fm10000PcieSmTable[i].current]
               [fm10000PcieSmTable[i].event].transitionCallback = NULL;
        }
        else
        {
            stt[fm10000PcieSmTable[i].current]
               [fm10000PcieSmTable[i].event].conditionCallback = NULL;

            stt[fm10000PcieSmTable[i].current]
               [fm10000PcieSmTable[i].event].transitionCallback = 
                   (fm_smTransitionCallback) fm10000PcieSmTable[i].callback;
        }
    }
    
    /* fill out the state transition table for this state machine type */
    for (i = 0 ; i < FM10000_PORT_STATE_MAX ; i++)
    {
        dynstt[i] = &stt[i][0];
    }

    /* register this state machine type */
    status = fmRegisterStateTransitionTable( FM10000_PCIE_PORT_STATE_MACHINE,
                                             FM10000_PORT_STATE_MAX,
                                             FM10000_PORT_EVENT_MAX,
                                             dynstt,
                                             logCallback,
                                             TRUE ); 
    return status;

}   /* end fm10000RegisterPciePortStateMachine */



