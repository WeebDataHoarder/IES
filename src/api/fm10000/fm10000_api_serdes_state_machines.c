/* vim:ts=4:sw=4:expandtab
 * (No tabs, indent level is 4 spaces) */
/*****************************************************************************
 * File:            fm10000_api_serdes_state_machines.c
 * Creation Date:   October 30, 2013
 * Description:     Source file for the serdes-level state machine
 * 
 *                  ------------------------------------------------------
 *                  THIS FILE IS AUTO-GENERATED BY THE BUILD SYSTEM. DO
 *                  NOT MODIFY THIS FILE. MODIFY THE FOLLOWING INSTEAD
 * 
 *                  1) fm10000_api_serdes_state_machines.xml
 *                  2) templates/fm10000_api_serdes_state_machines.c
 *                  ------------------------------------------------------
 *
 * Copyright (c) 2007 - 2015, Intel Corporation
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Intel Corporation nor the names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

#include <fm_sdk_fm10000_int.h>


/*****************************************************************************
 * Macros, Constants & Types
 *****************************************************************************/

#define ST(s) FM10000_SERDES_STATE_ ## s
#define EV(e) FM10000_SERDES_EVENT_ ## e
#define TG(g) TransitionGroup ## g
#define FN(n) (genericFunction) n

typedef void (*genericFunction)(void);

/****************************************************************/
/** \ingroup intSerDesStateMachine 
 * Definition of the State Machine Transition Table values.
 ****************************************************************/
typedef struct _fm_smTable
{
    /* callback for transition or condition */
    genericFunction         callback;
    
    /** current state identifier */
    fm_int                  current;

    /** event identifier */
    fm_int                  event;

    /** next state identifier */
    fm_int                  next;

} fm_smTable;


/*****************************************************************************
 * Local function prototypes
 *****************************************************************************/

/* declaration of all action callbacks */
static fm_status SerDesFlagError( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesSetSignalDtctForcedBadC( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesSetStaticDfeSignalDtctNormal( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesSetSignalDtctNormal( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesConfigureBitRateAndWidthMode( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesConfigureDataSelect( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesConfigureTxEqualization( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesConfigureOptions( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesConfigureDfeMode( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesSaveDfeConfig( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesSaveBitRateConfig( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesSaveNearLoopbackOnConfig( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesSaveNearLoopbackOffConfig( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesSetFarLoopbackModeOn( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesSetFarLoopbackModeOff( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesInitStateVar( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesEnableTxOutput( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDisableTxOutput( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesEnableBistMode( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesEnableTxBistMode( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesEnableRxBistMode( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesRemoveBistConfig( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesEnableNearLoopback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDisableNearLoopback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesEnableParallelLoopback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDisableParallelLoopback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesInitSignalOk( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesStartTimeoutTimerShrt( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesStartTimeoutTimerLng( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesStopTimeoutTimer( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesEnableTxRx( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDisableTxRx( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesEnableRx( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDisableRx( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesEnableTx( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDisableTx( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesEnableInterrupts( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDisableInterrupts( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesStopKrTraining( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesSendPortLaneReadyInd( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesSendPortKrTrainingCompleteInd( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesSendDfeStartTuningReq( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesSendDfeStopTuningReq( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesSendDfeSuspendTuningReq( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesSendDfeResumeTuningReq( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesSendKrStartPcalReq( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDontSaveTransitionRecord( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesSaveTransitionRecord( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesStubAction( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesStartStubPllTimer( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesStopStubPllTimer( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesStartStubSignalTimer( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesStopStubSignalTimer( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesStartStubTuningTimer( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesStopStubTuningTimer( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesStartKrDeferralTimer( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesMarkTxPllUp( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesMarkRxPllUp( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesMarkBothPllsUp( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesMarkTxPllDown( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesMarkRxPllDown( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesMarkBothPllsDown( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDumpBitRate( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDisableLanePolarity( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesConfigLanePolarity( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesResetSpico( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesRestoreSpico( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesEnableEeeOpMode( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDisableEeeOpMode( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesRstSignalOkDebounce( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesConfigureEee( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesSaveKrTimeoutStats( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesExecuteErrorValidation( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesExecuteErrorValidationWithActions( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesExecutePendingErrorActions( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesStartErrorValidationTimer( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesStopErrorValidationTimer( fm_smEventInfo *eventInfo, void *userInfo );



/* declaration of all condition callbacks */
static fm_status SerDesProcessSignalOkAsserted( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status SerDesProcessSignalOkAssertedRx( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status SerDesProcessSignalOkDeasserted( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status SerDesProcessSignalOkDeassertedRx( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status SerDesProcessSignalOkTimeout( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status SerDesProcessSignalOkTimeoutRx( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status SerDesProcessSignalNokTimeout( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status SerDesProcessSignalNokTimeoutRx( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status SerDesProcessDfeTuningTimeout( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status SerDesProcessKrTrainingTimeout( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status SerDesProcessKrTrainingSignalOk( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status SerDesProcessRxTxPllLockEvents( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status SerDesProcessRxTxPllLockTimeout( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status SerDesProcessRxPllLockTimeout( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status SerDesProcessTxPllLockTimeout( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status SerDesProcessStubPllTimer( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status SerDesProcessStubSignalTimer( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status SerDesProcessStubTuningTimer( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status SerDesProcessEnableBistMode( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status SerDesProcessDisableBistMode( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status SerDesProcessBistDisableLoopback( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status SerDesProcessDfeComplete( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status SerDesProcessDfeICalComplete( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status SerDesConfigureEthOrPcie( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );



/* declaration of transition group callbacks */
static fm_status TG(0)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(1)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(2)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(3)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(4)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(5)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(6)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(7)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(8)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(9)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(10)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(11)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(12)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(13)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(14)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(15)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(16)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(17)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(18)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(19)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(20)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(21)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(22)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(23)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(24)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(25)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(26)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(27)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(28)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(29)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(30)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(31)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(32)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(33)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(34)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(35)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(36)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(37)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(38)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(39)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(40)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(41)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(42)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(43)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(44)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(45)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(46)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(47)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(48)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(49)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(50)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(51)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(52)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(53)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(54)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(55)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(56)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(57)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(58)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(59)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(60)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(61)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(62)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(63)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(64)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(65)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(66)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(67)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(68)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(69)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(70)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(71)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(72)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(73)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(74)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(75)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(76)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(77)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(78)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(79)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(80)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(81)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(82)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(83)( fm_smEventInfo *eventInfo, void *userInfo );


/*****************************************************************************
 * Global Variables
 *****************************************************************************/

/* array containing descriptive names for each of the SerDes states */
fm_text fm10000SerDesStatesMap[FM10000_SERDES_STATE_MAX] =
{
    "SERDES_STATE_DISABLED",
    "SERDES_STATE_CONFIGURED",
    "SERDES_STATE_WAITING_TXRX",
    "SERDES_STATE_WAITING_TX",
    "SERDES_STATE_WAITING_RX",
    "SERDES_STATE_POWERED_UP",
    "SERDES_STATE_LOOPBACK",
    "SERDES_STATE_BIST",
    "SERDES_STATE_DFE_TUNING",
    "SERDES_STATE_KR_TRAINING",
    "SERDES_STATE_KR_COMPLETE",
    "SERDES_STATE_MISSION",
    "SERDES_STATE_TX_ON",
    "SERDES_STATE_RX_ON",
    "SERDES_STATE_RX_DFE_TUNING",
    "SERDES_STATE_RX_MISSION"

};

/* array containing descriptive names for each of the SerDes events */
fm_text fm10000SerDesEventsMap[FM10000_SERDES_EVENT_MAX] =
{
    "SERDES_EVENT_POWERUP_REQ",
    "SERDES_EVENT_RX_POWERUP_REQ",
    "SERDES_EVENT_TX_POWERUP_REQ",
    "SERDES_EVENT_POWERDOWN_REQ",
    "SERDES_EVENT_TX_POWERDOWN_REQ",
    "SERDES_EVENT_RX_POWERDOWN_REQ",
    "SERDES_EVENT_ENABLE_BIST_REQ",
    "SERDES_EVENT_DISABLE_BIST_REQ",
    "SERDES_EVENT_LOOPBACK_ON_REQ",
    "SERDES_EVENT_LOOPBACK_OFF_REQ",
    "SERDES_EVENT_CONFIGURE_REQ",
    "SERDES_EVENT_CONFIGURE_DFE_REQ",
    "SERDES_EVENT_DISABLE_REQ",
    "SERDES_EVENT_TIMEOUT_IND",
    "SERDES_EVENT_RXTX_PLLS_LOCKED_IND",
    "SERDES_EVENT_RX_PLL_LOCKED_IND",
    "SERDES_EVENT_TX_PLL_LOCKED_IND",
    "SERDES_EVENT_SIGNALOK_ASSERTED_IND",
    "SERDES_EVENT_SIGNALOK_DEASSERTED_IND",
    "SERDES_EVENT_DFE_TUNING_STARTED_IND",
    "SERDES_EVENT_DFE_TUNING_COMPLETE_IND",
    "SERDES_EVENT_DFE_ICAL_COMPLETE_IND",
    "SERDES_EVENT_DFE_TUNING_STOPPED_IND",
    "SERDES_EVENT_FAR_LOOPBACK_ON_REQ",
    "SERDES_EVENT_FAR_LOOPBACK_OFF_REQ",
    "SERDES_EVENT_ENABLE_EEE_MODE_REQ",
    "SERDES_EVENT_DISABLE_EEE_MODE_REQ",
    "SERDES_EVENT_VALIDATE_TIMEOUT_IND"

};

/*****************************************************************************
 * Local Variables
 *****************************************************************************/


static const fm_smTable fm10000BasicSmTable[] = {
    { FN(TG(0))                            , ST(LOOPBACK)     , EV(VALIDATE_TIMEOUT_IND)   , ST(LOOPBACK)         },
    { FN(TG(0))                            , ST(BIST)         , EV(VALIDATE_TIMEOUT_IND)   , ST(BIST)             },
    { FN(TG(0))                            , ST(KR_COMPLETE)  , EV(VALIDATE_TIMEOUT_IND)   , ST(KR_COMPLETE)      },
    { FN(TG(1))                            , ST(DISABLED)     , EV(ENABLE_EEE_MODE_REQ)    , ST(DISABLED)         },
    { FN(TG(1))                            , ST(CONFIGURED)   , EV(ENABLE_EEE_MODE_REQ)    , ST(CONFIGURED)       },
    { FN(TG(1))                            , ST(WAITING_TXRX) , EV(ENABLE_EEE_MODE_REQ)    , ST(WAITING_TXRX)     },
    { FN(TG(1))                            , ST(POWERED_UP)   , EV(ENABLE_EEE_MODE_REQ)    , ST(POWERED_UP)       },
    { FN(TG(1))                            , ST(BIST)         , EV(ENABLE_EEE_MODE_REQ)    , ST(BIST)             },
    { FN(TG(1))                            , ST(DFE_TUNING)   , EV(ENABLE_EEE_MODE_REQ)    , ST(DFE_TUNING)       },
    { FN(TG(1))                            , ST(KR_TRAINING)  , EV(ENABLE_EEE_MODE_REQ)    , ST(KR_TRAINING)      },
    { FN(TG(1))                            , ST(KR_COMPLETE)  , EV(ENABLE_EEE_MODE_REQ)    , ST(KR_COMPLETE)      },
    { FN(TG(1))                            , ST(MISSION)      , EV(ENABLE_EEE_MODE_REQ)    , ST(MISSION)          },
    { FN(TG(2))                            , ST(WAITING_RX)   , EV(RX_POWERDOWN_REQ)       , ST(CONFIGURED)       },
    { FN(TG(3))                            , ST(MISSION)      , EV(DISABLE_EEE_MODE_REQ)   , ST(MISSION)          },
    { FN(TG(4))                            , ST(DFE_TUNING)   , EV(CONFIGURE_DFE_REQ)      , ST(POWERED_UP)       },
    { FN(TG(4))                            , ST(MISSION)      , EV(CONFIGURE_DFE_REQ)      , ST(POWERED_UP)       },
    { FN(TG(4))                            , ST(RX_ON)        , EV(CONFIGURE_DFE_REQ)      , ST(RX_ON)            },
    { FN(TG(4))                            , ST(RX_DFE_TUNING), EV(CONFIGURE_DFE_REQ)      , ST(RX_ON)            },
    { FN(TG(4))                            , ST(RX_MISSION)   , EV(CONFIGURE_DFE_REQ)      , ST(RX_ON)            },
    { FN(TG(5))                            , ST(LOOPBACK)     , EV(DISABLE_REQ)            , ST(DISABLED)         },
    { FN(TG(6))                            , ST(DISABLED)     , EV(FAR_LOOPBACK_OFF_REQ)   , ST(DISABLED)         },
    { FN(TG(6))                            , ST(CONFIGURED)   , EV(FAR_LOOPBACK_OFF_REQ)   , ST(CONFIGURED)       },
    { FN(TG(7))                            , ST(RX_ON)        , EV(POWERDOWN_REQ)          , ST(CONFIGURED)       },
    { FN(TG(8))                            , ST(WAITING_RX)   , EV(RXTX_PLLS_LOCKED_IND)   , ST(RX_ON)            },
    { FN(TG(8))                            , ST(WAITING_RX)   , EV(RX_PLL_LOCKED_IND)      , ST(RX_ON)            },
    { FN(TG(9))                            , ST(DFE_TUNING)   , EV(POWERDOWN_REQ)          , ST(CONFIGURED)       },
    { FN(TG(10))                           , ST(WAITING_RX)   , EV(POWERDOWN_REQ)          , ST(CONFIGURED)       },
    { FN(TG(11))                           , ST(POWERED_UP)   , EV(DFE_TUNING_STARTED_IND) , ST(DFE_TUNING)       },
    { FN(TG(12))                           , ST(WAITING_TXRX) , EV(POWERDOWN_REQ)          , ST(CONFIGURED)       },
    { FN(TG(12))                           , ST(BIST)         , EV(POWERDOWN_REQ)          , ST(CONFIGURED)       },
    { FN(TG(12))                           , ST(KR_COMPLETE)  , EV(POWERDOWN_REQ)          , ST(CONFIGURED)       },
    { FN(TG(13))                           , ST(DISABLED)     , EV(CONFIGURE_REQ)          , ST(CONFIGURED)       },
    { FN(TG(14))                           , ST(DFE_TUNING)   , EV(DISABLE_REQ)            , ST(DISABLED)         },
    { FN(TG(14))                           , ST(RX_DFE_TUNING), EV(RX_POWERDOWN_REQ)       , ST(CONFIGURED)       },
    { FN(TG(14))                           , ST(RX_DFE_TUNING), EV(DISABLE_REQ)            , ST(DISABLED)         },
    { FN(TG(15))                           , ST(WAITING_TXRX) , EV(RX_POWERDOWN_REQ)       , ST(WAITING_TX)       },
    { FN(TG(15))                           , ST(POWERED_UP)   , EV(RX_POWERDOWN_REQ)       , ST(TX_ON)            },
    { FN(TG(16))                           , ST(DFE_TUNING)   , EV(SIGNALOK_ASSERTED_IND)  , ST(DFE_TUNING)       },
    { FN(TG(17))                           , ST(TX_ON)        , EV(ENABLE_BIST_REQ)        , ST(BIST)             },
    { FN(TG(18))                           , ST(RX_DFE_TUNING), EV(DFE_TUNING_COMPLETE_IND), ST(RX_MISSION)       },
    { FN(TG(19))                           , ST(MISSION)      , EV(DISABLE_REQ)            , ST(DISABLED)         },
    { FN(SerDesProcessRxTxPllLockTimeout)  , ST(WAITING_TXRX) , EV(TIMEOUT_IND)            , FM_STATE_UNSPECIFIED },
    { FN(SerDesProcessRxTxPllLockEvents)   , ST(WAITING_TXRX) , EV(RXTX_PLLS_LOCKED_IND)   , FM_STATE_UNSPECIFIED },
    { FN(SerDesProcessRxTxPllLockEvents)   , ST(WAITING_TXRX) , EV(RX_PLL_LOCKED_IND)      , FM_STATE_UNSPECIFIED },
    { FN(SerDesProcessRxTxPllLockEvents)   , ST(WAITING_TXRX) , EV(TX_PLL_LOCKED_IND)      , FM_STATE_UNSPECIFIED },
    { FN(SerDesProcessRxPllLockTimeout)    , ST(WAITING_RX)   , EV(TIMEOUT_IND)            , FM_STATE_UNSPECIFIED },
    { FN(SerDesProcessTxPllLockTimeout)    , ST(WAITING_TX)   , EV(TIMEOUT_IND)            , FM_STATE_UNSPECIFIED },
    { FN(SerDesProcessEnableBistMode)      , ST(POWERED_UP)   , EV(ENABLE_BIST_REQ)        , FM_STATE_UNSPECIFIED },
    { FN(SerDesProcessSignalOkTimeout)     , ST(POWERED_UP)   , EV(TIMEOUT_IND)            , FM_STATE_UNSPECIFIED },
    { FN(SerDesProcessSignalOkAsserted)    , ST(POWERED_UP)   , EV(SIGNALOK_ASSERTED_IND)  , FM_STATE_UNSPECIFIED },
    { FN(SerDesProcessDisableBistMode)     , ST(BIST)         , EV(DISABLE_BIST_REQ)       , FM_STATE_UNSPECIFIED },
    { FN(SerDesProcessBistDisableLoopback) , ST(BIST)         , EV(LOOPBACK_OFF_REQ)       , FM_STATE_UNSPECIFIED },
    { FN(SerDesProcessDfeTuningTimeout)    , ST(DFE_TUNING)   , EV(TIMEOUT_IND)            , FM_STATE_UNSPECIFIED },
    { FN(SerDesProcessDfeComplete)         , ST(DFE_TUNING)   , EV(DFE_TUNING_COMPLETE_IND), FM_STATE_UNSPECIFIED },
    { FN(SerDesProcessDfeICalComplete)     , ST(DFE_TUNING)   , EV(DFE_ICAL_COMPLETE_IND)  , FM_STATE_UNSPECIFIED },
    { FN(SerDesProcessKrTrainingTimeout)   , ST(KR_TRAINING)  , EV(TIMEOUT_IND)            , FM_STATE_UNSPECIFIED },
    { FN(SerDesProcessKrTrainingSignalOk)  , ST(KR_TRAINING)  , EV(SIGNALOK_ASSERTED_IND)  , FM_STATE_UNSPECIFIED },
    { FN(SerDesProcessSignalNokTimeout)    , ST(MISSION)      , EV(TIMEOUT_IND)            , FM_STATE_UNSPECIFIED },
    { FN(SerDesProcessSignalOkDeasserted)  , ST(MISSION)      , EV(SIGNALOK_DEASSERTED_IND), FM_STATE_UNSPECIFIED },
    { FN(SerDesProcessSignalOkAssertedRx)  , ST(RX_ON)        , EV(TIMEOUT_IND)            , FM_STATE_UNSPECIFIED },
    { FN(SerDesProcessSignalOkAssertedRx)  , ST(RX_ON)        , EV(SIGNALOK_ASSERTED_IND)  , FM_STATE_UNSPECIFIED },
    { NULL                                 , ST(RX_ON)        , EV(DFE_TUNING_STARTED_IND) , ST(RX_DFE_TUNING)    },
    { FN(SerDesProcessSignalNokTimeoutRx)  , ST(RX_DFE_TUNING), EV(TIMEOUT_IND)            , FM_STATE_UNSPECIFIED },
    { FN(SerDesProcessSignalOkDeassertedRx), ST(RX_DFE_TUNING), EV(SIGNALOK_DEASSERTED_IND), FM_STATE_UNSPECIFIED },
    { FN(SerDesProcessSignalNokTimeoutRx)  , ST(RX_MISSION)   , EV(TIMEOUT_IND)            , FM_STATE_UNSPECIFIED },
    { FN(SerDesProcessSignalOkDeassertedRx), ST(RX_MISSION)   , EV(SIGNALOK_DEASSERTED_IND), FM_STATE_UNSPECIFIED },
    { FN(TG(20))                           , ST(RX_MISSION)   , EV(POWERDOWN_REQ)          , ST(CONFIGURED)       },
    { FN(TG(21))                           , ST(WAITING_TX)   , EV(POWERDOWN_REQ)          , ST(CONFIGURED)       },
    { FN(TG(21))                           , ST(TX_ON)        , EV(POWERDOWN_REQ)          , ST(CONFIGURED)       },
    { FN(TG(22))                           , ST(WAITING_TXRX) , EV(TX_POWERDOWN_REQ)       , ST(WAITING_RX)       },
    { FN(TG(22))                           , ST(POWERED_UP)   , EV(TX_POWERDOWN_REQ)       , ST(RX_ON)            },
    { FN(TG(23))                           , ST(DISABLED)     , EV(VALIDATE_TIMEOUT_IND)   , ST(DISABLED)         },
    { FN(TG(24))                           , ST(DISABLED)     , EV(CONFIGURE_DFE_REQ)      , ST(DISABLED)         },
    { FN(TG(24))                           , ST(CONFIGURED)   , EV(CONFIGURE_DFE_REQ)      , ST(CONFIGURED)       },
    { FN(TG(24))                           , ST(WAITING_TXRX) , EV(CONFIGURE_DFE_REQ)      , ST(WAITING_TXRX)     },
    { FN(TG(24))                           , ST(WAITING_RX)   , EV(CONFIGURE_DFE_REQ)      , ST(WAITING_RX)       },
    { FN(TG(24))                           , ST(WAITING_TX)   , EV(CONFIGURE_DFE_REQ)      , ST(WAITING_TX)       },
    { FN(TG(24))                           , ST(POWERED_UP)   , EV(CONFIGURE_DFE_REQ)      , ST(POWERED_UP)       },
    { FN(TG(25))                           , ST(DFE_TUNING)   , EV(SIGNALOK_DEASSERTED_IND), ST(DFE_TUNING)       },
    { FN(TG(26))                           , ST(DISABLED)     , EV(DISABLE_EEE_MODE_REQ)   , ST(DISABLED)         },
    { FN(TG(26))                           , ST(CONFIGURED)   , EV(DISABLE_EEE_MODE_REQ)   , ST(CONFIGURED)       },
    { FN(TG(26))                           , ST(WAITING_TXRX) , EV(DISABLE_EEE_MODE_REQ)   , ST(WAITING_TXRX)     },
    { FN(TG(26))                           , ST(POWERED_UP)   , EV(DISABLE_EEE_MODE_REQ)   , ST(POWERED_UP)       },
    { FN(TG(26))                           , ST(LOOPBACK)     , EV(DISABLE_EEE_MODE_REQ)   , ST(LOOPBACK)         },
    { FN(TG(26))                           , ST(BIST)         , EV(DISABLE_EEE_MODE_REQ)   , ST(BIST)             },
    { FN(TG(26))                           , ST(DFE_TUNING)   , EV(DISABLE_EEE_MODE_REQ)   , ST(DFE_TUNING)       },
    { FN(TG(26))                           , ST(KR_TRAINING)  , EV(DISABLE_EEE_MODE_REQ)   , ST(KR_TRAINING)      },
    { FN(TG(26))                           , ST(KR_COMPLETE)  , EV(DISABLE_EEE_MODE_REQ)   , ST(KR_COMPLETE)      },
    { FN(TG(27))                           , ST(DISABLED)     , EV(FAR_LOOPBACK_ON_REQ)    , ST(DISABLED)         },
    { FN(TG(27))                           , ST(CONFIGURED)   , EV(FAR_LOOPBACK_ON_REQ)    , ST(CONFIGURED)       },
    { FN(TG(28))                           , ST(WAITING_TX)   , EV(TX_POWERDOWN_REQ)       , ST(CONFIGURED)       },
    { FN(TG(29))                           , ST(RX_MISSION)   , EV(RX_POWERDOWN_REQ)       , ST(CONFIGURED)       },
    { FN(TG(29))                           , ST(RX_MISSION)   , EV(DISABLE_REQ)            , ST(DISABLED)         },
    { FN(TG(30))                           , ST(WAITING_TX)   , EV(POWERUP_REQ)            , ST(WAITING_TXRX)     },
    { FN(TG(30))                           , ST(WAITING_TX)   , EV(RX_POWERUP_REQ)         , ST(WAITING_TXRX)     },
    { FN(TG(31))                           , ST(POWERED_UP)   , EV(SIGNALOK_DEASSERTED_IND), ST(POWERED_UP)       },
    { FN(TG(31))                           , ST(MISSION)      , EV(SIGNALOK_ASSERTED_IND)  , ST(MISSION)          },
    { FN(TG(32))                           , ST(RX_ON)        , EV(RX_POWERDOWN_REQ)       , ST(CONFIGURED)       },
    { FN(TG(32))                           , ST(RX_ON)        , EV(DISABLE_REQ)            , ST(DISABLED)         },
    { FN(TG(33))                           , ST(CONFIGURED)   , EV(LOOPBACK_OFF_REQ)       , ST(CONFIGURED)       },
    { FN(TG(34))                           , ST(LOOPBACK)     , EV(LOOPBACK_OFF_REQ)       , ST(POWERED_UP)       },
    { FN(TG(35))                           , ST(LOOPBACK)     , EV(ENABLE_BIST_REQ)        , ST(BIST)             },
    { FN(TG(35))                           , ST(BIST)         , EV(ENABLE_BIST_REQ)        , ST(BIST)             },
    { FN(TG(35))                           , ST(MISSION)      , EV(ENABLE_BIST_REQ)        , ST(BIST)             },
    { FN(TG(36))                           , ST(WAITING_RX)   , EV(POWERUP_REQ)            , ST(WAITING_TXRX)     },
    { FN(TG(36))                           , ST(WAITING_RX)   , EV(TX_POWERUP_REQ)         , ST(WAITING_TXRX)     },
    { FN(TG(37))                           , ST(CONFIGURED)   , EV(RX_POWERUP_REQ)         , ST(WAITING_RX)       },
    { FN(TG(38))                           , ST(POWERED_UP)   , EV(DISABLE_BIST_REQ)       , ST(POWERED_UP)       },
    { FN(TG(38))                           , ST(DFE_TUNING)   , EV(DISABLE_BIST_REQ)       , ST(DFE_TUNING)       },
    { FN(TG(39))                           , ST(TX_ON)        , EV(POWERUP_REQ)            , ST(WAITING_TXRX)     },
    { FN(TG(39))                           , ST(TX_ON)        , EV(RX_POWERUP_REQ)         , ST(WAITING_TXRX)     },
    { FN(TG(40))                           , ST(MISSION)      , EV(LOOPBACK_ON_REQ)        , ST(LOOPBACK)         },
    { FN(TG(41))                           , ST(DFE_TUNING)   , EV(DFE_TUNING_STOPPED_IND) , ST(POWERED_UP)       },
    { FN(TG(42))                           , ST(POWERED_UP)   , EV(POWERDOWN_REQ)          , ST(CONFIGURED)       },
    { FN(TG(42))                           , ST(LOOPBACK)     , EV(POWERDOWN_REQ)          , ST(CONFIGURED)       },
    { FN(TG(43))                           , ST(CONFIGURED)   , EV(TIMEOUT_IND)            , ST(CONFIGURED)       },
    { FN(TG(43))                           , ST(LOOPBACK)     , EV(CONFIGURE_REQ)          , ST(LOOPBACK)         },
    { FN(TG(43))                           , ST(LOOPBACK)     , EV(TIMEOUT_IND)            , ST(LOOPBACK)         },
    { FN(TG(43))                           , ST(LOOPBACK)     , EV(RXTX_PLLS_LOCKED_IND)   , ST(LOOPBACK)         },
    { FN(TG(43))                           , ST(LOOPBACK)     , EV(RX_PLL_LOCKED_IND)      , ST(LOOPBACK)         },
    { FN(TG(43))                           , ST(LOOPBACK)     , EV(TX_PLL_LOCKED_IND)      , ST(LOOPBACK)         },
    { FN(TG(43))                           , ST(LOOPBACK)     , EV(SIGNALOK_ASSERTED_IND)  , ST(LOOPBACK)         },
    { FN(TG(43))                           , ST(LOOPBACK)     , EV(SIGNALOK_DEASSERTED_IND), ST(LOOPBACK)         },
    { FN(TG(43))                           , ST(LOOPBACK)     , EV(DFE_TUNING_STARTED_IND) , ST(LOOPBACK)         },
    { FN(TG(43))                           , ST(LOOPBACK)     , EV(DFE_TUNING_STOPPED_IND) , ST(LOOPBACK)         },
    { FN(TG(43))                           , ST(LOOPBACK)     , EV(DFE_TUNING_COMPLETE_IND), ST(LOOPBACK)         },
    { FN(TG(44))                           , ST(RX_MISSION)   , EV(ENABLE_BIST_REQ)        , ST(BIST)             },
    { FN(TG(45))                           , ST(CONFIGURED)   , EV(TX_POWERUP_REQ)         , ST(WAITING_TX)       },
    { FN(TG(46))                           , ST(CONFIGURED)   , EV(LOOPBACK_ON_REQ)        , ST(CONFIGURED)       },
    { FN(TG(46))                           , ST(WAITING_TXRX) , EV(LOOPBACK_ON_REQ)        , ST(WAITING_TXRX)     },
    { FN(TG(46))                           , ST(WAITING_TXRX) , EV(LOOPBACK_OFF_REQ)       , ST(WAITING_TXRX)     },
    { FN(TG(47))                           , ST(DFE_TUNING)   , EV(LOOPBACK_ON_REQ)        , ST(LOOPBACK)         },
    { FN(TG(48))                           , ST(WAITING_TXRX) , EV(DISABLE_REQ)            , ST(DISABLED)         },
    { FN(TG(48))                           , ST(WAITING_RX)   , EV(DISABLE_REQ)            , ST(DISABLED)         },
    { FN(TG(48))                           , ST(WAITING_TX)   , EV(DISABLE_REQ)            , ST(DISABLED)         },
    { FN(TG(48))                           , ST(POWERED_UP)   , EV(DISABLE_REQ)            , ST(DISABLED)         },
    { FN(TG(48))                           , ST(BIST)         , EV(DISABLE_REQ)            , ST(DISABLED)         },
    { FN(TG(48))                           , ST(KR_TRAINING)  , EV(DISABLE_REQ)            , ST(DISABLED)         },
    { FN(TG(48))                           , ST(KR_COMPLETE)  , EV(DISABLE_REQ)            , ST(DISABLED)         },
    { FN(TG(48))                           , ST(TX_ON)        , EV(TX_POWERDOWN_REQ)       , ST(CONFIGURED)       },
    { FN(TG(48))                           , ST(TX_ON)        , EV(DISABLE_REQ)            , ST(DISABLED)         },
    { FN(TG(49))                           , ST(LOOPBACK)     , EV(FAR_LOOPBACK_ON_REQ)    , ST(LOOPBACK)         },
    { FN(TG(49))                           , ST(LOOPBACK)     , EV(FAR_LOOPBACK_OFF_REQ)   , ST(LOOPBACK)         },
    { FN(TG(50))                           , ST(LOOPBACK)     , EV(CONFIGURE_DFE_REQ)      , ST(LOOPBACK)         },
    { FN(TG(51))                           , ST(RX_DFE_TUNING), EV(POWERDOWN_REQ)          , ST(CONFIGURED)       },
    { FN(TG(52))                           , ST(POWERED_UP)   , EV(VALIDATE_TIMEOUT_IND)   , ST(POWERED_UP)       },
    { FN(TG(52))                           , ST(MISSION)      , EV(VALIDATE_TIMEOUT_IND)   , ST(MISSION)          },
    { FN(TG(52))                           , ST(TX_ON)        , EV(VALIDATE_TIMEOUT_IND)   , ST(TX_ON)            },
    { FN(TG(52))                           , ST(RX_ON)        , EV(VALIDATE_TIMEOUT_IND)   , ST(RX_ON)            },
    { FN(TG(52))                           , ST(RX_MISSION)   , EV(VALIDATE_TIMEOUT_IND)   , ST(RX_MISSION)       },
    { FN(TG(53))                           , ST(POWERED_UP)   , EV(LOOPBACK_ON_REQ)        , ST(LOOPBACK)         },
    { FN(TG(54))                           , ST(MISSION)      , EV(POWERDOWN_REQ)          , ST(CONFIGURED)       },
    { FN(TG(55))                           , ST(WAITING_TX)   , EV(RXTX_PLLS_LOCKED_IND)   , ST(TX_ON)            },
    { FN(TG(55))                           , ST(WAITING_TX)   , EV(TX_PLL_LOCKED_IND)      , ST(TX_ON)            },
    { FN(TG(56))                           , ST(CONFIGURED)   , EV(VALIDATE_TIMEOUT_IND)   , ST(CONFIGURED)       },
    { FN(TG(56))                           , ST(WAITING_TXRX) , EV(VALIDATE_TIMEOUT_IND)   , ST(WAITING_TXRX)     },
    { FN(TG(56))                           , ST(WAITING_RX)   , EV(VALIDATE_TIMEOUT_IND)   , ST(WAITING_RX)       },
    { FN(TG(56))                           , ST(WAITING_TX)   , EV(VALIDATE_TIMEOUT_IND)   , ST(WAITING_TX)       },
    { FN(TG(56))                           , ST(DFE_TUNING)   , EV(VALIDATE_TIMEOUT_IND)   , ST(DFE_TUNING)       },
    { FN(TG(56))                           , ST(KR_TRAINING)  , EV(VALIDATE_TIMEOUT_IND)   , ST(KR_TRAINING)      },
    { FN(TG(56))                           , ST(RX_DFE_TUNING), EV(VALIDATE_TIMEOUT_IND)   , ST(RX_DFE_TUNING)    },
    { FN(TG(57))                           , ST(LOOPBACK)     , EV(ENABLE_EEE_MODE_REQ)    , ST(LOOPBACK)         },
    { FN(TG(58))                           , ST(CONFIGURED)   , EV(POWERUP_REQ)            , ST(WAITING_TXRX)     },
    { FN(TG(59))                           , ST(CONFIGURED)   , EV(CONFIGURE_REQ)          , ST(CONFIGURED)       },
    { FN(TG(60))                           , ST(KR_TRAINING)  , EV(LOOPBACK_ON_REQ)        , ST(LOOPBACK)         },
    { FN(TG(61))                           , ST(KR_COMPLETE)  , EV(LOOPBACK_ON_REQ)        , ST(MISSION)          },
    { FN(TG(62))                           , ST(DISABLED)     , EV(POWERUP_REQ)            , ST(DISABLED)         },
    { FN(TG(62))                           , ST(DISABLED)     , EV(RX_POWERUP_REQ)         , ST(DISABLED)         },
    { FN(TG(62))                           , ST(DISABLED)     , EV(TX_POWERUP_REQ)         , ST(DISABLED)         },
    { FN(TG(62))                           , ST(DISABLED)     , EV(ENABLE_BIST_REQ)        , ST(DISABLED)         },
    { FN(TG(62))                           , ST(DISABLED)     , EV(LOOPBACK_ON_REQ)        , ST(DISABLED)         },
    { FN(TG(62))                           , ST(CONFIGURED)   , EV(ENABLE_BIST_REQ)        , ST(CONFIGURED)       },
    { FN(TG(62))                           , ST(WAITING_TXRX) , EV(ENABLE_BIST_REQ)        , ST(WAITING_TXRX)     },
    { FN(TG(62))                           , ST(WAITING_TXRX) , EV(FAR_LOOPBACK_ON_REQ)    , ST(WAITING_TXRX)     },
    { FN(TG(62))                           , ST(WAITING_TXRX) , EV(FAR_LOOPBACK_OFF_REQ)   , ST(WAITING_TXRX)     },
    { FN(TG(62))                           , ST(WAITING_RX)   , EV(ENABLE_BIST_REQ)        , ST(WAITING_RX)       },
    { FN(TG(62))                           , ST(WAITING_RX)   , EV(LOOPBACK_ON_REQ)        , ST(WAITING_RX)       },
    { FN(TG(62))                           , ST(WAITING_RX)   , EV(FAR_LOOPBACK_ON_REQ)    , ST(WAITING_RX)       },
    { FN(TG(62))                           , ST(WAITING_RX)   , EV(FAR_LOOPBACK_OFF_REQ)   , ST(WAITING_RX)       },
    { FN(TG(62))                           , ST(WAITING_TX)   , EV(ENABLE_BIST_REQ)        , ST(WAITING_TX)       },
    { FN(TG(62))                           , ST(WAITING_TX)   , EV(LOOPBACK_ON_REQ)        , ST(WAITING_TX)       },
    { FN(TG(62))                           , ST(WAITING_TX)   , EV(FAR_LOOPBACK_ON_REQ)    , ST(WAITING_TX)       },
    { FN(TG(62))                           , ST(WAITING_TX)   , EV(FAR_LOOPBACK_OFF_REQ)   , ST(WAITING_TX)       },
    { FN(TG(62))                           , ST(POWERED_UP)   , EV(FAR_LOOPBACK_ON_REQ)    , ST(POWERED_UP)       },
    { FN(TG(62))                           , ST(POWERED_UP)   , EV(FAR_LOOPBACK_OFF_REQ)   , ST(POWERED_UP)       },
    { FN(TG(62))                           , ST(BIST)         , EV(LOOPBACK_ON_REQ)        , ST(BIST)             },
    { FN(TG(62))                           , ST(BIST)         , EV(FAR_LOOPBACK_ON_REQ)    , ST(BIST)             },
    { FN(TG(62))                           , ST(BIST)         , EV(FAR_LOOPBACK_OFF_REQ)   , ST(BIST)             },
    { FN(TG(62))                           , ST(BIST)         , EV(CONFIGURE_DFE_REQ)      , ST(BIST)             },
    { FN(TG(62))                           , ST(DFE_TUNING)   , EV(ENABLE_BIST_REQ)        , ST(DFE_TUNING)       },
    { FN(TG(62))                           , ST(DFE_TUNING)   , EV(FAR_LOOPBACK_ON_REQ)    , ST(DFE_TUNING)       },
    { FN(TG(62))                           , ST(DFE_TUNING)   , EV(FAR_LOOPBACK_OFF_REQ)   , ST(DFE_TUNING)       },
    { FN(TG(62))                           , ST(KR_TRAINING)  , EV(ENABLE_BIST_REQ)        , ST(KR_TRAINING)      },
    { FN(TG(62))                           , ST(KR_TRAINING)  , EV(FAR_LOOPBACK_ON_REQ)    , ST(KR_TRAINING)      },
    { FN(TG(62))                           , ST(KR_TRAINING)  , EV(FAR_LOOPBACK_OFF_REQ)   , ST(KR_TRAINING)      },
    { FN(TG(62))                           , ST(KR_TRAINING)  , EV(CONFIGURE_DFE_REQ)      , ST(KR_TRAINING)      },
    { FN(TG(62))                           , ST(KR_COMPLETE)  , EV(FAR_LOOPBACK_ON_REQ)    , ST(KR_COMPLETE)      },
    { FN(TG(62))                           , ST(KR_COMPLETE)  , EV(FAR_LOOPBACK_OFF_REQ)   , ST(KR_COMPLETE)      },
    { FN(TG(62))                           , ST(MISSION)      , EV(FAR_LOOPBACK_ON_REQ)    , ST(MISSION)          },
    { FN(TG(62))                           , ST(MISSION)      , EV(FAR_LOOPBACK_OFF_REQ)   , ST(MISSION)          },
    { FN(TG(62))                           , ST(TX_ON)        , EV(LOOPBACK_ON_REQ)        , ST(TX_ON)            },
    { FN(TG(62))                           , ST(TX_ON)        , EV(FAR_LOOPBACK_ON_REQ)    , ST(TX_ON)            },
    { FN(TG(62))                           , ST(TX_ON)        , EV(FAR_LOOPBACK_OFF_REQ)   , ST(TX_ON)            },
    { FN(TG(62))                           , ST(TX_ON)        , EV(CONFIGURE_DFE_REQ)      , ST(TX_ON)            },
    { FN(TG(62))                           , ST(RX_ON)        , EV(ENABLE_BIST_REQ)        , ST(RX_ON)            },
    { FN(TG(62))                           , ST(RX_ON)        , EV(LOOPBACK_ON_REQ)        , ST(RX_ON)            },
    { FN(TG(62))                           , ST(RX_ON)        , EV(FAR_LOOPBACK_ON_REQ)    , ST(RX_ON)            },
    { FN(TG(62))                           , ST(RX_ON)        , EV(FAR_LOOPBACK_OFF_REQ)   , ST(RX_ON)            },
    { FN(TG(62))                           , ST(RX_DFE_TUNING), EV(ENABLE_BIST_REQ)        , ST(RX_DFE_TUNING)    },
    { FN(TG(62))                           , ST(RX_DFE_TUNING), EV(LOOPBACK_ON_REQ)        , ST(RX_DFE_TUNING)    },
    { FN(TG(62))                           , ST(RX_DFE_TUNING), EV(FAR_LOOPBACK_ON_REQ)    , ST(RX_DFE_TUNING)    },
    { FN(TG(62))                           , ST(RX_DFE_TUNING), EV(FAR_LOOPBACK_OFF_REQ)   , ST(RX_DFE_TUNING)    },
    { FN(TG(62))                           , ST(RX_MISSION)   , EV(LOOPBACK_ON_REQ)        , ST(RX_MISSION)       },
    { FN(TG(62))                           , ST(RX_MISSION)   , EV(FAR_LOOPBACK_ON_REQ)    , ST(RX_MISSION)       },
    { FN(TG(62))                           , ST(RX_MISSION)   , EV(FAR_LOOPBACK_OFF_REQ)   , ST(RX_MISSION)       },
    { FN(TG(63))                           , ST(MISSION)      , EV(DFE_TUNING_STOPPED_IND) , ST(POWERED_UP)       },
    { FN(TG(64))                           , ST(KR_COMPLETE)  , EV(TIMEOUT_IND)            , ST(MISSION)          },
    { FN(TG(65))                           , ST(KR_TRAINING)  , EV(POWERDOWN_REQ)          , ST(CONFIGURED)       },
    { FN(TG(66))                           , ST(RX_ON)        , EV(POWERUP_REQ)            , ST(WAITING_TXRX)     },
    { FN(TG(66))                           , ST(RX_ON)        , EV(TX_POWERUP_REQ)         , ST(WAITING_TXRX)     }
};

static const fm_smTable fm10000StubSmTable[] = {
    { FN(TG(67))                      , ST(TX_ON)       , EV(POWERDOWN_REQ)        , ST(CONFIGURED)       },
    { FN(TG(67))                      , ST(TX_ON)       , EV(DISABLE_BIST_REQ)     , ST(CONFIGURED)       },
    { FN(TG(67))                      , ST(TX_ON)       , EV(DISABLE_REQ)          , ST(DISABLED)         },
    { FN(TG(67))                      , ST(RX_ON)       , EV(POWERDOWN_REQ)        , ST(CONFIGURED)       },
    { FN(TG(67))                      , ST(RX_ON)       , EV(DISABLE_BIST_REQ)     , ST(CONFIGURED)       },
    { FN(TG(67))                      , ST(RX_ON)       , EV(DISABLE_REQ)          , ST(DISABLED)         },
    { FN(TG(67))                      , ST(MISSION)     , EV(POWERDOWN_REQ)        , ST(CONFIGURED)       },
    { FN(TG(67))                      , ST(MISSION)     , EV(DISABLE_BIST_REQ)     , ST(CONFIGURED)       },
    { FN(TG(67))                      , ST(MISSION)     , EV(DISABLE_REQ)          , ST(DISABLED)         },
    { FN(TG(68))                      , ST(DISABLED)    , EV(CONFIGURE_DFE_REQ)    , ST(CONFIGURED)       },
    { FN(TG(68))                      , ST(CONFIGURED)  , EV(DISABLE_REQ)          , ST(DISABLED)         },
    { FN(TG(68))                      , ST(CONFIGURED)  , EV(CONFIGURE_DFE_REQ)    , ST(CONFIGURED)       },
    { FN(TG(68))                      , ST(WAITING_TXRX), EV(CONFIGURE_DFE_REQ)    , ST(WAITING_TXRX)     },
    { FN(TG(68))                      , ST(POWERED_UP)  , EV(CONFIGURE_DFE_REQ)    , ST(POWERED_UP)       },
    { FN(TG(68))                      , ST(DFE_TUNING)  , EV(CONFIGURE_DFE_REQ)    , ST(DFE_TUNING)       },
    { FN(TG(68))                      , ST(TX_ON)       , EV(CONFIGURE_DFE_REQ)    , ST(TX_ON)            },
    { FN(TG(68))                      , ST(RX_ON)       , EV(CONFIGURE_DFE_REQ)    , ST(RX_ON)            },
    { FN(TG(68))                      , ST(MISSION)     , EV(CONFIGURE_DFE_REQ)    , ST(MISSION)          },
    { FN(TG(69))                      , ST(WAITING_TXRX), EV(TX_POWERDOWN_REQ)     , ST(WAITING_TXRX)     },
    { FN(TG(69))                      , ST(POWERED_UP)  , EV(TX_POWERDOWN_REQ)     , ST(POWERED_UP)       },
    { FN(TG(69))                      , ST(DFE_TUNING)  , EV(TX_POWERDOWN_REQ)     , ST(DFE_TUNING)       },
    { FN(TG(69))                      , ST(KR_TRAINING) , EV(TX_POWERDOWN_REQ)     , ST(KR_TRAINING)      },
    { FN(TG(69))                      , ST(TX_ON)       , EV(TX_POWERDOWN_REQ)     , ST(CONFIGURED)       },
    { FN(TG(69))                      , ST(MISSION)     , EV(TX_POWERDOWN_REQ)     , ST(RX_ON)            },
    { FN(TG(70))                      , ST(WAITING_TXRX), EV(TX_POWERUP_REQ)       , ST(WAITING_TXRX)     },
    { FN(TG(70))                      , ST(POWERED_UP)  , EV(TX_POWERUP_REQ)       , ST(POWERED_UP)       },
    { FN(TG(70))                      , ST(DFE_TUNING)  , EV(TX_POWERUP_REQ)       , ST(DFE_TUNING)       },
    { FN(TG(70))                      , ST(KR_TRAINING) , EV(TX_POWERUP_REQ)       , ST(KR_TRAINING)      },
    { FN(TG(71))                      , ST(POWERED_UP)  , EV(POWERDOWN_REQ)        , ST(CONFIGURED)       },
    { FN(TG(71))                      , ST(POWERED_UP)  , EV(DISABLE_BIST_REQ)     , ST(CONFIGURED)       },
    { FN(TG(71))                      , ST(POWERED_UP)  , EV(DISABLE_REQ)          , ST(DISABLED)         },
    { FN(SerDesConfigureEthOrPcie)    , ST(DISABLED)    , EV(CONFIGURE_REQ)        , FM_STATE_UNSPECIFIED },
    { FN(SerDesConfigureEthOrPcie)    , ST(CONFIGURED)  , EV(CONFIGURE_REQ)        , FM_STATE_UNSPECIFIED },
    { FN(SerDesProcessStubPllTimer)   , ST(WAITING_TXRX), EV(RXTX_PLLS_LOCKED_IND) , FM_STATE_UNSPECIFIED },
    { FN(SerDesProcessStubSignalTimer), ST(POWERED_UP)  , EV(SIGNALOK_ASSERTED_IND), FM_STATE_UNSPECIFIED },
    { FN(TG(72))                      , ST(WAITING_TXRX), EV(RX_POWERUP_REQ)       , ST(WAITING_TXRX)     },
    { FN(TG(72))                      , ST(POWERED_UP)  , EV(RX_POWERUP_REQ)       , ST(POWERED_UP)       },
    { FN(TG(72))                      , ST(DFE_TUNING)  , EV(RX_POWERUP_REQ)       , ST(DFE_TUNING)       },
    { FN(TG(72))                      , ST(KR_TRAINING) , EV(RX_POWERUP_REQ)       , ST(KR_TRAINING)      },
    { FN(TG(73))                      , ST(RX_ON)       , EV(POWERUP_REQ)          , ST(MISSION)          },
    { FN(TG(73))                      , ST(RX_ON)       , EV(ENABLE_BIST_REQ)      , ST(MISSION)          },
    { FN(TG(74))                      , ST(TX_ON)       , EV(POWERUP_REQ)          , ST(WAITING_TXRX)     },
    { FN(TG(74))                      , ST(TX_ON)       , EV(ENABLE_BIST_REQ)      , ST(WAITING_TXRX)     },
    { FN(TG(23))                      , ST(DISABLED)    , EV(VALIDATE_TIMEOUT_IND) , ST(DISABLED)         },
    { FN(TG(75))                      , ST(CONFIGURED)  , EV(POWERUP_REQ)          , ST(WAITING_TXRX)     },
    { FN(TG(76))                      , ST(CONFIGURED)  , EV(ENABLE_BIST_REQ)      , ST(CONFIGURED)       },
    { FN(TG(77))                      , ST(WAITING_TXRX), EV(RX_POWERDOWN_REQ)     , ST(WAITING_TXRX)     },
    { FN(TG(77))                      , ST(POWERED_UP)  , EV(RX_POWERDOWN_REQ)     , ST(POWERED_UP)       },
    { FN(TG(77))                      , ST(DFE_TUNING)  , EV(RX_POWERDOWN_REQ)     , ST(DFE_TUNING)       },
    { FN(TG(77))                      , ST(KR_TRAINING) , EV(RX_POWERDOWN_REQ)     , ST(KR_TRAINING)      },
    { FN(TG(77))                      , ST(RX_ON)       , EV(RX_POWERDOWN_REQ)     , ST(CONFIGURED)       },
    { FN(TG(77))                      , ST(MISSION)     , EV(RX_POWERDOWN_REQ)     , ST(TX_ON)            },
    { FN(TG(78))                      , ST(CONFIGURED)  , EV(RX_POWERUP_REQ)       , ST(WAITING_TXRX)     },
    { FN(TG(78))                      , ST(TX_ON)       , EV(RX_POWERUP_REQ)       , ST(WAITING_TXRX)     },
    { FN(TG(43))                      , ST(DFE_TUNING)  , EV(TIMEOUT_IND)          , ST(MISSION)          },
    { FN(TG(79))                      , ST(WAITING_TXRX), EV(POWERDOWN_REQ)        , ST(CONFIGURED)       },
    { FN(TG(79))                      , ST(WAITING_TXRX), EV(DISABLE_BIST_REQ)     , ST(CONFIGURED)       },
    { FN(TG(79))                      , ST(WAITING_TXRX), EV(DISABLE_REQ)          , ST(DISABLED)         },
    { FN(TG(80))                      , ST(CONFIGURED)  , EV(TX_POWERUP_REQ)       , ST(WAITING_TXRX)     },
    { FN(TG(81))                      , ST(DFE_TUNING)  , EV(POWERDOWN_REQ)        , ST(CONFIGURED)       },
    { FN(TG(81))                      , ST(DFE_TUNING)  , EV(DISABLE_BIST_REQ)     , ST(CONFIGURED)       },
    { FN(TG(81))                      , ST(DFE_TUNING)  , EV(DISABLE_REQ)          , ST(DISABLED)         },
    { FN(TG(81))                      , ST(KR_TRAINING) , EV(POWERDOWN_REQ)        , ST(CONFIGURED)       },
    { FN(TG(81))                      , ST(KR_TRAINING) , EV(DISABLE_BIST_REQ)     , ST(CONFIGURED)       },
    { FN(TG(81))                      , ST(KR_TRAINING) , EV(DISABLE_REQ)          , ST(DISABLED)         },
    { FN(TG(82))                      , ST(WAITING_TXRX), EV(POWERUP_REQ)          , ST(WAITING_TXRX)     },
    { FN(TG(82))                      , ST(WAITING_TXRX), EV(ENABLE_BIST_REQ)      , ST(WAITING_TXRX)     },
    { FN(TG(82))                      , ST(POWERED_UP)  , EV(POWERUP_REQ)          , ST(POWERED_UP)       },
    { FN(TG(82))                      , ST(POWERED_UP)  , EV(ENABLE_BIST_REQ)      , ST(POWERED_UP)       },
    { FN(TG(82))                      , ST(DFE_TUNING)  , EV(POWERUP_REQ)          , ST(DFE_TUNING)       },
    { FN(TG(82))                      , ST(DFE_TUNING)  , EV(ENABLE_BIST_REQ)      , ST(DFE_TUNING)       },
    { FN(TG(82))                      , ST(KR_TRAINING) , EV(POWERUP_REQ)          , ST(KR_TRAINING)      },
    { FN(TG(82))                      , ST(KR_TRAINING) , EV(ENABLE_BIST_REQ)      , ST(KR_TRAINING)      },
    { FN(TG(52))                      , ST(CONFIGURED)  , EV(VALIDATE_TIMEOUT_IND) , ST(CONFIGURED)       },
    { FN(TG(52))                      , ST(MISSION)     , EV(VALIDATE_TIMEOUT_IND) , ST(MISSION)          },
    { FN(TG(83))                      , ST(RX_ON)       , EV(TX_POWERUP_REQ)       , ST(MISSION)          },
    { FN(TG(62))                      , ST(DISABLED)    , EV(POWERUP_REQ)          , ST(DISABLED)         },
    { FN(TG(62))                      , ST(DISABLED)    , EV(RX_POWERUP_REQ)       , ST(DISABLED)         },
    { FN(TG(62))                      , ST(DISABLED)    , EV(TX_POWERUP_REQ)       , ST(DISABLED)         },
    { FN(TG(62))                      , ST(DISABLED)    , EV(ENABLE_BIST_REQ)      , ST(DISABLED)         },
    { FN(TG(62))                      , ST(TX_ON)       , EV(LOOPBACK_ON_REQ)      , ST(TX_ON)            },
    { FN(TG(62))                      , ST(RX_ON)       , EV(LOOPBACK_ON_REQ)      , ST(RX_ON)            }
};



/*****************************************************************************
 * Local Functions
 *****************************************************************************/

/*****************************************************************************/
/* SerDesFlagError
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesFlagError( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing FlagError\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesFlagError( eventInfo, userInfo );

    return status;

}   /* end SerDesFlagError */


/*****************************************************************************/
/* SerDesSetSignalDtctForcedBadC
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesSetSignalDtctForcedBadC( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing SetSignalDtctForcedBadC\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesSetSignalDtctForcedBadC( eventInfo, userInfo );

    return status;

}   /* end SerDesSetSignalDtctForcedBadC */


/*****************************************************************************/
/* SerDesSetStaticDfeSignalDtctNormal
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesSetStaticDfeSignalDtctNormal( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing SetStaticDfeSignalDtctNormal\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesSetStaticDfeSignalDtctNormal( eventInfo, userInfo );

    return status;

}   /* end SerDesSetStaticDfeSignalDtctNormal */


/*****************************************************************************/
/* SerDesSetSignalDtctNormal
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesSetSignalDtctNormal( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing SetSignalDtctNormal\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesSetSignalDtctNormal( eventInfo, userInfo );

    return status;

}   /* end SerDesSetSignalDtctNormal */


/*****************************************************************************/
/* SerDesConfigureBitRateAndWidthMode
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesConfigureBitRateAndWidthMode( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ConfigureBitRateAndWidthMode\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesConfigureBitRateAndWidthMode( eventInfo, userInfo );

    return status;

}   /* end SerDesConfigureBitRateAndWidthMode */


/*****************************************************************************/
/* SerDesConfigureDataSelect
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesConfigureDataSelect( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ConfigureDataSelect\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesConfigureDataSelect( eventInfo, userInfo );

    return status;

}   /* end SerDesConfigureDataSelect */


/*****************************************************************************/
/* SerDesConfigureTxEqualization
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesConfigureTxEqualization( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ConfigureTxEqualization\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesConfigureTxEqualization( eventInfo, userInfo );

    return status;

}   /* end SerDesConfigureTxEqualization */


/*****************************************************************************/
/* SerDesConfigureOptions
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesConfigureOptions( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ConfigureOptions\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesConfigureOptions( eventInfo, userInfo );

    return status;

}   /* end SerDesConfigureOptions */


/*****************************************************************************/
/* SerDesConfigureDfeMode
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesConfigureDfeMode( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ConfigureDfeMode\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesConfigureDfeMode( eventInfo, userInfo );

    return status;

}   /* end SerDesConfigureDfeMode */


/*****************************************************************************/
/* SerDesSaveDfeConfig
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesSaveDfeConfig( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing SaveDfeConfig\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesSaveDfeConfig( eventInfo, userInfo );

    return status;

}   /* end SerDesSaveDfeConfig */


/*****************************************************************************/
/* SerDesSaveBitRateConfig
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesSaveBitRateConfig( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing SaveBitRateConfig\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesSaveBitRateConfig( eventInfo, userInfo );

    return status;

}   /* end SerDesSaveBitRateConfig */


/*****************************************************************************/
/* SerDesSaveNearLoopbackOnConfig
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesSaveNearLoopbackOnConfig( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing SaveNearLoopbackOnConfig\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesSaveNearLoopbackOnConfig( eventInfo, userInfo );

    return status;

}   /* end SerDesSaveNearLoopbackOnConfig */


/*****************************************************************************/
/* SerDesSaveNearLoopbackOffConfig
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesSaveNearLoopbackOffConfig( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing SaveNearLoopbackOffConfig\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesSaveNearLoopbackOffConfig( eventInfo, userInfo );

    return status;

}   /* end SerDesSaveNearLoopbackOffConfig */


/*****************************************************************************/
/* SerDesSetFarLoopbackModeOn
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesSetFarLoopbackModeOn( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing SetFarLoopbackModeOn\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesSetFarLoopbackModeOn( eventInfo, userInfo );

    return status;

}   /* end SerDesSetFarLoopbackModeOn */


/*****************************************************************************/
/* SerDesSetFarLoopbackModeOff
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesSetFarLoopbackModeOff( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing SetFarLoopbackModeOff\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesSetFarLoopbackModeOff( eventInfo, userInfo );

    return status;

}   /* end SerDesSetFarLoopbackModeOff */


/*****************************************************************************/
/* SerDesInitStateVar
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesInitStateVar( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing InitStateVar\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesInitStateVar( eventInfo, userInfo );

    return status;

}   /* end SerDesInitStateVar */


/*****************************************************************************/
/* SerDesEnableTxOutput
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesEnableTxOutput( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing EnableTxOutput\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesEnableTxOutput( eventInfo, userInfo );

    return status;

}   /* end SerDesEnableTxOutput */


/*****************************************************************************/
/* SerDesDisableTxOutput
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDisableTxOutput( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing DisableTxOutput\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDisableTxOutput( eventInfo, userInfo );

    return status;

}   /* end SerDesDisableTxOutput */


/*****************************************************************************/
/* SerDesEnableBistMode
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesEnableBistMode( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing EnableBistMode\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesEnableBistMode( eventInfo, userInfo );

    return status;

}   /* end SerDesEnableBistMode */


/*****************************************************************************/
/* SerDesEnableTxBistMode
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesEnableTxBistMode( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing EnableTxBistMode\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesEnableTxBistMode( eventInfo, userInfo );

    return status;

}   /* end SerDesEnableTxBistMode */


/*****************************************************************************/
/* SerDesEnableRxBistMode
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesEnableRxBistMode( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing EnableRxBistMode\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesEnableRxBistMode( eventInfo, userInfo );

    return status;

}   /* end SerDesEnableRxBistMode */


/*****************************************************************************/
/* SerDesRemoveBistConfig
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesRemoveBistConfig( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing RemoveBistConfig\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesRemoveBistConfig( eventInfo, userInfo );

    return status;

}   /* end SerDesRemoveBistConfig */


/*****************************************************************************/
/* SerDesEnableNearLoopback
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesEnableNearLoopback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing EnableNearLoopback\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesEnableNearLoopback( eventInfo, userInfo );

    return status;

}   /* end SerDesEnableNearLoopback */


/*****************************************************************************/
/* SerDesDisableNearLoopback
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDisableNearLoopback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing DisableNearLoopback\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDisableNearLoopback( eventInfo, userInfo );

    return status;

}   /* end SerDesDisableNearLoopback */


/*****************************************************************************/
/* SerDesEnableParallelLoopback
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesEnableParallelLoopback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing EnableParallelLoopback\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesEnableParallelLoopback( eventInfo, userInfo );

    return status;

}   /* end SerDesEnableParallelLoopback */


/*****************************************************************************/
/* SerDesDisableParallelLoopback
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDisableParallelLoopback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing DisableParallelLoopback\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDisableParallelLoopback( eventInfo, userInfo );

    return status;

}   /* end SerDesDisableParallelLoopback */


/*****************************************************************************/
/* SerDesInitSignalOk
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesInitSignalOk( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing InitSignalOk\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesInitSignalOk( eventInfo, userInfo );

    return status;

}   /* end SerDesInitSignalOk */


/*****************************************************************************/
/* SerDesStartTimeoutTimerShrt
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesStartTimeoutTimerShrt( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing StartTimeoutTimerShrt\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesStartTimeoutTimerShrt( eventInfo, userInfo );

    return status;

}   /* end SerDesStartTimeoutTimerShrt */


/*****************************************************************************/
/* SerDesStartTimeoutTimerLng
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesStartTimeoutTimerLng( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing StartTimeoutTimerLng\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesStartTimeoutTimerLng( eventInfo, userInfo );

    return status;

}   /* end SerDesStartTimeoutTimerLng */


/*****************************************************************************/
/* SerDesStopTimeoutTimer
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesStopTimeoutTimer( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing StopTimeoutTimer\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesStopTimeoutTimer( eventInfo, userInfo );

    return status;

}   /* end SerDesStopTimeoutTimer */


/*****************************************************************************/
/* SerDesEnableTxRx
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesEnableTxRx( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing EnableTxRx\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesEnableTxRx( eventInfo, userInfo );

    return status;

}   /* end SerDesEnableTxRx */


/*****************************************************************************/
/* SerDesDisableTxRx
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDisableTxRx( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing DisableTxRx\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDisableTxRx( eventInfo, userInfo );

    return status;

}   /* end SerDesDisableTxRx */


/*****************************************************************************/
/* SerDesEnableRx
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesEnableRx( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing EnableRx\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesEnableRx( eventInfo, userInfo );

    return status;

}   /* end SerDesEnableRx */


/*****************************************************************************/
/* SerDesDisableRx
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDisableRx( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing DisableRx\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDisableRx( eventInfo, userInfo );

    return status;

}   /* end SerDesDisableRx */


/*****************************************************************************/
/* SerDesEnableTx
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesEnableTx( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing EnableTx\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesEnableTx( eventInfo, userInfo );

    return status;

}   /* end SerDesEnableTx */


/*****************************************************************************/
/* SerDesDisableTx
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDisableTx( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing DisableTx\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDisableTx( eventInfo, userInfo );

    return status;

}   /* end SerDesDisableTx */


/*****************************************************************************/
/* SerDesEnableInterrupts
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesEnableInterrupts( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing EnableInterrupts\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesEnableInterrupts( eventInfo, userInfo );

    return status;

}   /* end SerDesEnableInterrupts */


/*****************************************************************************/
/* SerDesDisableInterrupts
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDisableInterrupts( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing DisableInterrupts\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDisableInterrupts( eventInfo, userInfo );

    return status;

}   /* end SerDesDisableInterrupts */


/*****************************************************************************/
/* SerDesStopKrTraining
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesStopKrTraining( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing StopKrTraining\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesStopKrTraining( eventInfo, userInfo );

    return status;

}   /* end SerDesStopKrTraining */


/*****************************************************************************/
/* SerDesSendPortLaneReadyInd
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesSendPortLaneReadyInd( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing SendPortLaneReadyInd\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesSendPortLaneReadyInd( eventInfo, userInfo );

    return status;

}   /* end SerDesSendPortLaneReadyInd */


/*****************************************************************************/
/* SerDesSendPortKrTrainingCompleteInd
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesSendPortKrTrainingCompleteInd( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing SendPortKrTrainingCompleteInd\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesSendPortKrTrainingCompleteInd( eventInfo, userInfo );

    return status;

}   /* end SerDesSendPortKrTrainingCompleteInd */


/*****************************************************************************/
/* SerDesSendDfeStartTuningReq
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesSendDfeStartTuningReq( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing SendDfeStartTuningReq\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesSendDfeStartTuningReq( eventInfo, userInfo );

    return status;

}   /* end SerDesSendDfeStartTuningReq */


/*****************************************************************************/
/* SerDesSendDfeStopTuningReq
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesSendDfeStopTuningReq( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing SendDfeStopTuningReq\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesSendDfeStopTuningReq( eventInfo, userInfo );

    return status;

}   /* end SerDesSendDfeStopTuningReq */


/*****************************************************************************/
/* SerDesSendDfeSuspendTuningReq
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesSendDfeSuspendTuningReq( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing SendDfeSuspendTuningReq\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesSendDfeSuspendTuningReq( eventInfo, userInfo );

    return status;

}   /* end SerDesSendDfeSuspendTuningReq */


/*****************************************************************************/
/* SerDesSendDfeResumeTuningReq
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesSendDfeResumeTuningReq( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing SendDfeResumeTuningReq\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesSendDfeResumeTuningReq( eventInfo, userInfo );

    return status;

}   /* end SerDesSendDfeResumeTuningReq */


/*****************************************************************************/
/* SerDesSendKrStartPcalReq
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesSendKrStartPcalReq( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing SendKrStartPcalReq\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesSendKrStartPcalReq( eventInfo, userInfo );

    return status;

}   /* end SerDesSendKrStartPcalReq */


/*****************************************************************************/
/* SerDesDontSaveTransitionRecord
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDontSaveTransitionRecord( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing DontSaveTransitionRecord\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDontSaveTransitionRecord( eventInfo, userInfo );

    return status;

}   /* end SerDesDontSaveTransitionRecord */


/*****************************************************************************/
/* SerDesSaveTransitionRecord
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesSaveTransitionRecord( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing SaveTransitionRecord\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesSaveTransitionRecord( eventInfo, userInfo );

    return status;

}   /* end SerDesSaveTransitionRecord */


/*****************************************************************************/
/* SerDesStubAction
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesStubAction( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing StubAction\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesStubAction( eventInfo, userInfo );

    return status;

}   /* end SerDesStubAction */


/*****************************************************************************/
/* SerDesStartStubPllTimer
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesStartStubPllTimer( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing StartStubPllTimer\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesStartStubPllTimer( eventInfo, userInfo );

    return status;

}   /* end SerDesStartStubPllTimer */


/*****************************************************************************/
/* SerDesStopStubPllTimer
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesStopStubPllTimer( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing StopStubPllTimer\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesStopStubPllTimer( eventInfo, userInfo );

    return status;

}   /* end SerDesStopStubPllTimer */


/*****************************************************************************/
/* SerDesStartStubSignalTimer
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesStartStubSignalTimer( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing StartStubSignalTimer\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesStartStubSignalTimer( eventInfo, userInfo );

    return status;

}   /* end SerDesStartStubSignalTimer */


/*****************************************************************************/
/* SerDesStopStubSignalTimer
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesStopStubSignalTimer( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing StopStubSignalTimer\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesStopStubSignalTimer( eventInfo, userInfo );

    return status;

}   /* end SerDesStopStubSignalTimer */


/*****************************************************************************/
/* SerDesStartStubTuningTimer
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesStartStubTuningTimer( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing StartStubTuningTimer\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesStartStubTuningTimer( eventInfo, userInfo );

    return status;

}   /* end SerDesStartStubTuningTimer */


/*****************************************************************************/
/* SerDesStopStubTuningTimer
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesStopStubTuningTimer( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing StopStubTuningTimer\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesStopStubTuningTimer( eventInfo, userInfo );

    return status;

}   /* end SerDesStopStubTuningTimer */


/*****************************************************************************/
/* SerDesStartKrDeferralTimer
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesStartKrDeferralTimer( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing StartKrDeferralTimer\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesStartKrDeferralTimer( eventInfo, userInfo );

    return status;

}   /* end SerDesStartKrDeferralTimer */


/*****************************************************************************/
/* SerDesMarkTxPllUp
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesMarkTxPllUp( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing MarkTxPllUp\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesMarkTxPllUp( eventInfo, userInfo );

    return status;

}   /* end SerDesMarkTxPllUp */


/*****************************************************************************/
/* SerDesMarkRxPllUp
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesMarkRxPllUp( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing MarkRxPllUp\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesMarkRxPllUp( eventInfo, userInfo );

    return status;

}   /* end SerDesMarkRxPllUp */


/*****************************************************************************/
/* SerDesMarkBothPllsUp
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesMarkBothPllsUp( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing MarkBothPllsUp\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesMarkBothPllsUp( eventInfo, userInfo );

    return status;

}   /* end SerDesMarkBothPllsUp */


/*****************************************************************************/
/* SerDesMarkTxPllDown
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesMarkTxPllDown( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing MarkTxPllDown\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesMarkTxPllDown( eventInfo, userInfo );

    return status;

}   /* end SerDesMarkTxPllDown */


/*****************************************************************************/
/* SerDesMarkRxPllDown
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesMarkRxPllDown( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing MarkRxPllDown\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesMarkRxPllDown( eventInfo, userInfo );

    return status;

}   /* end SerDesMarkRxPllDown */


/*****************************************************************************/
/* SerDesMarkBothPllsDown
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesMarkBothPllsDown( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing MarkBothPllsDown\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesMarkBothPllsDown( eventInfo, userInfo );

    return status;

}   /* end SerDesMarkBothPllsDown */


/*****************************************************************************/
/* SerDesDumpBitRate
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDumpBitRate( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing DumpBitRate\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDumpBitRate( eventInfo, userInfo );

    return status;

}   /* end SerDesDumpBitRate */


/*****************************************************************************/
/* SerDesDisableLanePolarity
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDisableLanePolarity( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing DisableLanePolarity\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDisableLanePolarity( eventInfo, userInfo );

    return status;

}   /* end SerDesDisableLanePolarity */


/*****************************************************************************/
/* SerDesConfigLanePolarity
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesConfigLanePolarity( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ConfigLanePolarity\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesConfigLanePolarity( eventInfo, userInfo );

    return status;

}   /* end SerDesConfigLanePolarity */


/*****************************************************************************/
/* SerDesResetSpico
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesResetSpico( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ResetSpico\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesResetSpico( eventInfo, userInfo );

    return status;

}   /* end SerDesResetSpico */


/*****************************************************************************/
/* SerDesRestoreSpico
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesRestoreSpico( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing RestoreSpico\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesRestoreSpico( eventInfo, userInfo );

    return status;

}   /* end SerDesRestoreSpico */


/*****************************************************************************/
/* SerDesEnableEeeOpMode
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesEnableEeeOpMode( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing EnableEeeOpMode\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesEnableEeeOpMode( eventInfo, userInfo );

    return status;

}   /* end SerDesEnableEeeOpMode */


/*****************************************************************************/
/* SerDesDisableEeeOpMode
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDisableEeeOpMode( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing DisableEeeOpMode\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDisableEeeOpMode( eventInfo, userInfo );

    return status;

}   /* end SerDesDisableEeeOpMode */


/*****************************************************************************/
/* SerDesRstSignalOkDebounce
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesRstSignalOkDebounce( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing RstSignalOkDebounce\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesRstSignalOkDebounce( eventInfo, userInfo );

    return status;

}   /* end SerDesRstSignalOkDebounce */


/*****************************************************************************/
/* SerDesConfigureEee
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesConfigureEee( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ConfigureEee\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesConfigureEee( eventInfo, userInfo );

    return status;

}   /* end SerDesConfigureEee */


/*****************************************************************************/
/* SerDesSaveKrTimeoutStats
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesSaveKrTimeoutStats( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing SaveKrTimeoutStats\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesSaveKrTimeoutStats( eventInfo, userInfo );

    return status;

}   /* end SerDesSaveKrTimeoutStats */


/*****************************************************************************/
/* SerDesExecuteErrorValidation
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesExecuteErrorValidation( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ExecuteErrorValidation\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesExecuteErrorValidation( eventInfo, userInfo );

    return status;

}   /* end SerDesExecuteErrorValidation */


/*****************************************************************************/
/* SerDesExecuteErrorValidationWithActions
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesExecuteErrorValidationWithActions( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ExecuteErrorValidationWithActions\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesExecuteErrorValidationWithActions( eventInfo, userInfo );

    return status;

}   /* end SerDesExecuteErrorValidationWithActions */


/*****************************************************************************/
/* SerDesExecutePendingErrorActions
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesExecutePendingErrorActions( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ExecutePendingErrorActions\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesExecutePendingErrorActions( eventInfo, userInfo );

    return status;

}   /* end SerDesExecutePendingErrorActions */


/*****************************************************************************/
/* SerDesStartErrorValidationTimer
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesStartErrorValidationTimer( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing StartErrorValidationTimer\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesStartErrorValidationTimer( eventInfo, userInfo );

    return status;

}   /* end SerDesStartErrorValidationTimer */


/*****************************************************************************/
/* SerDesStopErrorValidationTimer
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesStopErrorValidationTimer( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing StopErrorValidationTimer\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesStopErrorValidationTimer( eventInfo, userInfo );

    return status;

}   /* end SerDesStopErrorValidationTimer */


/*****************************************************************************/
/* SerDesProcessSignalOkAsserted
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesProcessSignalOkAsserted( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ProcessSignalOkAsserted\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesProcessSignalOkAsserted( eventInfo, userInfo, nextState );

    return status;

}   /* end SerDesProcessSignalOkAsserted */


/*****************************************************************************/
/* SerDesProcessSignalOkAssertedRx
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesProcessSignalOkAssertedRx( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ProcessSignalOkAssertedRx\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesProcessSignalOkAssertedRx( eventInfo, userInfo, nextState );

    return status;

}   /* end SerDesProcessSignalOkAssertedRx */


/*****************************************************************************/
/* SerDesProcessSignalOkDeasserted
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesProcessSignalOkDeasserted( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ProcessSignalOkDeasserted\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesProcessSignalOkDeasserted( eventInfo, userInfo, nextState );

    return status;

}   /* end SerDesProcessSignalOkDeasserted */


/*****************************************************************************/
/* SerDesProcessSignalOkDeassertedRx
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesProcessSignalOkDeassertedRx( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ProcessSignalOkDeassertedRx\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesProcessSignalOkDeassertedRx( eventInfo, userInfo, nextState );

    return status;

}   /* end SerDesProcessSignalOkDeassertedRx */


/*****************************************************************************/
/* SerDesProcessSignalOkTimeout
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesProcessSignalOkTimeout( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ProcessSignalOkTimeout\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesProcessSignalOkTimeout( eventInfo, userInfo, nextState );

    return status;

}   /* end SerDesProcessSignalOkTimeout */


/*****************************************************************************/
/* SerDesProcessSignalOkTimeoutRx
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesProcessSignalOkTimeoutRx( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ProcessSignalOkTimeoutRx\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesProcessSignalOkTimeoutRx( eventInfo, userInfo, nextState );

    return status;

}   /* end SerDesProcessSignalOkTimeoutRx */


/*****************************************************************************/
/* SerDesProcessSignalNokTimeout
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesProcessSignalNokTimeout( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ProcessSignalNokTimeout\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesProcessSignalNokTimeout( eventInfo, userInfo, nextState );

    return status;

}   /* end SerDesProcessSignalNokTimeout */


/*****************************************************************************/
/* SerDesProcessSignalNokTimeoutRx
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesProcessSignalNokTimeoutRx( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ProcessSignalNokTimeoutRx\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesProcessSignalNokTimeoutRx( eventInfo, userInfo, nextState );

    return status;

}   /* end SerDesProcessSignalNokTimeoutRx */


/*****************************************************************************/
/* SerDesProcessDfeTuningTimeout
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesProcessDfeTuningTimeout( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ProcessDfeTuningTimeout\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesProcessDfeTuningTimeout( eventInfo, userInfo, nextState );

    return status;

}   /* end SerDesProcessDfeTuningTimeout */


/*****************************************************************************/
/* SerDesProcessKrTrainingTimeout
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesProcessKrTrainingTimeout( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ProcessKrTrainingTimeout\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesProcessKrTrainingTimeout( eventInfo, userInfo, nextState );

    return status;

}   /* end SerDesProcessKrTrainingTimeout */


/*****************************************************************************/
/* SerDesProcessKrTrainingSignalOk
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesProcessKrTrainingSignalOk( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ProcessKrTrainingSignalOk\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesProcessKrTrainingSignalOk( eventInfo, userInfo, nextState );

    return status;

}   /* end SerDesProcessKrTrainingSignalOk */


/*****************************************************************************/
/* SerDesProcessRxTxPllLockEvents
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesProcessRxTxPllLockEvents( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ProcessRxTxPllLockEvents\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesProcessRxTxPllLockEvents( eventInfo, userInfo, nextState );

    return status;

}   /* end SerDesProcessRxTxPllLockEvents */


/*****************************************************************************/
/* SerDesProcessRxTxPllLockTimeout
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesProcessRxTxPllLockTimeout( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ProcessRxTxPllLockTimeout\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesProcessRxTxPllLockTimeout( eventInfo, userInfo, nextState );

    return status;

}   /* end SerDesProcessRxTxPllLockTimeout */


/*****************************************************************************/
/* SerDesProcessRxPllLockTimeout
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesProcessRxPllLockTimeout( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ProcessRxPllLockTimeout\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesProcessRxPllLockTimeout( eventInfo, userInfo, nextState );

    return status;

}   /* end SerDesProcessRxPllLockTimeout */


/*****************************************************************************/
/* SerDesProcessTxPllLockTimeout
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesProcessTxPllLockTimeout( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ProcessTxPllLockTimeout\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesProcessTxPllLockTimeout( eventInfo, userInfo, nextState );

    return status;

}   /* end SerDesProcessTxPllLockTimeout */


/*****************************************************************************/
/* SerDesProcessStubPllTimer
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesProcessStubPllTimer( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ProcessStubPllTimer\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesProcessStubPllTimer( eventInfo, userInfo, nextState );

    return status;

}   /* end SerDesProcessStubPllTimer */


/*****************************************************************************/
/* SerDesProcessStubSignalTimer
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesProcessStubSignalTimer( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ProcessStubSignalTimer\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesProcessStubSignalTimer( eventInfo, userInfo, nextState );

    return status;

}   /* end SerDesProcessStubSignalTimer */


/*****************************************************************************/
/* SerDesProcessStubTuningTimer
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesProcessStubTuningTimer( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ProcessStubTuningTimer\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesProcessStubTuningTimer( eventInfo, userInfo, nextState );

    return status;

}   /* end SerDesProcessStubTuningTimer */


/*****************************************************************************/
/* SerDesProcessEnableBistMode
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesProcessEnableBistMode( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ProcessEnableBistMode\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesProcessEnableBistMode( eventInfo, userInfo, nextState );

    return status;

}   /* end SerDesProcessEnableBistMode */


/*****************************************************************************/
/* SerDesProcessDisableBistMode
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesProcessDisableBistMode( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ProcessDisableBistMode\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesProcessDisableBistMode( eventInfo, userInfo, nextState );

    return status;

}   /* end SerDesProcessDisableBistMode */


/*****************************************************************************/
/* SerDesProcessBistDisableLoopback
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesProcessBistDisableLoopback( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ProcessBistDisableLoopback\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesProcessBistDisableLoopback( eventInfo, userInfo, nextState );

    return status;

}   /* end SerDesProcessBistDisableLoopback */


/*****************************************************************************/
/* SerDesProcessDfeComplete
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesProcessDfeComplete( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ProcessDfeComplete\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesProcessDfeComplete( eventInfo, userInfo, nextState );

    return status;

}   /* end SerDesProcessDfeComplete */


/*****************************************************************************/
/* SerDesProcessDfeICalComplete
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesProcessDfeICalComplete( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ProcessDfeICalComplete\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesProcessDfeICalComplete( eventInfo, userInfo, nextState );

    return status;

}   /* end SerDesProcessDfeICalComplete */


/*****************************************************************************/
/* SerDesConfigureEthOrPcie
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesConfigureEthOrPcie( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the SerDes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ConfigureEthOrPcie\n", 
                     fm10000SerDesEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesConfigureEthOrPcie( eventInfo, userInfo, nextState );

    return status;

}   /* end SerDesConfigureEthOrPcie */




/******************************************************************************
 * Definitions of transition group callbacks 
 *****************************************************************************/


/*****************************************************************************/
/* TransitionGroup0
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(0)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesExecuteErrorValidation( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDontSaveTransitionRecord( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup0 */


/*****************************************************************************/
/* TransitionGroup1
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(1)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesEnableEeeOpMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup1 */


/*****************************************************************************/
/* TransitionGroup2
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(2)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesDisableRx( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup2 */


/*****************************************************************************/
/* TransitionGroup3
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(3)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesDisableEeeOpMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesStartTimeoutTimerShrt( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup3 */


/*****************************************************************************/
/* TransitionGroup4
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(4)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesSaveDfeConfig( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesSendDfeStopTuningReq( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesStartTimeoutTimerShrt( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup4 */


/*****************************************************************************/
/* TransitionGroup5
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(5)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesDisableTxRx( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesExecutePendingErrorActions( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup5 */


/*****************************************************************************/
/* TransitionGroup6
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(6)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesSetFarLoopbackModeOff( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup6 */


/*****************************************************************************/
/* TransitionGroup7
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(7)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesSetSignalDtctForcedBadC( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableTxRx( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesStopTimeoutTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup7 */


/*****************************************************************************/
/* TransitionGroup8
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(8)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesSendPortLaneReadyInd( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup8 */


/*****************************************************************************/
/* TransitionGroup9
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(9)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesSetSignalDtctForcedBadC( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesSendDfeStopTuningReq( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableTxRx( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableEeeOpMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesStopTimeoutTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup9 */


/*****************************************************************************/
/* TransitionGroup10
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(10)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesDisableTxRx( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesStopTimeoutTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup10 */


/*****************************************************************************/
/* TransitionGroup11
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(11)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesRstSignalOkDebounce( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup11 */


/*****************************************************************************/
/* TransitionGroup12
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(12)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesDisableTxRx( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableEeeOpMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesStopTimeoutTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup12 */


/*****************************************************************************/
/* TransitionGroup13
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(13)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesStartErrorValidationTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesSaveBitRateConfig( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup13 */


/*****************************************************************************/
/* TransitionGroup14
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(14)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesSendDfeStopTuningReq( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableTxRx( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesSetSignalDtctForcedBadC( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup14 */


/*****************************************************************************/
/* TransitionGroup15
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(15)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesDisableRx( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup15 */


/*****************************************************************************/
/* TransitionGroup16
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(16)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesDontSaveTransitionRecord( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup16 */


/*****************************************************************************/
/* TransitionGroup17
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(17)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesEnableTxBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup17 */


/*****************************************************************************/
/* TransitionGroup18
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(18)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesSetSignalDtctNormal( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup18 */


/*****************************************************************************/
/* TransitionGroup19
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(19)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesSetSignalDtctForcedBadC( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesSendDfeStopTuningReq( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableTxRx( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableEeeOpMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup19 */


/*****************************************************************************/
/* TransitionGroup20
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(20)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesSetSignalDtctForcedBadC( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesSendDfeStopTuningReq( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableTxRx( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesStopTimeoutTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup20 */


/*****************************************************************************/
/* TransitionGroup21
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(21)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesDisableTxRx( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesStopTimeoutTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup21 */


/*****************************************************************************/
/* TransitionGroup22
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(22)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesDisableTx( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup22 */


/*****************************************************************************/
/* TransitionGroup23
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(23)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesStopErrorValidationTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDontSaveTransitionRecord( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup23 */


/*****************************************************************************/
/* TransitionGroup24
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(24)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesSaveDfeConfig( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup24 */


/*****************************************************************************/
/* TransitionGroup25
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(25)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesStartTimeoutTimerShrt( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDontSaveTransitionRecord( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup25 */


/*****************************************************************************/
/* TransitionGroup26
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(26)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesDisableEeeOpMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup26 */


/*****************************************************************************/
/* TransitionGroup27
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(27)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesSetFarLoopbackModeOn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup27 */


/*****************************************************************************/
/* TransitionGroup28
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(28)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesDisableTx( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup28 */


/*****************************************************************************/
/* TransitionGroup29
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(29)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesSetSignalDtctForcedBadC( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesSendDfeStopTuningReq( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableTxRx( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup29 */


/*****************************************************************************/
/* TransitionGroup30
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(30)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesSetSignalDtctForcedBadC( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesEnableRx( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup30 */


/*****************************************************************************/
/* TransitionGroup31
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(31)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesRstSignalOkDebounce( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDontSaveTransitionRecord( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup31 */


/*****************************************************************************/
/* TransitionGroup32
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(32)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesSetSignalDtctForcedBadC( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableTxRx( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup32 */


/*****************************************************************************/
/* TransitionGroup33
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(33)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesSaveNearLoopbackOffConfig( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup33 */


/*****************************************************************************/
/* TransitionGroup34
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(34)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesSetSignalDtctForcedBadC( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableNearLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesConfigLanePolarity( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesEnableTxOutput( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesStartTimeoutTimerShrt( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesExecutePendingErrorActions( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup34 */


/*****************************************************************************/
/* TransitionGroup35
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(35)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesEnableBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup35 */


/*****************************************************************************/
/* TransitionGroup36
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(36)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesEnableTx( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup36 */


/*****************************************************************************/
/* TransitionGroup37
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(37)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesExecuteErrorValidationWithActions( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesRestoreSpico( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesConfigureBitRateAndWidthMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesConfigureDataSelect( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesConfigureTxEqualization( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesConfigureDfeMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesConfigureOptions( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesConfigLanePolarity( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesInitStateVar( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesSetSignalDtctForcedBadC( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesEnableRx( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesEnableInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesStartTimeoutTimerLng( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup37 */


/*****************************************************************************/
/* TransitionGroup38
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(38)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesRemoveBistConfig( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup38 */


/*****************************************************************************/
/* TransitionGroup39
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(39)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesEnableRx( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup39 */


/*****************************************************************************/
/* TransitionGroup40
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(40)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesSendDfeStopTuningReq( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableLanePolarity( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesEnableNearLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableTxOutput( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup40 */


/*****************************************************************************/
/* TransitionGroup41
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(41)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesStartTimeoutTimerLng( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup41 */


/*****************************************************************************/
/* TransitionGroup42
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(42)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesDisableTxRx( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableEeeOpMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesStopTimeoutTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesExecutePendingErrorActions( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup42 */


/*****************************************************************************/
/* TransitionGroup43
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(43)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesExecutePendingErrorActions( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup43 */


/*****************************************************************************/
/* TransitionGroup44
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(44)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesExecuteErrorValidation( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesEnableRxBistMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup44 */


/*****************************************************************************/
/* TransitionGroup45
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(45)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesExecuteErrorValidationWithActions( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesRestoreSpico( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesConfigureBitRateAndWidthMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesConfigureDataSelect( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesConfigureTxEqualization( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesConfigureDfeMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesConfigureOptions( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesConfigLanePolarity( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesInitStateVar( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesSetSignalDtctForcedBadC( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesEnableTx( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesEnableInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesStartTimeoutTimerLng( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup45 */


/*****************************************************************************/
/* TransitionGroup46
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(46)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesSaveNearLoopbackOnConfig( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup46 */


/*****************************************************************************/
/* TransitionGroup47
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(47)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesSendDfeStopTuningReq( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableLanePolarity( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesEnableNearLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableTxOutput( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesSetSignalDtctNormal( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup47 */


/*****************************************************************************/
/* TransitionGroup48
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(48)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesDisableTxRx( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup48 */


/*****************************************************************************/
/* TransitionGroup49
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(49)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesFlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesExecutePendingErrorActions( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup49 */


/*****************************************************************************/
/* TransitionGroup50
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(50)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesSaveDfeConfig( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesExecutePendingErrorActions( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup50 */


/*****************************************************************************/
/* TransitionGroup51
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(51)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesSendDfeStopTuningReq( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableTxRx( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesSetSignalDtctForcedBadC( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesStopTimeoutTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup51 */


/*****************************************************************************/
/* TransitionGroup52
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(52)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesExecuteErrorValidationWithActions( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDontSaveTransitionRecord( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup52 */


/*****************************************************************************/
/* TransitionGroup53
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(53)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesDisableLanePolarity( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesEnableNearLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableTxOutput( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesSetSignalDtctNormal( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesExecuteErrorValidationWithActions( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup53 */


/*****************************************************************************/
/* TransitionGroup54
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(54)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesSetSignalDtctForcedBadC( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesSendDfeStopTuningReq( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableTxRx( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableEeeOpMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesStopTimeoutTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesExecutePendingErrorActions( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup54 */


/*****************************************************************************/
/* TransitionGroup55
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(55)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesEnableTxOutput( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesStartTimeoutTimerShrt( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesSendPortLaneReadyInd( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup55 */


/*****************************************************************************/
/* TransitionGroup56
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(56)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesStartErrorValidationTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDontSaveTransitionRecord( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup56 */


/*****************************************************************************/
/* TransitionGroup57
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(57)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesEnableEeeOpMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesExecutePendingErrorActions( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup57 */


/*****************************************************************************/
/* TransitionGroup58
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(58)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesExecuteErrorValidationWithActions( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesRestoreSpico( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesConfigureBitRateAndWidthMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesConfigureDataSelect( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesConfigureTxEqualization( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesConfigureDfeMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesConfigureOptions( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesConfigLanePolarity( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesInitStateVar( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesSetSignalDtctForcedBadC( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesEnableTxRx( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesEnableInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesStartTimeoutTimerLng( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesConfigureEee( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup58 */


/*****************************************************************************/
/* TransitionGroup59
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(59)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesSaveBitRateConfig( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup59 */


/*****************************************************************************/
/* TransitionGroup60
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(60)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesStopKrTraining( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableLanePolarity( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesEnableNearLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableTxOutput( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup60 */


/*****************************************************************************/
/* TransitionGroup61
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(61)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesDisableLanePolarity( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesEnableNearLoopback( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableTxOutput( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup61 */


/*****************************************************************************/
/* TransitionGroup62
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(62)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesFlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup62 */


/*****************************************************************************/
/* TransitionGroup63
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(63)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesStartTimeoutTimerShrt( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup63 */


/*****************************************************************************/
/* TransitionGroup64
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(64)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesSendKrStartPcalReq( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup64 */


/*****************************************************************************/
/* TransitionGroup65
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(65)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesSaveKrTimeoutStats( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesStopKrTraining( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableTxRx( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDisableEeeOpMode( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesStopTimeoutTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup65 */


/*****************************************************************************/
/* TransitionGroup66
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(66)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesSetSignalDtctForcedBadC( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesEnableTx( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup66 */


/*****************************************************************************/
/* TransitionGroup67
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(67)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesMarkBothPllsDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup67 */


/*****************************************************************************/
/* TransitionGroup68
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(68)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesStubAction( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup68 */


/*****************************************************************************/
/* TransitionGroup69
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(69)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesMarkTxPllDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup69 */


/*****************************************************************************/
/* TransitionGroup70
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(70)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesMarkTxPllUp( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup70 */


/*****************************************************************************/
/* TransitionGroup71
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(71)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesMarkBothPllsDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesStopStubSignalTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup71 */


/*****************************************************************************/
/* TransitionGroup72
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(72)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesMarkRxPllUp( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup72 */


/*****************************************************************************/
/* TransitionGroup73
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(73)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesExecutePendingErrorActions( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesMarkBothPllsUp( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup73 */


/*****************************************************************************/
/* TransitionGroup74
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(74)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesMarkBothPllsUp( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesStartStubPllTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup74 */


/*****************************************************************************/
/* TransitionGroup75
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(75)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesMarkBothPllsUp( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesStartStubPllTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesStartErrorValidationTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup75 */


/*****************************************************************************/
/* TransitionGroup76
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(76)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesStartStubPllTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup76 */


/*****************************************************************************/
/* TransitionGroup77
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(77)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesMarkRxPllDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup77 */


/*****************************************************************************/
/* TransitionGroup78
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(78)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesMarkRxPllUp( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesStartStubPllTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup78 */


/*****************************************************************************/
/* TransitionGroup79
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(79)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesMarkBothPllsDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesStopStubPllTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup79 */


/*****************************************************************************/
/* TransitionGroup80
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(80)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesMarkTxPllUp( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesStartStubPllTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup80 */


/*****************************************************************************/
/* TransitionGroup81
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(81)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesMarkBothPllsDown( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesStopStubTuningTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup81 */


/*****************************************************************************/
/* TransitionGroup82
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(82)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesMarkBothPllsUp( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup82 */


/*****************************************************************************/
/* TransitionGroup83
 *
 * \desc            Transition callback for SerDes state machine. 
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(83)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesExecutePendingErrorActions( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesMarkTxPllUp( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup83 */



/*****************************************************************************
 * Public Functions
 *****************************************************************************/


/*****************************************************************************/
/* fm10000RegisterBasicSerDesStateMachine
 *
 * \desc            This function registers with the Generic State Machine
 *                  Engine state machine type ''FM10000_BASIC_SERDES_STATE_MACHINE''.
 * 
 * \return          FM_OK if the state machine was created successfully.
 * 
 * \return          FM_ERR_INVALID_ARGUMENT if one of the arguments is invalid.
 *
 * \return          FM_ERR_NO_MEM if there was a memory allocation failure
 *                  while creating one of the state machine internal structures.
 * 
 * \return          FM_ERR_STATE_MACHINE_TYPE if this state machine type is
 *                  already registered.
 *
 *****************************************************************************/
fm_status fm10000RegisterBasicSerDesStateMachine( void )
{
    fm_uint     i;
    fm_status   status;
    fm_smTransitionEntry  stt[FM10000_SERDES_STATE_MAX][FM10000_SERDES_EVENT_MAX];
    fm_smTransitionEntry *dynstt[FM10000_SERDES_STATE_MAX];
    fm_smTransitionLogCallback logCallback;

    
    /* log callback for this type */
    logCallback = fm10000LogSerDesTransition;
    

    /* clear out the temporary state transition table */
    FM_MEMSET_S( stt, sizeof(stt), 0, sizeof(stt));
    for (i = 0 ; 
         i < (sizeof(fm10000BasicSmTable) / sizeof(fm_smTable)) ;
         i++)
    { 
        stt[fm10000BasicSmTable[i].current]
           [fm10000BasicSmTable[i].event].used = TRUE;

        stt[fm10000BasicSmTable[i].current]
           [fm10000BasicSmTable[i].event].nextState = 
               fm10000BasicSmTable[i].next;

        if (fm10000BasicSmTable[i].next == FM_STATE_UNSPECIFIED)
        {
            stt[fm10000BasicSmTable[i].current]
               [fm10000BasicSmTable[i].event].conditionCallback = 
                   (fm_smConditionCallback) fm10000BasicSmTable[i].callback;

            stt[fm10000BasicSmTable[i].current]
               [fm10000BasicSmTable[i].event].transitionCallback = NULL;
        }
        else
        {
            stt[fm10000BasicSmTable[i].current]
               [fm10000BasicSmTable[i].event].conditionCallback = NULL;

            stt[fm10000BasicSmTable[i].current]
               [fm10000BasicSmTable[i].event].transitionCallback = 
                   (fm_smTransitionCallback) fm10000BasicSmTable[i].callback;
        }
    }
 
    /* fill out the state transition table for this state machine type */
    for (i = 0 ; i < FM10000_SERDES_STATE_MAX ; i++)
    {
        dynstt[i] = &stt[i][0];
    }

    /* register this state machine type */
    status = fmRegisterStateTransitionTable( FM10000_BASIC_SERDES_STATE_MACHINE,
                                             FM10000_SERDES_STATE_MAX,
                                             FM10000_SERDES_EVENT_MAX,
                                             dynstt,
                                             logCallback,
                                             TRUE ); 
    return status;

}   /* end fm10000RegisterBasicSerDesStateMachine */


/*****************************************************************************/
/* fm10000RegisterPcieSerDesStateMachine
 *
 * \desc            This function registers with the Generic State Machine
 *                  Engine state machine type ''FM10000_PCIE_SERDES_STATE_MACHINE''.
 * 
 * \return          FM_OK if the state machine was created successfully.
 * 
 * \return          FM_ERR_INVALID_ARGUMENT if one of the arguments is invalid.
 *
 * \return          FM_ERR_NO_MEM if there was a memory allocation failure
 *                  while creating one of the state machine internal structures.
 * 
 * \return          FM_ERR_STATE_MACHINE_TYPE if this state machine type is
 *                  already registered.
 *
 *****************************************************************************/
fm_status fm10000RegisterPcieSerDesStateMachine( void )
{
    fm_uint     i;
    fm_status   status;
    fm_smTransitionEntry  stt[FM10000_SERDES_STATE_MAX][FM10000_SERDES_EVENT_MAX];
    fm_smTransitionEntry *dynstt[FM10000_SERDES_STATE_MAX];
    fm_smTransitionLogCallback logCallback;

    
    /* log callback for this type */
    logCallback = fm10000LogSerDesTransition;
    

    /* clear out the temporary state transition table */
    FM_MEMSET_S( stt, sizeof(stt), 0, sizeof(stt));
 
    /* fill out the state transition table for this state machine type */
    for (i = 0 ; i < FM10000_SERDES_STATE_MAX ; i++)
    {
        dynstt[i] = &stt[i][0];
    }

    /* register this state machine type */
    status = fmRegisterStateTransitionTable( FM10000_PCIE_SERDES_STATE_MACHINE,
                                             FM10000_SERDES_STATE_MAX,
                                             FM10000_SERDES_EVENT_MAX,
                                             dynstt,
                                             logCallback,
                                             TRUE ); 
    return status;

}   /* end fm10000RegisterPcieSerDesStateMachine */


/*****************************************************************************/
/* fm10000RegisterStubSerDesStateMachine
 *
 * \desc            This function registers with the Generic State Machine
 *                  Engine state machine type ''FM10000_STUB_SERDES_STATE_MACHINE''.
 * 
 * \return          FM_OK if the state machine was created successfully.
 * 
 * \return          FM_ERR_INVALID_ARGUMENT if one of the arguments is invalid.
 *
 * \return          FM_ERR_NO_MEM if there was a memory allocation failure
 *                  while creating one of the state machine internal structures.
 * 
 * \return          FM_ERR_STATE_MACHINE_TYPE if this state machine type is
 *                  already registered.
 *
 *****************************************************************************/
fm_status fm10000RegisterStubSerDesStateMachine( void )
{
    fm_uint     i;
    fm_status   status;
    fm_smTransitionEntry  stt[FM10000_SERDES_STATE_MAX][FM10000_SERDES_EVENT_MAX];
    fm_smTransitionEntry *dynstt[FM10000_SERDES_STATE_MAX];
    fm_smTransitionLogCallback logCallback;

    
    /* log callback for this type */
    logCallback = fm10000LogSerDesTransition;
    

    /* clear out the temporary state transition table */
    FM_MEMSET_S( stt, sizeof(stt), 0, sizeof(stt));
    for (i = 0 ; 
         i < (sizeof(fm10000StubSmTable) / sizeof(fm_smTable)) ;
         i++)
    { 
        stt[fm10000StubSmTable[i].current]
           [fm10000StubSmTable[i].event].used = TRUE;

        stt[fm10000StubSmTable[i].current]
           [fm10000StubSmTable[i].event].nextState = 
               fm10000StubSmTable[i].next;

        if (fm10000StubSmTable[i].next == FM_STATE_UNSPECIFIED)
        {
            stt[fm10000StubSmTable[i].current]
               [fm10000StubSmTable[i].event].conditionCallback = 
                   (fm_smConditionCallback) fm10000StubSmTable[i].callback;

            stt[fm10000StubSmTable[i].current]
               [fm10000StubSmTable[i].event].transitionCallback = NULL;
        }
        else
        {
            stt[fm10000StubSmTable[i].current]
               [fm10000StubSmTable[i].event].conditionCallback = NULL;

            stt[fm10000StubSmTable[i].current]
               [fm10000StubSmTable[i].event].transitionCallback = 
                   (fm_smTransitionCallback) fm10000StubSmTable[i].callback;
        }
    }
 
    /* fill out the state transition table for this state machine type */
    for (i = 0 ; i < FM10000_SERDES_STATE_MAX ; i++)
    {
        dynstt[i] = &stt[i][0];
    }

    /* register this state machine type */
    status = fmRegisterStateTransitionTable( FM10000_STUB_SERDES_STATE_MACHINE,
                                             FM10000_SERDES_STATE_MAX,
                                             FM10000_SERDES_EVENT_MAX,
                                             dynstt,
                                             logCallback,
                                             TRUE ); 
    return status;

}   /* end fm10000RegisterStubSerDesStateMachine */


