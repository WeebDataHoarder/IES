/* vim:ts=4:sw=4:expandtab
 * (No tabs, indent level is 4 spaces) */
/*****************************************************************************
 * File:            fm10000_api_serdes_dfe_state_machines.c
 * Creation Date:   October 30, 2013
 * Description:     Source file for the serdes-level state machine.
 * 
 *                  ------------------------------------------------------
 *                  THIS FILE IS AUTO-GENERATED BY THE BUILD SYSTEM. DO
 *                  NOT MODIFY THIS FILE. MODIFY THE FOLLOWING INSTEAD:
 * 
 *                  1) fm10000_api_serdes_dfe_state_machines.xml
 *                  2) templates/fm10000_api_serdes_dfe_state_machines.c
 *                  ------------------------------------------------------
 *
 * Copyright (c) 2007 - 2015, Intel Corporation
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Intel Corporation nor the names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

#include <fm_sdk_fm10000_int.h>

/*****************************************************************************
 * Macros, Constants & Types
 *****************************************************************************/

#define ST(s) FM10000_SERDES_DFE_STATE_ ## s
#define EV(e) FM10000_SERDES_DFE_EVENT_ ## e
#define TG(g) TransitionGroup ## g
#define FN(n) (genericFunction) n

typedef void (*genericFunction)(void);

/****************************************************************/
/** \ingroup intSerDesDfeStateMachine 
 * Definition of the State Machine Transition Table values.
 ****************************************************************/
typedef struct _fm_smTable
{
    /* callback for transition or condition */
    genericFunction         callback;
    
    /** current state identifier */
    fm_int                  current;

    /** event identifier */
    fm_int                  event;

    /** next state identifier */
    fm_int                  next;

} fm_smTable;


/*****************************************************************************
 * Local function prototypes
 *****************************************************************************/

/* declaration of all action callbacks */
static fm_status SerDesDfeFlagError( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDfeConfigDfe( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDfeStartTuning( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDfePauseTuning( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDfeResumeTuning( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDfeStartKrPCalTuning( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDfeStartTimeoutTimerShrt( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDfeStartTimeoutTimerStopTuning( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDfeStartTimeoutTimerDebounce( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDfeStartTimeoutTimerAdaptive( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDfeStopTimeoutTimer( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDfeLoadRetryCntr( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDfeClrCycleCntr( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDfeClrRetryCntr( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDfeIncCycleCntr( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDfeStopTuning( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDfeSendTuningStartedInd( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDfeSendTuningStoppedInd( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDfeSendTuningCompleteInd( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDfeSendICalTuningCompleteInd( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDfeReadEyeW( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDfeReadEyeH( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDfeConfigureEyeW( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDfeConfigureEyeH( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDfeDontSaveRecord( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status SerDesDfeRestartStopTuningTimer( fm_smEventInfo *eventInfo, void *userInfo );



/* declaration of all condition callbacks */
static fm_status SerDesDfeProcessPCalTimeout( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status SerDesDfeProcessPushAutoStartTuning( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );
static fm_status SerDesDfeProcessICalTimeout( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );



/* declaration of transition group callbacks */
static fm_status TG(0)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(1)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(2)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(3)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(4)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(5)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(6)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(7)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(8)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(9)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(10)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(11)( fm_smEventInfo *eventInfo, void *userInfo );


/*****************************************************************************
 * Global Variables
 *****************************************************************************/

/* array containing descriptive names for each of the SerDesDfe states */
fm_text fm10000SerDesDfeStatesMap[FM10000_SERDES_DFE_STATE_MAX] =
{
    "START",
    "WAIT_ICAL",
    "WAIT_PCAL",
    "DEBOUNCE",
    "STOP_TUNING",
    "EYE_H_DELAY",
    "EYE_W_DELAY"

};

/* array containing descriptive names for each of the SerDesDfe events */
fm_text fm10000SerDesDfeEventsMap[FM10000_SERDES_DFE_EVENT_MAX] =
{
    "START_TUNING_REQ",
    "STOP_TUNING_REQ",
    "PAUSE_TUNING_REQ",
    "RESUME_TUNING_REQ",
    "START_PCAL_REQ",
    "TUNING_STOPPED_IND",
    "TIMEOUT_IND",
    "RESET_MACHINE_REQ"

};

/*****************************************************************************
 * Local Variables
 *****************************************************************************/



static const fm_smTable fm10000BasicSmTable[] = {
    { FN(TG(0))                              , ST(STOP_TUNING), EV(TIMEOUT_IND)      , ST(START)            },
    { FN(TG(1))                              , ST(START)      , EV(START_PCAL_REQ)   , ST(WAIT_PCAL)        },
    { FN(TG(2))                              , ST(DEBOUNCE)   , EV(TIMEOUT_IND)      , ST(EYE_H_DELAY)      },
    { FN(TG(3))                              , ST(EYE_W_DELAY), EV(TIMEOUT_IND)      , ST(EYE_H_DELAY)      },
    { FN(TG(4))                              , ST(WAIT_ICAL)  , EV(STOP_TUNING_REQ)  , ST(STOP_TUNING)      },
    { FN(TG(4))                              , ST(WAIT_PCAL)  , EV(STOP_TUNING_REQ)  , ST(STOP_TUNING)      },
    { FN(TG(4))                              , ST(DEBOUNCE)   , EV(STOP_TUNING_REQ)  , ST(STOP_TUNING)      },
    { FN(TG(4))                              , ST(EYE_H_DELAY), EV(STOP_TUNING_REQ)  , ST(STOP_TUNING)      },
    { FN(TG(4))                              , ST(EYE_W_DELAY), EV(STOP_TUNING_REQ)  , ST(STOP_TUNING)      },
    { FN(TG(5))                              , ST(EYE_H_DELAY), EV(TIMEOUT_IND)      , ST(EYE_W_DELAY)      },
    { FN(TG(6))                              , ST(EYE_H_DELAY), EV(RESUME_TUNING_REQ), ST(EYE_H_DELAY)      },
    { FN(TG(6))                              , ST(EYE_W_DELAY), EV(RESUME_TUNING_REQ), ST(EYE_W_DELAY)      },
    { FN(TG(7))                              , ST(WAIT_PCAL)  , EV(PAUSE_TUNING_REQ) , ST(WAIT_PCAL)        },
    { FN(TG(7))                              , ST(DEBOUNCE)   , EV(PAUSE_TUNING_REQ) , ST(DEBOUNCE)         },
    { FN(TG(8))                              , ST(EYE_H_DELAY), EV(PAUSE_TUNING_REQ) , ST(EYE_H_DELAY)      },
    { FN(TG(9))                              , ST(START)      , EV(STOP_TUNING_REQ)  , ST(START)            },
    { FN(TG(9))                              , ST(STOP_TUNING), EV(STOP_TUNING_REQ)  , ST(STOP_TUNING)      },
    { FN(TG(10))                             , ST(EYE_W_DELAY), EV(PAUSE_TUNING_REQ) , ST(EYE_W_DELAY)      },
    { FN(SerDesDfeProcessPushAutoStartTuning), ST(START)      , EV(TIMEOUT_IND)      , FM_STATE_UNSPECIFIED },
    { FN(SerDesDfeProcessICalTimeout)        , ST(WAIT_ICAL)  , EV(TIMEOUT_IND)      , FM_STATE_UNSPECIFIED },
    { NULL                                   , ST(WAIT_ICAL)  , EV(RESET_MACHINE_REQ), ST(START)            },
    { FN(SerDesDfeProcessPCalTimeout)        , ST(WAIT_PCAL)  , EV(TIMEOUT_IND)      , FM_STATE_UNSPECIFIED },
    { NULL                                   , ST(WAIT_PCAL)  , EV(RESET_MACHINE_REQ), ST(START)            },
    { NULL                                   , ST(DEBOUNCE)   , EV(RESET_MACHINE_REQ), ST(START)            },
    { NULL                                   , ST(STOP_TUNING), EV(RESET_MACHINE_REQ), ST(START)            },
    { NULL                                   , ST(EYE_H_DELAY), EV(RESET_MACHINE_REQ), ST(START)            },
    { NULL                                   , ST(EYE_W_DELAY), EV(RESET_MACHINE_REQ), ST(START)            },
    { FN(TG(11))                             , ST(START)      , EV(START_TUNING_REQ) , ST(WAIT_ICAL)        }
};



/*****************************************************************************
 * Local Functions
 *****************************************************************************/

/*****************************************************************************/
/* SerDesDfeFlagError
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDfeFlagError( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the serdes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing FlagError\n", 
                     fm10000SerDesDfeEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDfeFlagError( eventInfo, userInfo );

    return status;

}   /* end SerDesDfeFlagError */


/*****************************************************************************/
/* SerDesDfeConfigDfe
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDfeConfigDfe( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the serdes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ConfigDfe\n", 
                     fm10000SerDesDfeEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDfeConfigDfe( eventInfo, userInfo );

    return status;

}   /* end SerDesDfeConfigDfe */


/*****************************************************************************/
/* SerDesDfeStartTuning
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDfeStartTuning( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the serdes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing StartTuning\n", 
                     fm10000SerDesDfeEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDfeStartTuning( eventInfo, userInfo );

    return status;

}   /* end SerDesDfeStartTuning */


/*****************************************************************************/
/* SerDesDfePauseTuning
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDfePauseTuning( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the serdes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing PauseTuning\n", 
                     fm10000SerDesDfeEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDfePauseTuning( eventInfo, userInfo );

    return status;

}   /* end SerDesDfePauseTuning */


/*****************************************************************************/
/* SerDesDfeResumeTuning
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDfeResumeTuning( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the serdes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ResumeTuning\n", 
                     fm10000SerDesDfeEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDfeResumeTuning( eventInfo, userInfo );

    return status;

}   /* end SerDesDfeResumeTuning */


/*****************************************************************************/
/* SerDesDfeStartKrPCalTuning
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDfeStartKrPCalTuning( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the serdes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing StartKrPCalTuning\n", 
                     fm10000SerDesDfeEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDfeStartKrPCalTuning( eventInfo, userInfo );

    return status;

}   /* end SerDesDfeStartKrPCalTuning */


/*****************************************************************************/
/* SerDesDfeStartTimeoutTimerShrt
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDfeStartTimeoutTimerShrt( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the serdes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing StartTimeoutTimerShrt\n", 
                     fm10000SerDesDfeEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDfeStartTimeoutTimerShrt( eventInfo, userInfo );

    return status;

}   /* end SerDesDfeStartTimeoutTimerShrt */


/*****************************************************************************/
/* SerDesDfeStartTimeoutTimerStopTuning
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDfeStartTimeoutTimerStopTuning( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the serdes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing StartTimeoutTimerStopTuning\n", 
                     fm10000SerDesDfeEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDfeStartTimeoutTimerStopTuning( eventInfo, userInfo );

    return status;

}   /* end SerDesDfeStartTimeoutTimerStopTuning */


/*****************************************************************************/
/* SerDesDfeStartTimeoutTimerDebounce
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDfeStartTimeoutTimerDebounce( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the serdes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing StartTimeoutTimerDebounce\n", 
                     fm10000SerDesDfeEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDfeStartTimeoutTimerDebounce( eventInfo, userInfo );

    return status;

}   /* end SerDesDfeStartTimeoutTimerDebounce */


/*****************************************************************************/
/* SerDesDfeStartTimeoutTimerAdaptive
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDfeStartTimeoutTimerAdaptive( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the serdes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing StartTimeoutTimerAdaptive\n", 
                     fm10000SerDesDfeEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDfeStartTimeoutTimerAdaptive( eventInfo, userInfo );

    return status;

}   /* end SerDesDfeStartTimeoutTimerAdaptive */


/*****************************************************************************/
/* SerDesDfeStopTimeoutTimer
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDfeStopTimeoutTimer( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the serdes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing StopTimeoutTimer\n", 
                     fm10000SerDesDfeEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDfeStopTimeoutTimer( eventInfo, userInfo );

    return status;

}   /* end SerDesDfeStopTimeoutTimer */


/*****************************************************************************/
/* SerDesDfeLoadRetryCntr
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDfeLoadRetryCntr( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the serdes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing LoadRetryCntr\n", 
                     fm10000SerDesDfeEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDfeLoadRetryCntr( eventInfo, userInfo );

    return status;

}   /* end SerDesDfeLoadRetryCntr */


/*****************************************************************************/
/* SerDesDfeClrCycleCntr
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDfeClrCycleCntr( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the serdes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ClrCycleCntr\n", 
                     fm10000SerDesDfeEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDfeClrCycleCntr( eventInfo, userInfo );

    return status;

}   /* end SerDesDfeClrCycleCntr */


/*****************************************************************************/
/* SerDesDfeClrRetryCntr
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDfeClrRetryCntr( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the serdes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ClrRetryCntr\n", 
                     fm10000SerDesDfeEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDfeClrRetryCntr( eventInfo, userInfo );

    return status;

}   /* end SerDesDfeClrRetryCntr */


/*****************************************************************************/
/* SerDesDfeIncCycleCntr
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDfeIncCycleCntr( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the serdes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing IncCycleCntr\n", 
                     fm10000SerDesDfeEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDfeIncCycleCntr( eventInfo, userInfo );

    return status;

}   /* end SerDesDfeIncCycleCntr */


/*****************************************************************************/
/* SerDesDfeStopTuning
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDfeStopTuning( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the serdes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing StopTuning\n", 
                     fm10000SerDesDfeEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDfeStopTuning( eventInfo, userInfo );

    return status;

}   /* end SerDesDfeStopTuning */


/*****************************************************************************/
/* SerDesDfeSendTuningStartedInd
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDfeSendTuningStartedInd( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the serdes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing SendTuningStartedInd\n", 
                     fm10000SerDesDfeEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDfeSendTuningStartedInd( eventInfo, userInfo );

    return status;

}   /* end SerDesDfeSendTuningStartedInd */


/*****************************************************************************/
/* SerDesDfeSendTuningStoppedInd
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDfeSendTuningStoppedInd( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the serdes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing SendTuningStoppedInd\n", 
                     fm10000SerDesDfeEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDfeSendTuningStoppedInd( eventInfo, userInfo );

    return status;

}   /* end SerDesDfeSendTuningStoppedInd */


/*****************************************************************************/
/* SerDesDfeSendTuningCompleteInd
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDfeSendTuningCompleteInd( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the serdes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing SendTuningCompleteInd\n", 
                     fm10000SerDesDfeEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDfeSendTuningCompleteInd( eventInfo, userInfo );

    return status;

}   /* end SerDesDfeSendTuningCompleteInd */


/*****************************************************************************/
/* SerDesDfeSendICalTuningCompleteInd
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDfeSendICalTuningCompleteInd( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the serdes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing SendICalTuningCompleteInd\n", 
                     fm10000SerDesDfeEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDfeSendICalTuningCompleteInd( eventInfo, userInfo );

    return status;

}   /* end SerDesDfeSendICalTuningCompleteInd */


/*****************************************************************************/
/* SerDesDfeReadEyeW
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDfeReadEyeW( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the serdes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ReadEyeW\n", 
                     fm10000SerDesDfeEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDfeReadEyeW( eventInfo, userInfo );

    return status;

}   /* end SerDesDfeReadEyeW */


/*****************************************************************************/
/* SerDesDfeReadEyeH
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDfeReadEyeH( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the serdes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ReadEyeH\n", 
                     fm10000SerDesDfeEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDfeReadEyeH( eventInfo, userInfo );

    return status;

}   /* end SerDesDfeReadEyeH */


/*****************************************************************************/
/* SerDesDfeConfigureEyeW
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDfeConfigureEyeW( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the serdes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ConfigureEyeW\n", 
                     fm10000SerDesDfeEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDfeConfigureEyeW( eventInfo, userInfo );

    return status;

}   /* end SerDesDfeConfigureEyeW */


/*****************************************************************************/
/* SerDesDfeConfigureEyeH
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDfeConfigureEyeH( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the serdes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ConfigureEyeH\n", 
                     fm10000SerDesDfeEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDfeConfigureEyeH( eventInfo, userInfo );

    return status;

}   /* end SerDesDfeConfigureEyeH */


/*****************************************************************************/
/* SerDesDfeDontSaveRecord
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDfeDontSaveRecord( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the serdes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing DontSaveRecord\n", 
                     fm10000SerDesDfeEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDfeDontSaveRecord( eventInfo, userInfo );

    return status;

}   /* end SerDesDfeDontSaveRecord */


/*****************************************************************************/
/* SerDesDfeRestartStopTuningTimer
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDfeRestartStopTuningTimer( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the serdes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing RestartStopTuningTimer\n", 
                     fm10000SerDesDfeEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDfeRestartStopTuningTimer( eventInfo, userInfo );

    return status;

}   /* end SerDesDfeRestartStopTuningTimer */


/*****************************************************************************/
/* SerDesDfeProcessPCalTimeout
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDfeProcessPCalTimeout( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the serdes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ProcessPCalTimeout\n", 
                     fm10000SerDesDfeEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDfeProcessPCalTimeout( eventInfo, userInfo, nextState );

    return status;

}   /* end SerDesDfeProcessPCalTimeout */


/*****************************************************************************/
/* SerDesDfeProcessPushAutoStartTuning
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDfeProcessPushAutoStartTuning( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the serdes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ProcessPushAutoStartTuning\n", 
                     fm10000SerDesDfeEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDfeProcessPushAutoStartTuning( eventInfo, userInfo, nextState );

    return status;

}   /* end SerDesDfeProcessPushAutoStartTuning */


/*****************************************************************************/
/* SerDesDfeProcessICalTimeout
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status SerDesDfeProcessICalTimeout( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int    serDes;

    /* this log message can be modified once the serdes-specific event
       info structure will be defined */
    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    FM_LOG_DEBUG_V2( FM_LOG_CAT_SERDES,
                     serDes,
                     "Event %s occurred on serDes %d, executing ProcessICalTimeout\n", 
                     fm10000SerDesDfeEventsMap[eventInfo->eventId],
                     serDes );

    status = fm10000SerDesDfeProcessICalTimeout( eventInfo, userInfo, nextState );

    return status;

}   /* end SerDesDfeProcessICalTimeout */





/******************************************************************************
 * Definitions of transition group callbacks 
 *****************************************************************************/


/*****************************************************************************/
/* TransitionGroup0
 *
 * \desc            Transition callback for serdes state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(0)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesDfeRestartStopTuningTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup0 */


/*****************************************************************************/
/* TransitionGroup1
 *
 * \desc            Transition callback for serdes state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(1)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesDfeClrCycleCntr( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDfeStartKrPCalTuning( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDfeStartTimeoutTimerShrt( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup1 */


/*****************************************************************************/
/* TransitionGroup2
 *
 * \desc            Transition callback for serdes state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(2)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesDfeReadEyeH( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDfeClrCycleCntr( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDfeStartTimeoutTimerAdaptive( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDfeSendTuningCompleteInd( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup2 */


/*****************************************************************************/
/* TransitionGroup3
 *
 * \desc            Transition callback for serdes state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(3)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesDfeReadEyeW( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDfeConfigureEyeH( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDfeStartTimeoutTimerAdaptive( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDfeIncCycleCntr( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDfeDontSaveRecord( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup3 */


/*****************************************************************************/
/* TransitionGroup4
 *
 * \desc            Transition callback for serdes state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(4)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesDfeClrRetryCntr( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDfeStopTuning( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDfeStartTimeoutTimerStopTuning( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup4 */


/*****************************************************************************/
/* TransitionGroup5
 *
 * \desc            Transition callback for serdes state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(5)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesDfeReadEyeH( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDfeConfigureEyeW( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDfeStartTimeoutTimerAdaptive( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDfeIncCycleCntr( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDfeDontSaveRecord( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDfeSendTuningCompleteInd( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup5 */


/*****************************************************************************/
/* TransitionGroup6
 *
 * \desc            Transition callback for serdes state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(6)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesDfeResumeTuning( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDfeClrCycleCntr( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDfeStartTimeoutTimerAdaptive( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup6 */


/*****************************************************************************/
/* TransitionGroup7
 *
 * \desc            Transition callback for serdes state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(7)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesDfeFlagError( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup7 */


/*****************************************************************************/
/* TransitionGroup8
 *
 * \desc            Transition callback for serdes state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(8)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesDfePauseTuning( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDfeStopTimeoutTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup8 */


/*****************************************************************************/
/* TransitionGroup9
 *
 * \desc            Transition callback for serdes state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(9)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesDfeClrRetryCntr( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup9 */


/*****************************************************************************/
/* TransitionGroup10
 *
 * \desc            Transition callback for serdes state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(10)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesDfeStopTimeoutTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDfePauseTuning( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup10 */


/*****************************************************************************/
/* TransitionGroup11
 *
 * \desc            Transition callback for serdes state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(11)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int    serDes = ((fm10000_serDesSmEventInfo *)userInfo)->laneExt->serDes;
    
    status = SerDesDfeStopTimeoutTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDfeConfigDfe( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDfeClrCycleCntr( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDfeLoadRetryCntr( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDfeStartTuning( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );
    
    status = SerDesDfeStartTimeoutTimerShrt( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_SERDES, serDes, status );

ABORT:
    return status;

}   /* end TransitionGroup11 */


/*****************************************************************************
 * Public Functions
 *****************************************************************************/


/*****************************************************************************/
/* fm10000RegisterBasicSerDesDfeStateMachine
 *
 * \desc            This function registers with the Generic State Machine
 *                  Engine state machine type ''FM10000_BASIC_SERDES_DFE_STATE_MACHINE''.
 * 
 * \return          FM_OK if the state machine was created successfully.
 * 
 * \return          FM_ERR_INVALID_ARGUMENT if one of the arguments is invalid.
 *
 * \return          FM_ERR_NO_MEM if there was a memory allocation failure
 *                  while creating one of the state machine internal structures.
 * 
 * \return          FM_ERR_STATE_MACHINE_TYPE if this state machine type is
 *                  already registered.
 *
 *****************************************************************************/
fm_status fm10000RegisterBasicSerDesDfeStateMachine( void )
{
    fm_uint     i;
    fm_status   status;
    fm_smTransitionEntry  stt[FM10000_SERDES_DFE_STATE_MAX][FM10000_SERDES_DFE_EVENT_MAX];
    fm_smTransitionEntry *dynstt[FM10000_SERDES_DFE_STATE_MAX];
    fm_smTransitionLogCallback logCallback;

    
    /* log callback for this type */
    logCallback = fm10000LogSerDesDfeTransition;
    

    /* clear out the temporary state transition table */
    FM_MEMSET_S( stt, sizeof(stt), 0, sizeof(stt));

    for (i = 0 ; 
         i < (sizeof(fm10000BasicSmTable) / sizeof(fm_smTable)); 
         i++)
    {
        stt[fm10000BasicSmTable[i].current]
           [fm10000BasicSmTable[i].event].used = TRUE;

        stt[fm10000BasicSmTable[i].current]
           [fm10000BasicSmTable[i].event].nextState = 
               fm10000BasicSmTable[i].next;

        if (fm10000BasicSmTable[i].next == FM_STATE_UNSPECIFIED)
        {
            stt[fm10000BasicSmTable[i].current]
               [fm10000BasicSmTable[i].event].conditionCallback = 
                   (fm_smConditionCallback) fm10000BasicSmTable[i].callback;

            stt[fm10000BasicSmTable[i].current]
               [fm10000BasicSmTable[i].event].transitionCallback = NULL;
        }
        else
        {
            stt[fm10000BasicSmTable[i].current]
               [fm10000BasicSmTable[i].event].conditionCallback = NULL;

            stt[fm10000BasicSmTable[i].current]
               [fm10000BasicSmTable[i].event].transitionCallback = 
                   (fm_smTransitionCallback) fm10000BasicSmTable[i].callback;
        }
    }
 
    /* fill out the state transition table for this state machine type */
    for (i = 0 ; i < FM10000_SERDES_DFE_STATE_MAX ; i++)
    {
        dynstt[i] = &stt[i][0];
    }

    /* register this state machine type */
    status = fmRegisterStateTransitionTable( FM10000_BASIC_SERDES_DFE_STATE_MACHINE,
                                             FM10000_SERDES_DFE_STATE_MAX,
                                             FM10000_SERDES_DFE_EVENT_MAX,
                                             dynstt,
                                             logCallback,
                                             TRUE ); 
    return status;

}   /* end fm10000RegisterBasicSerDesDfeStateMachine */


