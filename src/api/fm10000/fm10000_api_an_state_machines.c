/* vim:ts=4:sw=4:expandtab
 * (No tabs, indent level is 4 spaces) */
/*****************************************************************************
 * File:            fm10000_api_an_state_machines.c
 * Creation Date:   April 4th, 2013
 * Description:     Source file for the auto-negotiation state machines
 * 
 *                  ------------------------------------------------------
 *                  THIS FILE IS AUTO-GENERATED BY THE BUILD SYSTEM. DO
 *                  NOT MODIFY THIS FILE. MODIFY THE FOLLOWING INSTEAD:
 * 
 *                  1) fm10000_api_an_state_machines.xml
 *                  2) templates/fm10000_api_an_state_machines.c
 *                  ------------------------------------------------------
 *
 * Copyright (c) 2007 - 2015, Intel Corporation
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Intel Corporation nor the names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

#include <fm_sdk_fm10000_int.h>

/*****************************************************************************
 * Macros, Constants & Types
 *****************************************************************************/

#define ST(s) FM10000_AN_STATE_ ## s
#define EV(e) FM10000_AN_EVENT_ ## e
#define TG(g) TransitionGroup ## g
#define FN(n) (genericFunction) n

typedef void (*genericFunction)(void);

/****************************************************************/
/** \ingroup intAnStateMachine 
 * Definition of the State Machine Transition Table values.
 ****************************************************************/
typedef struct _fm_smTable
{
    /* callback for transition or condition */
    genericFunction         callback;
    
    /** current state identifier */
    fm_int                  current;

    /** event identifier */
    fm_int                  event;

    /** next state identifier */
    fm_int                  next;

} fm_smTable;


/*****************************************************************************
 * Local function prototypes
 *****************************************************************************/

/* declaration of all action callbacks */
static fm_status TakeRegLock( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status DropRegLock( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status EnableAn( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status DisableAn( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status EnableAnInterrupts( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status DisableAnInterrupts( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status ConfigureBasePage( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status ConfigureNextPages( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status NotifyApiAutonegCompleteOrFault( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status NotifyApiAutonegFailed( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status NotifyApiAutonegStarted( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status ConfigureAnTimers( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status NotifyPortAutonegComplete( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status NotifyPortAutonegRestarted( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status DoAbilityMatch( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status StartAnPollingTimer( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status StartAnQuickPollingTimer( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status StopAnPollingTimer( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status PerformAnPortStatusValidation( fm_smEventInfo *eventInfo, void *userInfo );



/* declaration of all condition callbacks */
static fm_status Dummy( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );



/* declaration of transition group callbacks */
static fm_status TG(0)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(1)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(2)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(3)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(4)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(5)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(6)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(7)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(8)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(9)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(10)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(11)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(12)( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status TG(13)( fm_smEventInfo *eventInfo, void *userInfo );



/*****************************************************************************
 * Global Variables
 *****************************************************************************/

/* array containing descriptive names for each of the AN states */
fm_text fm10000AnStatesMap[FM10000_AN_STATE_MAX] =
{
    "AN_STATE_DISABLED",
    "AN_STATE_ENABLED",
    "AN_STATE_RESTART",
    "AN_STATE_DISABLE_LINK_OK",
    "AN_STATE_ABILITY_DETECT",
    "AN_STATE_ACK_DETECT",
    "AN_STATE_COMPLETE_ACK",
    "AN_STATE_IDLE_DETECT",
    "AN_STATE_NEXT_PAGE_WAIT",
    "AN_STATE_TRANSMIT_DISABLE",
    "AN_STATE_GOOD_CHECK",
    "AN_STATE_GOOD",
    "AN_STATE_LINK_OK"

};

/* array containing descriptive names for each of the AN events */
fm_text fm10000AnEventsMap[FM10000_AN_EVENT_MAX] =
{
    "AN_EVENT_START_REQ",
    "AN_EVENT_STOP_REQ",
    "AN_EVENT_ENABLE_IND",
    "AN_EVENT_RESTART_IND",
    "AN_EVENT_DISABLE_LINK_OK_IND",
    "AN_EVENT_ABILITY_DETECT_IND",
    "AN_EVENT_ACK_DETECT_IND",
    "AN_EVENT_COMPLETE_ACK_IND",
    "AN_EVENT_NEXT_PAGE_WAIT_IND",
    "AN_EVENT_IDLE_DETECT_IND",
    "AN_EVENT_LINK_OK_IND",
    "AN_EVENT_TRANSMIT_DISABLE_IND",
    "AN_EVENT_GOOD_CHECK_IND",
    "AN_EVENT_GOOD_IND",
    "AN_EVENT_POLLING_TIMER_EXP_IND"

};

/*****************************************************************************
 * Local Variables
 *****************************************************************************/


static const fm_smTable fm10000Clause73SmTable[] = {
    { FN(TG(7)) , ST(ABILITY_DETECT)  , EV(TRANSMIT_DISABLE_IND) , ST(TRANSMIT_DISABLE) },
    { FN(TG(7)) , ST(ACK_DETECT)      , EV(TRANSMIT_DISABLE_IND) , ST(TRANSMIT_DISABLE) },
    { FN(TG(7)) , ST(COMPLETE_ACK)    , EV(TRANSMIT_DISABLE_IND) , ST(TRANSMIT_DISABLE) },
    { FN(TG(7)) , ST(NEXT_PAGE_WAIT)  , EV(TRANSMIT_DISABLE_IND) , ST(TRANSMIT_DISABLE) },
    { FN(TG(7)) , ST(GOOD_CHECK)      , EV(TRANSMIT_DISABLE_IND) , ST(TRANSMIT_DISABLE) },
    { FN(TG(8)) , ST(COMPLETE_ACK)    , EV(GOOD_CHECK_IND)       , ST(GOOD_CHECK)       },
    { FN(TG(8)) , ST(NEXT_PAGE_WAIT)  , EV(GOOD_CHECK_IND)       , ST(GOOD_CHECK)       },
    { FN(TG(9)) , ST(GOOD)            , EV(POLLING_TIMER_EXP_IND), ST(GOOD)             },
    { FN(TG(10)), ST(GOOD_CHECK)      , EV(GOOD_IND)             , ST(GOOD)             },
    { FN(TG(1)) , ST(TRANSMIT_DISABLE), EV(COMPLETE_ACK_IND)     , ST(COMPLETE_ACK)     },
    { FN(TG(1)) , ST(ABILITY_DETECT)  , EV(COMPLETE_ACK_IND)     , ST(COMPLETE_ACK)     },
    { FN(TG(1)) , ST(ACK_DETECT)      , EV(COMPLETE_ACK_IND)     , ST(COMPLETE_ACK)     },
    { FN(TG(1)) , ST(NEXT_PAGE_WAIT)  , EV(COMPLETE_ACK_IND)     , ST(COMPLETE_ACK)     },
    { FN(TG(2)) , ST(ENABLED)         , EV(STOP_REQ)             , ST(DISABLED)         },
    { FN(TG(2)) , ST(TRANSMIT_DISABLE), EV(STOP_REQ)             , ST(DISABLED)         },
    { FN(TG(2)) , ST(ABILITY_DETECT)  , EV(STOP_REQ)             , ST(DISABLED)         },
    { FN(TG(2)) , ST(ACK_DETECT)      , EV(STOP_REQ)             , ST(DISABLED)         },
    { FN(TG(2)) , ST(COMPLETE_ACK)    , EV(STOP_REQ)             , ST(DISABLED)         },
    { FN(TG(2)) , ST(NEXT_PAGE_WAIT)  , EV(STOP_REQ)             , ST(DISABLED)         },
    { FN(TG(2)) , ST(GOOD_CHECK)      , EV(STOP_REQ)             , ST(DISABLED)         },
    { FN(TG(3)) , ST(ENABLED)         , EV(START_REQ)            , ST(ENABLED)          },
    { FN(TG(3)) , ST(TRANSMIT_DISABLE), EV(START_REQ)            , ST(ENABLED)          },
    { FN(TG(3)) , ST(ABILITY_DETECT)  , EV(START_REQ)            , ST(ENABLED)          },
    { FN(TG(3)) , ST(ACK_DETECT)      , EV(START_REQ)            , ST(ENABLED)          },
    { FN(TG(3)) , ST(COMPLETE_ACK)    , EV(START_REQ)            , ST(ENABLED)          },
    { FN(TG(3)) , ST(NEXT_PAGE_WAIT)  , EV(START_REQ)            , ST(ENABLED)          },
    { FN(TG(3)) , ST(GOOD_CHECK)      , EV(START_REQ)            , ST(ENABLED)          },
    { FN(TG(3)) , ST(GOOD)            , EV(START_REQ)            , ST(ENABLED)          },
    { FN(TG(11)), ST(ENABLED)         , EV(TRANSMIT_DISABLE_IND) , ST(TRANSMIT_DISABLE) },
    { FN(TG(4)) , ST(DISABLED)        , EV(START_REQ)            , ST(ENABLED)          },
    { FN(TG(12)), ST(GOOD)            , EV(STOP_REQ)             , ST(DISABLED)         },
    { FN(TG(13)), ST(GOOD)            , EV(TRANSMIT_DISABLE_IND) , ST(DISABLED)         },
    { NULL      , ST(TRANSMIT_DISABLE), EV(ABILITY_DETECT_IND)   , ST(ABILITY_DETECT)   },
    { NULL      , ST(TRANSMIT_DISABLE), EV(ACK_DETECT_IND)       , ST(ACK_DETECT)       },
    { NULL      , ST(ABILITY_DETECT)  , EV(ACK_DETECT_IND)       , ST(ACK_DETECT)       },
    { NULL      , ST(COMPLETE_ACK)    , EV(ACK_DETECT_IND)       , ST(ACK_DETECT)       },
    { NULL      , ST(COMPLETE_ACK)    , EV(NEXT_PAGE_WAIT_IND)   , ST(NEXT_PAGE_WAIT)   },
    { NULL      , ST(NEXT_PAGE_WAIT)  , EV(ACK_DETECT_IND)       , ST(ACK_DETECT)       }
};

static const fm_smTable fm10000Clause37SmTable[] = {
    { NULL     , ST(ENABLED)        , EV(DISABLE_LINK_OK_IND), ST(DISABLE_LINK_OK) },
    { NULL     , ST(RESTART)        , EV(DISABLE_LINK_OK_IND), ST(DISABLE_LINK_OK) },
    { NULL     , ST(RESTART)        , EV(ABILITY_DETECT_IND) , ST(ABILITY_DETECT)  },
    { NULL     , ST(RESTART)        , EV(ACK_DETECT_IND)     , ST(ACK_DETECT)      },
    { NULL     , ST(ABILITY_DETECT) , EV(DISABLE_LINK_OK_IND), ST(DISABLE_LINK_OK) },
    { NULL     , ST(ABILITY_DETECT) , EV(ACK_DETECT_IND)     , ST(ACK_DETECT)      },
    { NULL     , ST(ACK_DETECT)     , EV(DISABLE_LINK_OK_IND), ST(DISABLE_LINK_OK) },
    { NULL     , ST(COMPLETE_ACK)   , EV(DISABLE_LINK_OK_IND), ST(DISABLE_LINK_OK) },
    { NULL     , ST(COMPLETE_ACK)   , EV(ACK_DETECT_IND)     , ST(ACK_DETECT)      },
    { NULL     , ST(COMPLETE_ACK)   , EV(NEXT_PAGE_WAIT_IND) , ST(NEXT_PAGE_WAIT)  },
    { NULL     , ST(COMPLETE_ACK)   , EV(IDLE_DETECT_IND)    , ST(IDLE_DETECT)     },
    { NULL     , ST(NEXT_PAGE_WAIT) , EV(DISABLE_LINK_OK_IND), ST(DISABLE_LINK_OK) },
    { NULL     , ST(NEXT_PAGE_WAIT) , EV(ACK_DETECT_IND)     , ST(ACK_DETECT)      },
    { NULL     , ST(LINK_OK)        , EV(DISABLE_LINK_OK_IND), ST(DISABLE_LINK_OK) },
    { FN(TG(0)), ST(COMPLETE_ACK)   , EV(LINK_OK_IND)        , ST(LINK_OK)         },
    { FN(TG(0)), ST(IDLE_DETECT)    , EV(LINK_OK_IND)        , ST(LINK_OK)         },
    { FN(TG(1)), ST(RESTART)        , EV(COMPLETE_ACK_IND)   , ST(COMPLETE_ACK)    },
    { FN(TG(1)), ST(ABILITY_DETECT) , EV(COMPLETE_ACK_IND)   , ST(COMPLETE_ACK)    },
    { FN(TG(1)), ST(ACK_DETECT)     , EV(COMPLETE_ACK_IND)   , ST(COMPLETE_ACK)    },
    { FN(TG(1)), ST(NEXT_PAGE_WAIT) , EV(COMPLETE_ACK_IND)   , ST(COMPLETE_ACK)    },
    { FN(TG(2)), ST(ENABLED)        , EV(STOP_REQ)           , ST(DISABLED)        },
    { FN(TG(2)), ST(RESTART)        , EV(STOP_REQ)           , ST(DISABLED)        },
    { FN(TG(2)), ST(DISABLE_LINK_OK), EV(STOP_REQ)           , ST(DISABLED)        },
    { FN(TG(2)), ST(ABILITY_DETECT) , EV(STOP_REQ)           , ST(DISABLED)        },
    { FN(TG(2)), ST(ACK_DETECT)     , EV(STOP_REQ)           , ST(DISABLED)        },
    { FN(TG(2)), ST(COMPLETE_ACK)   , EV(STOP_REQ)           , ST(DISABLED)        },
    { FN(TG(2)), ST(NEXT_PAGE_WAIT) , EV(STOP_REQ)           , ST(DISABLED)        },
    { FN(TG(2)), ST(IDLE_DETECT)    , EV(STOP_REQ)           , ST(DISABLED)        },
    { FN(TG(2)), ST(LINK_OK)        , EV(STOP_REQ)           , ST(DISABLED)        },
    { FN(TG(3)), ST(ENABLED)        , EV(START_REQ)          , ST(ENABLED)         },
    { FN(TG(3)), ST(RESTART)        , EV(START_REQ)          , ST(ENABLED)         },
    { FN(TG(3)), ST(DISABLE_LINK_OK), EV(START_REQ)          , ST(ENABLED)         },
    { FN(TG(3)), ST(ABILITY_DETECT) , EV(START_REQ)          , ST(ENABLED)         },
    { FN(TG(3)), ST(ACK_DETECT)     , EV(START_REQ)          , ST(ENABLED)         },
    { FN(TG(3)), ST(COMPLETE_ACK)   , EV(START_REQ)          , ST(ENABLED)         },
    { FN(TG(3)), ST(NEXT_PAGE_WAIT) , EV(START_REQ)          , ST(ENABLED)         },
    { FN(TG(3)), ST(IDLE_DETECT)    , EV(START_REQ)          , ST(ENABLED)         },
    { FN(TG(3)), ST(LINK_OK)        , EV(START_REQ)          , ST(ENABLED)         },
    { FN(TG(4)), ST(DISABLED)       , EV(START_REQ)          , ST(ENABLED)         },
    { FN(TG(5)), ST(ENABLED)        , EV(RESTART_IND)        , ST(RESTART)         },
    { FN(TG(6)), ST(RESTART)        , EV(RESTART_IND)        , ST(RESTART)         },
    { FN(TG(6)), ST(ABILITY_DETECT) , EV(RESTART_IND)        , ST(RESTART)         },
    { FN(TG(6)), ST(ACK_DETECT)     , EV(RESTART_IND)        , ST(RESTART)         },
    { FN(TG(6)), ST(COMPLETE_ACK)   , EV(RESTART_IND)        , ST(RESTART)         },
    { FN(TG(6)), ST(NEXT_PAGE_WAIT) , EV(RESTART_IND)        , ST(RESTART)         },
    { FN(TG(6)), ST(IDLE_DETECT)    , EV(RESTART_IND)        , ST(RESTART)         },
    { FN(TG(6)), ST(LINK_OK)        , EV(RESTART_IND)        , ST(RESTART)         }
};



/*****************************************************************************
 * Local Functions
 *****************************************************************************/

/*****************************************************************************/
/* TakeRegLock
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status TakeRegLock( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing TakeRegLock\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000TakeRegLock( eventInfo, userInfo );

    return status;

}   /* end TakeRegLock */


/*****************************************************************************/
/* DropRegLock
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status DropRegLock( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing DropRegLock\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000DropRegLock( eventInfo, userInfo );

    return status;

}   /* end DropRegLock */


/*****************************************************************************/
/* EnableAn
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status EnableAn( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing EnableAn\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000EnableAn( eventInfo, userInfo );

    return status;

}   /* end EnableAn */


/*****************************************************************************/
/* DisableAn
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status DisableAn( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing DisableAn\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000DisableAn( eventInfo, userInfo );

    return status;

}   /* end DisableAn */


/*****************************************************************************/
/* EnableAnInterrupts
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status EnableAnInterrupts( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing EnableAnInterrupts\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000EnableAnInterrupts( eventInfo, userInfo );

    return status;

}   /* end EnableAnInterrupts */


/*****************************************************************************/
/* DisableAnInterrupts
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status DisableAnInterrupts( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing DisableAnInterrupts\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000DisableAnInterrupts( eventInfo, userInfo );

    return status;

}   /* end DisableAnInterrupts */


/*****************************************************************************/
/* ConfigureBasePage
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status ConfigureBasePage( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing ConfigureBasePage\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ConfigureBasePage( eventInfo, userInfo );

    return status;

}   /* end ConfigureBasePage */


/*****************************************************************************/
/* ConfigureNextPages
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status ConfigureNextPages( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing ConfigureNextPages\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ConfigureNextPages( eventInfo, userInfo );

    return status;

}   /* end ConfigureNextPages */


/*****************************************************************************/
/* NotifyApiAutonegCompleteOrFault
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status NotifyApiAutonegCompleteOrFault( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing NotifyApiAutonegCompleteOrFault\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000NotifyApiAutonegCompleteOrFault( eventInfo, userInfo );

    return status;

}   /* end NotifyApiAutonegCompleteOrFault */


/*****************************************************************************/
/* NotifyApiAutonegFailed
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status NotifyApiAutonegFailed( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing NotifyApiAutonegFailed\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000NotifyApiAutonegFailed( eventInfo, userInfo );

    return status;

}   /* end NotifyApiAutonegFailed */


/*****************************************************************************/
/* NotifyApiAutonegStarted
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status NotifyApiAutonegStarted( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing NotifyApiAutonegStarted\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000NotifyApiAutonegStarted( eventInfo, userInfo );

    return status;

}   /* end NotifyApiAutonegStarted */


/*****************************************************************************/
/* ConfigureAnTimers
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status ConfigureAnTimers( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing ConfigureAnTimers\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ConfigureAnTimers( eventInfo, userInfo );

    return status;

}   /* end ConfigureAnTimers */


/*****************************************************************************/
/* NotifyPortAutonegComplete
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status NotifyPortAutonegComplete( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing NotifyPortAutonegComplete\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000NotifyPortAutonegComplete( eventInfo, userInfo );

    return status;

}   /* end NotifyPortAutonegComplete */


/*****************************************************************************/
/* NotifyPortAutonegRestarted
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status NotifyPortAutonegRestarted( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing NotifyPortAutonegRestarted\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000NotifyPortAutonegRestarted( eventInfo, userInfo );

    return status;

}   /* end NotifyPortAutonegRestarted */


/*****************************************************************************/
/* DoAbilityMatch
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status DoAbilityMatch( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing DoAbilityMatch\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000DoAbilityMatch( eventInfo, userInfo );

    return status;

}   /* end DoAbilityMatch */


/*****************************************************************************/
/* StartAnPollingTimer
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status StartAnPollingTimer( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing StartAnPollingTimer\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000StartAnPollingTimer( eventInfo, userInfo );

    return status;

}   /* end StartAnPollingTimer */


/*****************************************************************************/
/* StartAnQuickPollingTimer
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status StartAnQuickPollingTimer( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing StartAnQuickPollingTimer\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000StartAnQuickPollingTimer( eventInfo, userInfo );

    return status;

}   /* end StartAnQuickPollingTimer */


/*****************************************************************************/
/* StopAnPollingTimer
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status StopAnPollingTimer( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing StopAnPollingTimer\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000StopAnPollingTimer( eventInfo, userInfo );

    return status;

}   /* end StopAnPollingTimer */


/*****************************************************************************/
/* PerformAnPortStatusValidation
 *
 * \desc            One of the action callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status PerformAnPortStatusValidation( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing PerformAnPortStatusValidation\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000PerformAnPortStatusValidation( eventInfo, userInfo );

    return status;

}   /* end PerformAnPortStatusValidation */


/*****************************************************************************/
/* Dummy
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category.
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state.
 *
 * \return          Caller-provided return codes.
 * 
 *****************************************************************************/
static fm_status Dummy( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    /* this log message can be modified once the port-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing Dummy\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000Dummy( eventInfo, userInfo, nextState );

    return status;

}   /* end Dummy */




/******************************************************************************
 * Definitions of transition group callbacks 
 *****************************************************************************/



/*****************************************************************************/
/* TransitionGroup0
 *
 * \desc            Transition callback for AN state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(0)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
    
    status = NotifyApiAutonegCompleteOrFault( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = NotifyPortAutonegComplete( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );

ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end TransitionGroup0 */



/*****************************************************************************/
/* TransitionGroup1
 *
 * \desc            Transition callback for AN state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(1)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
    
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = ConfigureNextPages( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );

ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end TransitionGroup1 */



/*****************************************************************************/
/* TransitionGroup2
 *
 * \desc            Transition callback for AN state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(2)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
    
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );

ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end TransitionGroup2 */



/*****************************************************************************/
/* TransitionGroup3
 *
 * \desc            Transition callback for AN state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(3)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
    
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = EnableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = ConfigureAnTimers( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = EnableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );

ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end TransitionGroup3 */



/*****************************************************************************/
/* TransitionGroup4
 *
 * \desc            Transition callback for AN state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(4)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
    
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = EnableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = ConfigureAnTimers( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = EnableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );

ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end TransitionGroup4 */



/*****************************************************************************/
/* TransitionGroup5
 *
 * \desc            Transition callback for AN state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(5)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
    
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = NotifyPortAutonegRestarted( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = NotifyApiAutonegStarted( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );

ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end TransitionGroup5 */



/*****************************************************************************/
/* TransitionGroup6
 *
 * \desc            Transition callback for AN state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(6)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
    
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = NotifyPortAutonegRestarted( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = NotifyApiAutonegFailed( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );

ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end TransitionGroup6 */



/*****************************************************************************/
/* TransitionGroup7
 *
 * \desc            Transition callback for AN state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(7)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
    
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = ConfigureAnTimers( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = NotifyPortAutonegRestarted( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = NotifyApiAutonegFailed( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );

ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end TransitionGroup7 */



/*****************************************************************************/
/* TransitionGroup8
 *
 * \desc            Transition callback for AN state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(8)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
    
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = DoAbilityMatch( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = ConfigureAnTimers( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = NotifyPortAutonegComplete( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );

ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end TransitionGroup8 */



/*****************************************************************************/
/* TransitionGroup9
 *
 * \desc            Transition callback for AN state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(9)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
    
    status = StartAnPollingTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = PerformAnPortStatusValidation( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );

ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end TransitionGroup9 */



/*****************************************************************************/
/* TransitionGroup10
 *
 * \desc            Transition callback for AN state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(10)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
    
    status = StartAnQuickPollingTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = NotifyApiAutonegCompleteOrFault( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );

ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end TransitionGroup10 */



/*****************************************************************************/
/* TransitionGroup11
 *
 * \desc            Transition callback for AN state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(11)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
    
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = ConfigureAnTimers( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = NotifyPortAutonegRestarted( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = NotifyApiAutonegStarted( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );

ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end TransitionGroup11 */



/*****************************************************************************/
/* TransitionGroup12
 *
 * \desc            Transition callback for AN state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(12)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
    
    status = StopAnPollingTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );

ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end TransitionGroup12 */



/*****************************************************************************/
/* TransitionGroup13
 *
 * \desc            Transition callback for AN state machine.
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated area containing
 *                  purpose-specific event info.
 * 
 * \return          See return codes from the action callback functions.
 * 
 *****************************************************************************/
static fm_status TG(13)( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
    
    status = StopAnPollingTimer( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = ConfigureAnTimers( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = NotifyPortAutonegRestarted( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
    
    status = NotifyApiAutonegFailed( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );

ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end TransitionGroup13 */



/*****************************************************************************
 * Public Functions
 *****************************************************************************/


/*****************************************************************************/
/* fm10000RegisterClause73AnStateMachine
 *
 * \desc            This function registers with the Generic State Machine
 *                  Engine state machine type ''FM10000_CLAUSE73_AN_STATE_MACHINE''.
 * 
 * \return          FM_OK if the state machine was created successfully.
 * 
 * \return          FM_ERR_INVALID_ARGUMENT if one of the arguments is invalid.
 *
 * \return          FM_ERR_NO_MEM if there was a memory allocation failure
 *                  while creating one of the state machine internal structures.
 * 
 * \return          FM_ERR_STATE_MACHINE_TYPE if this state machine type is
 *                  already registered.
 *
 *****************************************************************************/
fm_status fm10000RegisterClause73AnStateMachine( void )
{
    fm_uint     i;
    fm_status   status;
    fm_smTransitionEntry  stt[FM10000_AN_STATE_MAX][FM10000_AN_EVENT_MAX];
    fm_smTransitionEntry *dynstt[FM10000_AN_STATE_MAX];
    fm_smTransitionLogCallback logCallback;

    
    /* log callback for this type */
    logCallback = fm10000LogAnStateTransition;
    

    /* clear out the temporary state transition table */
    FM_MEMSET_S( stt, sizeof(stt), 0, sizeof(stt));
 
    for (i = 0 ; 
         i < (sizeof(fm10000Clause73SmTable) / sizeof(fm_smTable)); 
         i++)
    {
        stt[fm10000Clause73SmTable[i].current]
           [fm10000Clause73SmTable[i].event].used = TRUE;

        stt[fm10000Clause73SmTable[i].current]
           [fm10000Clause73SmTable[i].event].nextState = 
               fm10000Clause73SmTable[i].next;

        if (fm10000Clause73SmTable[i].next == FM_STATE_UNSPECIFIED)
        {
            stt[fm10000Clause73SmTable[i].current]
               [fm10000Clause73SmTable[i].event].conditionCallback = 
                   (fm_smConditionCallback) fm10000Clause73SmTable[i].callback;

            stt[fm10000Clause73SmTable[i].current]
               [fm10000Clause73SmTable[i].event].transitionCallback = NULL;
        }
        else
        {
            stt[fm10000Clause73SmTable[i].current]
               [fm10000Clause73SmTable[i].event].conditionCallback = NULL;

            stt[fm10000Clause73SmTable[i].current]
               [fm10000Clause73SmTable[i].event].transitionCallback = 
                   (fm_smTransitionCallback) fm10000Clause73SmTable[i].callback;
        }

    }
    
    /* fill out the state transition table for this state machine type */
    for (i = 0 ; i < FM10000_AN_STATE_MAX ; i++)
    {
        dynstt[i] = &stt[i][0];
    }

    /* register this state machine type */
    status = fmRegisterStateTransitionTable( FM10000_CLAUSE73_AN_STATE_MACHINE,
                                             FM10000_AN_STATE_MAX,
                                             FM10000_AN_EVENT_MAX,
                                             dynstt,
                                             logCallback,
                                             TRUE ); 
    return status;

}   /* end fm10000RegisterClause73AnStateMachine */


/*****************************************************************************/
/* fm10000RegisterClause37AnStateMachine
 *
 * \desc            This function registers with the Generic State Machine
 *                  Engine state machine type ''FM10000_CLAUSE37_AN_STATE_MACHINE''.
 * 
 * \return          FM_OK if the state machine was created successfully.
 * 
 * \return          FM_ERR_INVALID_ARGUMENT if one of the arguments is invalid.
 *
 * \return          FM_ERR_NO_MEM if there was a memory allocation failure
 *                  while creating one of the state machine internal structures.
 * 
 * \return          FM_ERR_STATE_MACHINE_TYPE if this state machine type is
 *                  already registered.
 *
 *****************************************************************************/
fm_status fm10000RegisterClause37AnStateMachine( void )
{
    fm_uint     i;
    fm_status   status;
    fm_smTransitionEntry  stt[FM10000_AN_STATE_MAX][FM10000_AN_EVENT_MAX];
    fm_smTransitionEntry *dynstt[FM10000_AN_STATE_MAX];
    fm_smTransitionLogCallback logCallback;

    
    /* log callback for this type */
    logCallback = fm10000LogAnStateTransition;
    

    /* clear out the temporary state transition table */
    FM_MEMSET_S( stt, sizeof(stt), 0, sizeof(stt));
 
    for (i = 0 ; 
         i < (sizeof(fm10000Clause37SmTable) / sizeof(fm_smTable)); 
         i++)
    {
        stt[fm10000Clause37SmTable[i].current]
           [fm10000Clause37SmTable[i].event].used = TRUE;

        stt[fm10000Clause37SmTable[i].current]
           [fm10000Clause37SmTable[i].event].nextState = 
               fm10000Clause37SmTable[i].next;

        if (fm10000Clause37SmTable[i].next == FM_STATE_UNSPECIFIED)
        {
            stt[fm10000Clause37SmTable[i].current]
               [fm10000Clause37SmTable[i].event].conditionCallback = 
                   (fm_smConditionCallback) fm10000Clause37SmTable[i].callback;

            stt[fm10000Clause37SmTable[i].current]
               [fm10000Clause37SmTable[i].event].transitionCallback = NULL;
        }
        else
        {
            stt[fm10000Clause37SmTable[i].current]
               [fm10000Clause37SmTable[i].event].conditionCallback = NULL;

            stt[fm10000Clause37SmTable[i].current]
               [fm10000Clause37SmTable[i].event].transitionCallback = 
                   (fm_smTransitionCallback) fm10000Clause37SmTable[i].callback;
        }

    }
    
    /* fill out the state transition table for this state machine type */
    for (i = 0 ; i < FM10000_AN_STATE_MAX ; i++)
    {
        dynstt[i] = &stt[i][0];
    }

    /* register this state machine type */
    status = fmRegisterStateTransitionTable( FM10000_CLAUSE37_AN_STATE_MACHINE,
                                             FM10000_AN_STATE_MAX,
                                             FM10000_AN_EVENT_MAX,
                                             dynstt,
                                             logCallback,
                                             TRUE ); 
    return status;

}   /* end fm10000RegisterClause37AnStateMachine */



