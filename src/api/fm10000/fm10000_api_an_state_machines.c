/* vim:ts=4:sw=4:expandtab
 * (No tabs, indent level is 4 spaces) */
/*****************************************************************************
 * File:            fm10000_api_an_state_machines.c
 * Creation Date:   April 4th, 2013
 * Description:     Source file for the auto-negotiation state machines
 * 
 *                  ------------------------------------------------------
 *                  THIS FILE IS AUTO-GENERATED BY THE BUILD SYSTEM, DO
 *                  NOT MODIFY THIS FILE.  MODIFY THE FOLLOWING INSTEAD
 *                  ------------------------------------------------------
 * 
 *                  1) fm10000_api_an_state_machine.xml
 *                  2) templates/fm10000_api_an_state_machine.c
 *
 * Copyright (c) 2007 - 2015, Intel Corporation
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *     * Redistributions of source code must retain the above copyright notice,
 *       this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Intel Corporation nor the names of its contributors
 *       may be used to endorse or promote products derived from this software
 *       without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *****************************************************************************/

#include <fm_sdk_fm10000_int.h>


/*****************************************************************************
 * Macros, Constants & Types
 *****************************************************************************/

/*****************************************************************************
 * Local function prototypes
 *****************************************************************************/

/* declaration of all action callbacks */
static fm_status TakeRegLock( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status DropRegLock( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status EnableAn( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status DisableAn( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status EnableAnInterrupts( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status DisableAnInterrupts( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status ConfigureBasePage( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status ConfigureNextPages( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status NotifyApiAutonegCompleteOrFault( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status NotifyApiAutonegFailed( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status NotifyApiAutonegStarted( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status ConfigureAnTimers( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status NotifyPortAutonegComplete( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status NotifyPortAutonegRestarted( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status DoAbilityMatch( fm_smEventInfo *eventInfo, void *userInfo );



/* declaration of all condition callbacks */
static fm_status Dummy( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState );


/* Declarations of transition callbacks for FM10000_CLAUSE73_AN_STATE_MACHINE */
static fm_status Clause73StateMachineS0E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause73StateMachineS1E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause73StateMachineS1E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause73StateMachineS1E11Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause73StateMachineS9E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause73StateMachineS9E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause73StateMachineS9E7Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause73StateMachineS4E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause73StateMachineS4E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause73StateMachineS4E11Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause73StateMachineS4E7Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause73StateMachineS5E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause73StateMachineS5E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause73StateMachineS5E11Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause73StateMachineS5E7Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause73StateMachineS6E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause73StateMachineS6E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause73StateMachineS6E11Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause73StateMachineS6E12Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause73StateMachineS8E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause73StateMachineS8E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause73StateMachineS8E11Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause73StateMachineS8E7Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause73StateMachineS8E12Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause73StateMachineS10E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause73StateMachineS10E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause73StateMachineS10E11Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause73StateMachineS10E13Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause73StateMachineS11E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause73StateMachineS11E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause73StateMachineS11E11Callback( fm_smEventInfo *eventInfo, void *userInfo );

/* Declarations of transition callbacks for FM10000_CLAUSE37_AN_STATE_MACHINE */
static fm_status Clause37StateMachineS0E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause37StateMachineS1E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause37StateMachineS1E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause37StateMachineS1E3Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause37StateMachineS2E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause37StateMachineS2E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause37StateMachineS2E3Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause37StateMachineS2E7Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause37StateMachineS3E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause37StateMachineS3E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause37StateMachineS4E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause37StateMachineS4E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause37StateMachineS4E3Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause37StateMachineS4E7Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause37StateMachineS5E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause37StateMachineS5E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause37StateMachineS5E3Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause37StateMachineS5E7Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause37StateMachineS6E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause37StateMachineS6E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause37StateMachineS6E3Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause37StateMachineS6E10Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause37StateMachineS8E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause37StateMachineS8E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause37StateMachineS8E3Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause37StateMachineS8E7Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause37StateMachineS7E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause37StateMachineS7E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause37StateMachineS7E3Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause37StateMachineS7E10Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause37StateMachineS12E0Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause37StateMachineS12E1Callback( fm_smEventInfo *eventInfo, void *userInfo );
static fm_status Clause37StateMachineS12E3Callback( fm_smEventInfo *eventInfo, void *userInfo );


/*****************************************************************************
 * Global Variables
 *****************************************************************************/

/* array containing descriptive names for each of the AN states */
fm_text fm10000AnStatesMap[FM10000_AN_STATE_MAX] =
{
    "AN_STATE_DISABLED",
    "AN_STATE_ENABLED",
    "AN_STATE_RESTART",
    "AN_STATE_DISABLE_LINK_OK",
    "AN_STATE_ABILITY_DETECT",
    "AN_STATE_ACK_DETECT",
    "AN_STATE_COMPLETE_ACK",
    "AN_STATE_IDLE_DETECT",
    "AN_STATE_NEXT_PAGE_WAIT",
    "AN_STATE_TRANSMIT_DISABLE",
    "AN_STATE_GOOD_CHECK",
    "AN_STATE_GOOD",
    "AN_STATE_LINK_OK"

};

/* array containing descriptive names for each of the AN events */
fm_text fm10000AnEventsMap[FM10000_AN_EVENT_MAX] =
{
    "AN_EVENT_START_REQ",
    "AN_EVENT_STOP_REQ",
    "AN_EVENT_ENABLE_IND",
    "AN_EVENT_RESTART_IND",
    "AN_EVENT_DISABLE_LINK_OK_IND",
    "AN_EVENT_ABILITY_DETECT_IND",
    "AN_EVENT_ACK_DETECT_IND",
    "AN_EVENT_COMPLETE_ACK_IND",
    "AN_EVENT_NEXT_PAGE_WAIT_IND",
    "AN_EVENT_IDLE_DETECT_IND",
    "AN_EVENT_LINK_OK_IND",
    "AN_EVENT_TRANSMIT_DISABLE_IND",
    "AN_EVENT_GOOD_CHECK_IND",
    "AN_EVENT_GOOD_IND"

};

/*****************************************************************************
 * Local Variables
 *****************************************************************************/

/*****************************************************************************
 * Local Functions
 *****************************************************************************/

/*****************************************************************************/
/** TakeRegLock
 * ingroup intAnStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status TakeRegLock( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing TakeRegLock\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000TakeRegLock( eventInfo, userInfo );

    return status;

} /* end  TakeRegLock */


/*****************************************************************************/
/** DropRegLock
 * ingroup intAnStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status DropRegLock( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing DropRegLock\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000DropRegLock( eventInfo, userInfo );

    return status;

} /* end  DropRegLock */


/*****************************************************************************/
/** EnableAn
 * ingroup intAnStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status EnableAn( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing EnableAn\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000EnableAn( eventInfo, userInfo );

    return status;

} /* end  EnableAn */


/*****************************************************************************/
/** DisableAn
 * ingroup intAnStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status DisableAn( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing DisableAn\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000DisableAn( eventInfo, userInfo );

    return status;

} /* end  DisableAn */


/*****************************************************************************/
/** EnableAnInterrupts
 * ingroup intAnStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status EnableAnInterrupts( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing EnableAnInterrupts\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000EnableAnInterrupts( eventInfo, userInfo );

    return status;

} /* end  EnableAnInterrupts */


/*****************************************************************************/
/** DisableAnInterrupts
 * ingroup intAnStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status DisableAnInterrupts( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing DisableAnInterrupts\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000DisableAnInterrupts( eventInfo, userInfo );

    return status;

} /* end  DisableAnInterrupts */


/*****************************************************************************/
/** ConfigureBasePage
 * ingroup intAnStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status ConfigureBasePage( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing ConfigureBasePage\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ConfigureBasePage( eventInfo, userInfo );

    return status;

} /* end  ConfigureBasePage */


/*****************************************************************************/
/** ConfigureNextPages
 * ingroup intAnStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status ConfigureNextPages( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing ConfigureNextPages\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ConfigureNextPages( eventInfo, userInfo );

    return status;

} /* end  ConfigureNextPages */


/*****************************************************************************/
/** NotifyApiAutonegCompleteOrFault
 * ingroup intAnStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status NotifyApiAutonegCompleteOrFault( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing NotifyApiAutonegCompleteOrFault\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000NotifyApiAutonegCompleteOrFault( eventInfo, userInfo );

    return status;

} /* end  NotifyApiAutonegCompleteOrFault */


/*****************************************************************************/
/** NotifyApiAutonegFailed
 * ingroup intAnStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status NotifyApiAutonegFailed( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing NotifyApiAutonegFailed\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000NotifyApiAutonegFailed( eventInfo, userInfo );

    return status;

} /* end  NotifyApiAutonegFailed */


/*****************************************************************************/
/** NotifyApiAutonegStarted
 * ingroup intAnStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status NotifyApiAutonegStarted( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing NotifyApiAutonegStarted\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000NotifyApiAutonegStarted( eventInfo, userInfo );

    return status;

} /* end  NotifyApiAutonegStarted */


/*****************************************************************************/
/** ConfigureAnTimers
 * ingroup intAnStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status ConfigureAnTimers( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing ConfigureAnTimers\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000ConfigureAnTimers( eventInfo, userInfo );

    return status;

} /* end  ConfigureAnTimers */


/*****************************************************************************/
/** NotifyPortAutonegComplete
 * ingroup intAnStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status NotifyPortAutonegComplete( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing NotifyPortAutonegComplete\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000NotifyPortAutonegComplete( eventInfo, userInfo );

    return status;

} /* end  NotifyPortAutonegComplete */


/*****************************************************************************/
/** NotifyPortAutonegRestarted
 * ingroup intAnStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status NotifyPortAutonegRestarted( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing NotifyPortAutonegRestarted\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000NotifyPortAutonegRestarted( eventInfo, userInfo );

    return status;

} /* end  NotifyPortAutonegRestarted */


/*****************************************************************************/
/** DoAbilityMatch
 * ingroup intAnStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the action callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status DoAbilityMatch( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing DoAbilityMatch\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000DoAbilityMatch( eventInfo, userInfo );

    return status;

} /* end  DoAbilityMatch */


/*****************************************************************************/
/** Dummy
 * ingroup intAnStateMachine 
 *
 * \chips           FM10000
 *
 * \desc            One of the condition callbacks for this state machine
 *                  category
 *
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated containing
 *                  purpose-specific event info
 * 
 * \param[out]      nextState is the pointer to a caller-allocated area where
 *                  this function will return the next state
 *
 * \return          Caller-provided return codes. 
 *****************************************************************************/
static fm_status Dummy( fm_smEventInfo *eventInfo, void *userInfo, fm_int *nextState )
{
    fm_status status;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    /* this log message can be modified once the port-specific event
       info structure will be defined */
    FM_LOG_DEBUG_V2( FM_LOG_CAT_PORT_AUTONEG,
                     port,
                     "Event %s occurred on port %d, executing Dummy\n", 
                     fm10000AnEventsMap[eventInfo->eventId],
                     port );

    status = fm10000Dummy ( eventInfo, userInfo, nextState );

    return status;

} /* end  Dummy */




/******************************************************************************
 * Definitions of transition callbacks for FM10000_CLAUSE73_AN_STATE_MACHINE
 *****************************************************************************/

/*****************************************************************************/
/** Clause73StateMachineS0E0Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE73_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_START_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_DISABLED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause73StateMachineS0E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureAnTimers( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause73StateMachineS0E0Callback() */

/*****************************************************************************/
/** Clause73StateMachineS1E0Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE73_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_START_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_ENABLED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause73StateMachineS1E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureAnTimers( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause73StateMachineS1E0Callback() */

/*****************************************************************************/
/** Clause73StateMachineS1E1Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE73_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_STOP_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_ENABLED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause73StateMachineS1E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause73StateMachineS1E1Callback() */

/*****************************************************************************/
/** Clause73StateMachineS1E11Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE73_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_TRANSMIT_DISABLE_IND'' occurs in state
 *                  ''FM10000_AN_STATE_ENABLED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause73StateMachineS1E11Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureAnTimers( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = NotifyPortAutonegRestarted( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = NotifyApiAutonegStarted( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause73StateMachineS1E11Callback() */

/*****************************************************************************/
/** Clause73StateMachineS9E0Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE73_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_START_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_TRANSMIT_DISABLE
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause73StateMachineS9E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureAnTimers( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause73StateMachineS9E0Callback() */

/*****************************************************************************/
/** Clause73StateMachineS9E1Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE73_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_STOP_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_TRANSMIT_DISABLE
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause73StateMachineS9E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause73StateMachineS9E1Callback() */

/*****************************************************************************/
/** Clause73StateMachineS9E7Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE73_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_COMPLETE_ACK_IND'' occurs in state
 *                  ''FM10000_AN_STATE_TRANSMIT_DISABLE
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause73StateMachineS9E7Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureNextPages( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause73StateMachineS9E7Callback() */

/*****************************************************************************/
/** Clause73StateMachineS4E0Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE73_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_START_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_ABILITY_DETECT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause73StateMachineS4E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureAnTimers( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause73StateMachineS4E0Callback() */

/*****************************************************************************/
/** Clause73StateMachineS4E1Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE73_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_STOP_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_ABILITY_DETECT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause73StateMachineS4E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause73StateMachineS4E1Callback() */

/*****************************************************************************/
/** Clause73StateMachineS4E11Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE73_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_TRANSMIT_DISABLE_IND'' occurs in state
 *                  ''FM10000_AN_STATE_ABILITY_DETECT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause73StateMachineS4E11Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureAnTimers( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = NotifyPortAutonegRestarted( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = NotifyApiAutonegFailed( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause73StateMachineS4E11Callback() */

/*****************************************************************************/
/** Clause73StateMachineS4E7Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE73_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_COMPLETE_ACK_IND'' occurs in state
 *                  ''FM10000_AN_STATE_ABILITY_DETECT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause73StateMachineS4E7Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureNextPages( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause73StateMachineS4E7Callback() */

/*****************************************************************************/
/** Clause73StateMachineS5E0Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE73_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_START_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_ACK_DETECT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause73StateMachineS5E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureAnTimers( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause73StateMachineS5E0Callback() */

/*****************************************************************************/
/** Clause73StateMachineS5E1Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE73_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_STOP_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_ACK_DETECT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause73StateMachineS5E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause73StateMachineS5E1Callback() */

/*****************************************************************************/
/** Clause73StateMachineS5E11Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE73_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_TRANSMIT_DISABLE_IND'' occurs in state
 *                  ''FM10000_AN_STATE_ACK_DETECT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause73StateMachineS5E11Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureAnTimers( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = NotifyPortAutonegRestarted( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = NotifyApiAutonegFailed( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause73StateMachineS5E11Callback() */

/*****************************************************************************/
/** Clause73StateMachineS5E7Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE73_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_COMPLETE_ACK_IND'' occurs in state
 *                  ''FM10000_AN_STATE_ACK_DETECT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause73StateMachineS5E7Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureNextPages( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause73StateMachineS5E7Callback() */

/*****************************************************************************/
/** Clause73StateMachineS6E0Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE73_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_START_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_COMPLETE_ACK
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause73StateMachineS6E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureAnTimers( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause73StateMachineS6E0Callback() */

/*****************************************************************************/
/** Clause73StateMachineS6E1Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE73_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_STOP_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_COMPLETE_ACK
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause73StateMachineS6E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause73StateMachineS6E1Callback() */

/*****************************************************************************/
/** Clause73StateMachineS6E11Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE73_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_TRANSMIT_DISABLE_IND'' occurs in state
 *                  ''FM10000_AN_STATE_COMPLETE_ACK
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause73StateMachineS6E11Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureAnTimers( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = NotifyPortAutonegRestarted( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = NotifyApiAutonegFailed( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause73StateMachineS6E11Callback() */

/*****************************************************************************/
/** Clause73StateMachineS6E12Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE73_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_GOOD_CHECK_IND'' occurs in state
 *                  ''FM10000_AN_STATE_COMPLETE_ACK
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause73StateMachineS6E12Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DoAbilityMatch( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureAnTimers( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = NotifyPortAutonegComplete( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause73StateMachineS6E12Callback() */

/*****************************************************************************/
/** Clause73StateMachineS8E0Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE73_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_START_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_NEXT_PAGE_WAIT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause73StateMachineS8E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureAnTimers( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause73StateMachineS8E0Callback() */

/*****************************************************************************/
/** Clause73StateMachineS8E1Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE73_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_STOP_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_NEXT_PAGE_WAIT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause73StateMachineS8E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause73StateMachineS8E1Callback() */

/*****************************************************************************/
/** Clause73StateMachineS8E11Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE73_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_TRANSMIT_DISABLE_IND'' occurs in state
 *                  ''FM10000_AN_STATE_NEXT_PAGE_WAIT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause73StateMachineS8E11Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureAnTimers( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = NotifyPortAutonegRestarted( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = NotifyApiAutonegFailed( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause73StateMachineS8E11Callback() */

/*****************************************************************************/
/** Clause73StateMachineS8E7Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE73_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_COMPLETE_ACK_IND'' occurs in state
 *                  ''FM10000_AN_STATE_NEXT_PAGE_WAIT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause73StateMachineS8E7Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureNextPages( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause73StateMachineS8E7Callback() */

/*****************************************************************************/
/** Clause73StateMachineS8E12Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE73_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_GOOD_CHECK_IND'' occurs in state
 *                  ''FM10000_AN_STATE_NEXT_PAGE_WAIT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause73StateMachineS8E12Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DoAbilityMatch( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureAnTimers( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = NotifyPortAutonegComplete( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause73StateMachineS8E12Callback() */

/*****************************************************************************/
/** Clause73StateMachineS10E0Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE73_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_START_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_GOOD_CHECK
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause73StateMachineS10E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureAnTimers( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause73StateMachineS10E0Callback() */

/*****************************************************************************/
/** Clause73StateMachineS10E1Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE73_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_STOP_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_GOOD_CHECK
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause73StateMachineS10E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause73StateMachineS10E1Callback() */

/*****************************************************************************/
/** Clause73StateMachineS10E11Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE73_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_TRANSMIT_DISABLE_IND'' occurs in state
 *                  ''FM10000_AN_STATE_GOOD_CHECK
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause73StateMachineS10E11Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureAnTimers( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = NotifyPortAutonegRestarted( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = NotifyApiAutonegFailed( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause73StateMachineS10E11Callback() */

/*****************************************************************************/
/** Clause73StateMachineS10E13Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE73_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_GOOD_IND'' occurs in state
 *                  ''FM10000_AN_STATE_GOOD_CHECK
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause73StateMachineS10E13Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = NotifyApiAutonegCompleteOrFault( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause73StateMachineS10E13Callback() */

/*****************************************************************************/
/** Clause73StateMachineS11E0Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE73_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_START_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_GOOD
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause73StateMachineS11E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureAnTimers( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause73StateMachineS11E0Callback() */

/*****************************************************************************/
/** Clause73StateMachineS11E1Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE73_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_STOP_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_GOOD
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause73StateMachineS11E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause73StateMachineS11E1Callback() */

/*****************************************************************************/
/** Clause73StateMachineS11E11Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE73_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_TRANSMIT_DISABLE_IND'' occurs in state
 *                  ''FM10000_AN_STATE_GOOD
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause73StateMachineS11E11Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureAnTimers( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = NotifyPortAutonegRestarted( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = NotifyApiAutonegFailed( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause73StateMachineS11E11Callback() */

/******************************************************************************
 * Definitions of transition callbacks for FM10000_CLAUSE37_AN_STATE_MACHINE
 *****************************************************************************/

/*****************************************************************************/
/** Clause37StateMachineS0E0Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE37_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_START_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_DISABLED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause37StateMachineS0E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureAnTimers( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause37StateMachineS0E0Callback() */

/*****************************************************************************/
/** Clause37StateMachineS1E0Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE37_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_START_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_ENABLED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause37StateMachineS1E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureAnTimers( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause37StateMachineS1E0Callback() */

/*****************************************************************************/
/** Clause37StateMachineS1E1Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE37_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_STOP_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_ENABLED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause37StateMachineS1E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause37StateMachineS1E1Callback() */

/*****************************************************************************/
/** Clause37StateMachineS1E3Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE37_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_RESTART_IND'' occurs in state
 *                  ''FM10000_AN_STATE_ENABLED
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause37StateMachineS1E3Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = NotifyPortAutonegRestarted( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = NotifyApiAutonegStarted( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause37StateMachineS1E3Callback() */

/*****************************************************************************/
/** Clause37StateMachineS2E0Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE37_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_START_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_RESTART
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause37StateMachineS2E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureAnTimers( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause37StateMachineS2E0Callback() */

/*****************************************************************************/
/** Clause37StateMachineS2E1Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE37_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_STOP_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_RESTART
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause37StateMachineS2E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause37StateMachineS2E1Callback() */

/*****************************************************************************/
/** Clause37StateMachineS2E3Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE37_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_RESTART_IND'' occurs in state
 *                  ''FM10000_AN_STATE_RESTART
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause37StateMachineS2E3Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = NotifyPortAutonegRestarted( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = NotifyApiAutonegFailed( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause37StateMachineS2E3Callback() */

/*****************************************************************************/
/** Clause37StateMachineS2E7Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE37_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_COMPLETE_ACK_IND'' occurs in state
 *                  ''FM10000_AN_STATE_RESTART
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause37StateMachineS2E7Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureNextPages( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause37StateMachineS2E7Callback() */

/*****************************************************************************/
/** Clause37StateMachineS3E0Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE37_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_START_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_DISABLE_LINK_OK
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause37StateMachineS3E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureAnTimers( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause37StateMachineS3E0Callback() */

/*****************************************************************************/
/** Clause37StateMachineS3E1Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE37_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_STOP_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_DISABLE_LINK_OK
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause37StateMachineS3E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause37StateMachineS3E1Callback() */

/*****************************************************************************/
/** Clause37StateMachineS4E0Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE37_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_START_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_ABILITY_DETECT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause37StateMachineS4E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureAnTimers( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause37StateMachineS4E0Callback() */

/*****************************************************************************/
/** Clause37StateMachineS4E1Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE37_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_STOP_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_ABILITY_DETECT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause37StateMachineS4E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause37StateMachineS4E1Callback() */

/*****************************************************************************/
/** Clause37StateMachineS4E3Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE37_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_RESTART_IND'' occurs in state
 *                  ''FM10000_AN_STATE_ABILITY_DETECT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause37StateMachineS4E3Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = NotifyPortAutonegRestarted( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = NotifyApiAutonegFailed( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause37StateMachineS4E3Callback() */

/*****************************************************************************/
/** Clause37StateMachineS4E7Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE37_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_COMPLETE_ACK_IND'' occurs in state
 *                  ''FM10000_AN_STATE_ABILITY_DETECT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause37StateMachineS4E7Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureNextPages( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause37StateMachineS4E7Callback() */

/*****************************************************************************/
/** Clause37StateMachineS5E0Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE37_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_START_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_ACK_DETECT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause37StateMachineS5E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureAnTimers( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause37StateMachineS5E0Callback() */

/*****************************************************************************/
/** Clause37StateMachineS5E1Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE37_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_STOP_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_ACK_DETECT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause37StateMachineS5E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause37StateMachineS5E1Callback() */

/*****************************************************************************/
/** Clause37StateMachineS5E3Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE37_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_RESTART_IND'' occurs in state
 *                  ''FM10000_AN_STATE_ACK_DETECT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause37StateMachineS5E3Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = NotifyPortAutonegRestarted( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = NotifyApiAutonegFailed( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause37StateMachineS5E3Callback() */

/*****************************************************************************/
/** Clause37StateMachineS5E7Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE37_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_COMPLETE_ACK_IND'' occurs in state
 *                  ''FM10000_AN_STATE_ACK_DETECT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause37StateMachineS5E7Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureNextPages( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause37StateMachineS5E7Callback() */

/*****************************************************************************/
/** Clause37StateMachineS6E0Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE37_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_START_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_COMPLETE_ACK
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause37StateMachineS6E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureAnTimers( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause37StateMachineS6E0Callback() */

/*****************************************************************************/
/** Clause37StateMachineS6E1Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE37_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_STOP_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_COMPLETE_ACK
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause37StateMachineS6E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause37StateMachineS6E1Callback() */

/*****************************************************************************/
/** Clause37StateMachineS6E3Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE37_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_RESTART_IND'' occurs in state
 *                  ''FM10000_AN_STATE_COMPLETE_ACK
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause37StateMachineS6E3Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = NotifyPortAutonegRestarted( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = NotifyApiAutonegFailed( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause37StateMachineS6E3Callback() */

/*****************************************************************************/
/** Clause37StateMachineS6E10Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE37_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_LINK_OK_IND'' occurs in state
 *                  ''FM10000_AN_STATE_COMPLETE_ACK
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause37StateMachineS6E10Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = NotifyApiAutonegCompleteOrFault( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = NotifyPortAutonegComplete( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause37StateMachineS6E10Callback() */

/*****************************************************************************/
/** Clause37StateMachineS8E0Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE37_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_START_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_NEXT_PAGE_WAIT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause37StateMachineS8E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureAnTimers( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause37StateMachineS8E0Callback() */

/*****************************************************************************/
/** Clause37StateMachineS8E1Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE37_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_STOP_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_NEXT_PAGE_WAIT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause37StateMachineS8E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause37StateMachineS8E1Callback() */

/*****************************************************************************/
/** Clause37StateMachineS8E3Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE37_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_RESTART_IND'' occurs in state
 *                  ''FM10000_AN_STATE_NEXT_PAGE_WAIT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause37StateMachineS8E3Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = NotifyPortAutonegRestarted( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = NotifyApiAutonegFailed( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause37StateMachineS8E3Callback() */

/*****************************************************************************/
/** Clause37StateMachineS8E7Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE37_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_COMPLETE_ACK_IND'' occurs in state
 *                  ''FM10000_AN_STATE_NEXT_PAGE_WAIT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause37StateMachineS8E7Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureNextPages( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause37StateMachineS8E7Callback() */

/*****************************************************************************/
/** Clause37StateMachineS7E0Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE37_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_START_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_IDLE_DETECT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause37StateMachineS7E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureAnTimers( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause37StateMachineS7E0Callback() */

/*****************************************************************************/
/** Clause37StateMachineS7E1Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE37_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_STOP_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_IDLE_DETECT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause37StateMachineS7E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause37StateMachineS7E1Callback() */

/*****************************************************************************/
/** Clause37StateMachineS7E3Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE37_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_RESTART_IND'' occurs in state
 *                  ''FM10000_AN_STATE_IDLE_DETECT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause37StateMachineS7E3Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = NotifyPortAutonegRestarted( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = NotifyApiAutonegFailed( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause37StateMachineS7E3Callback() */

/*****************************************************************************/
/** Clause37StateMachineS7E10Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE37_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_LINK_OK_IND'' occurs in state
 *                  ''FM10000_AN_STATE_IDLE_DETECT
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause37StateMachineS7E10Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = NotifyApiAutonegCompleteOrFault( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = NotifyPortAutonegComplete( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause37StateMachineS7E10Callback() */

/*****************************************************************************/
/** Clause37StateMachineS12E0Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE37_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_START_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_LINK_OK
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause37StateMachineS12E0Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureAnTimers( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = EnableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause37StateMachineS12E0Callback() */

/*****************************************************************************/
/** Clause37StateMachineS12E1Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE37_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_STOP_REQ'' occurs in state
 *                  ''FM10000_AN_STATE_LINK_OK
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause37StateMachineS12E1Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAnInterrupts( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DisableAn( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause37StateMachineS12E1Callback() */

/*****************************************************************************/
/** Clause37StateMachineS12E3Callback
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            Transition callback for AN state machine type
 *                  ''FM10000_CLAUSE37_AN_STATE_MACHINE'', when event
 *                  ''FM10000_AN_EVENT_RESTART_IND'' occurs in state
 *                  ''FM10000_AN_STATE_LINK_OK
 * 
 * \param[in]       eventInfo is a pointer to a caller-allocated area
 *                  containing the generic event descriptor.
 * 
 * \param[in]       userInfo is a pointer to a caller-allocated are containing
 *                  purpose-specific event info
 * 
 * \return          See return codes from the action callback functions
 *****************************************************************************/
static fm_status Clause37StateMachineS12E3Callback( fm_smEventInfo *eventInfo, void *userInfo )
{
    fm_status status = FM_OK;
    fm_int port = ((fm10000_portSmEventInfo *)userInfo)->portPtr->portNumber;

    ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken = FALSE;
        
    status = TakeRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = ConfigureBasePage( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = DropRegLock( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = NotifyPortAutonegRestarted( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
    status = NotifyApiAutonegFailed( eventInfo, userInfo );
    FM_LOG_ABORT_ON_ERR_V2( FM_LOG_CAT_PORT_AUTONEG, port, status );
            
ABORT:
    if( ( ( fm10000_portSmEventInfo * )userInfo )->regLockTaken == TRUE )
    {
        DropRegLock( eventInfo, userInfo );
    }

    return status;

}   /* end Clause37StateMachineS12E3Callback() */


/*****************************************************************************
 * Public Functions
 *****************************************************************************/


/*****************************************************************************/
/** fm10000RegisterClause73AnStateMachine
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            This function registers with the Generic State Machine
 *                  Engine state machine type ''FM10000_CLAUSE73_AN_STATE_MACHINE''
 * 
 * \return          FM_OK if the state machine was created successfully
 * 
 * \return          FM_ERR_INVALID_ARGUMENT if one of the arguments is invalid
 *
 * \return          FM_ERR_NO_MEM if there was a memory allocation failure
 *                  while creating one of the state machine internal structures
 * 
 * \return          FM_ERR_STATE_MACHINE_TYPE if this state machine type is
 *                  already registered 
 *
 *****************************************************************************/
fm_status fm10000RegisterClause73AnStateMachine( void )
{
    fm_int      i;
    fm_status   status;
    fm_smTransitionEntry  stt[FM10000_AN_STATE_MAX][FM10000_AN_EVENT_MAX];
    fm_smTransitionEntry *dynstt[FM10000_AN_STATE_MAX];
    fm_smTransitionLogCallback logCallback;

    
    /* log callback for this type */
    logCallback = fm10000LogAnStateTransition;
    

    /* clear out the temporary state transition table */
    FM_MEMSET_S( stt, sizeof(stt), 0, sizeof(stt));

    /* transition for state=AN_STATE_DISABLED(0), event=AN_EVENT_START_REQ(0) */
    stt[FM10000_AN_STATE_DISABLED]
       [FM10000_AN_EVENT_START_REQ].used = TRUE;
    stt[FM10000_AN_STATE_DISABLED]
       [FM10000_AN_EVENT_START_REQ].nextState = FM10000_AN_STATE_ENABLED;
    stt[FM10000_AN_STATE_DISABLED]
       [FM10000_AN_EVENT_START_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_DISABLED]
       [FM10000_AN_EVENT_START_REQ].transitionCallback = Clause73StateMachineS0E0Callback;

    /* transition for state=AN_STATE_ENABLED(1), event=AN_EVENT_START_REQ(0) */
    stt[FM10000_AN_STATE_ENABLED]
       [FM10000_AN_EVENT_START_REQ].used = TRUE;
    stt[FM10000_AN_STATE_ENABLED]
       [FM10000_AN_EVENT_START_REQ].nextState = FM10000_AN_STATE_ENABLED;
    stt[FM10000_AN_STATE_ENABLED]
       [FM10000_AN_EVENT_START_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_ENABLED]
       [FM10000_AN_EVENT_START_REQ].transitionCallback = Clause73StateMachineS1E0Callback;

    /* transition for state=AN_STATE_ENABLED(1), event=AN_EVENT_STOP_REQ(1) */
    stt[FM10000_AN_STATE_ENABLED]
       [FM10000_AN_EVENT_STOP_REQ].used = TRUE;
    stt[FM10000_AN_STATE_ENABLED]
       [FM10000_AN_EVENT_STOP_REQ].nextState = FM10000_AN_STATE_DISABLED;
    stt[FM10000_AN_STATE_ENABLED]
       [FM10000_AN_EVENT_STOP_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_ENABLED]
       [FM10000_AN_EVENT_STOP_REQ].transitionCallback = Clause73StateMachineS1E1Callback;

    /* transition for state=AN_STATE_ENABLED(1), event=AN_EVENT_TRANSMIT_DISABLE_IND(11) */
    stt[FM10000_AN_STATE_ENABLED]
       [FM10000_AN_EVENT_TRANSMIT_DISABLE_IND].used = TRUE;
    stt[FM10000_AN_STATE_ENABLED]
       [FM10000_AN_EVENT_TRANSMIT_DISABLE_IND].nextState = FM10000_AN_STATE_TRANSMIT_DISABLE;
    stt[FM10000_AN_STATE_ENABLED]
       [FM10000_AN_EVENT_TRANSMIT_DISABLE_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_ENABLED]
       [FM10000_AN_EVENT_TRANSMIT_DISABLE_IND].transitionCallback = Clause73StateMachineS1E11Callback;

    /* transition for state=AN_STATE_TRANSMIT_DISABLE(9), event=AN_EVENT_START_REQ(0) */
    stt[FM10000_AN_STATE_TRANSMIT_DISABLE]
       [FM10000_AN_EVENT_START_REQ].used = TRUE;
    stt[FM10000_AN_STATE_TRANSMIT_DISABLE]
       [FM10000_AN_EVENT_START_REQ].nextState = FM10000_AN_STATE_ENABLED;
    stt[FM10000_AN_STATE_TRANSMIT_DISABLE]
       [FM10000_AN_EVENT_START_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_TRANSMIT_DISABLE]
       [FM10000_AN_EVENT_START_REQ].transitionCallback = Clause73StateMachineS9E0Callback;

    /* transition for state=AN_STATE_TRANSMIT_DISABLE(9), event=AN_EVENT_STOP_REQ(1) */
    stt[FM10000_AN_STATE_TRANSMIT_DISABLE]
       [FM10000_AN_EVENT_STOP_REQ].used = TRUE;
    stt[FM10000_AN_STATE_TRANSMIT_DISABLE]
       [FM10000_AN_EVENT_STOP_REQ].nextState = FM10000_AN_STATE_DISABLED;
    stt[FM10000_AN_STATE_TRANSMIT_DISABLE]
       [FM10000_AN_EVENT_STOP_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_TRANSMIT_DISABLE]
       [FM10000_AN_EVENT_STOP_REQ].transitionCallback = Clause73StateMachineS9E1Callback;

    /* transition for state=AN_STATE_TRANSMIT_DISABLE(9), event=AN_EVENT_ABILITY_DETECT_IND(5) */
    stt[FM10000_AN_STATE_TRANSMIT_DISABLE]
       [FM10000_AN_EVENT_ABILITY_DETECT_IND].used = TRUE;
    stt[FM10000_AN_STATE_TRANSMIT_DISABLE]
       [FM10000_AN_EVENT_ABILITY_DETECT_IND].nextState = FM10000_AN_STATE_ABILITY_DETECT;
    stt[FM10000_AN_STATE_TRANSMIT_DISABLE]
       [FM10000_AN_EVENT_ABILITY_DETECT_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_TRANSMIT_DISABLE]
       [FM10000_AN_EVENT_ABILITY_DETECT_IND].transitionCallback = NULL;

    /* transition for state=AN_STATE_TRANSMIT_DISABLE(9), event=AN_EVENT_ACK_DETECT_IND(6) */
    stt[FM10000_AN_STATE_TRANSMIT_DISABLE]
       [FM10000_AN_EVENT_ACK_DETECT_IND].used = TRUE;
    stt[FM10000_AN_STATE_TRANSMIT_DISABLE]
       [FM10000_AN_EVENT_ACK_DETECT_IND].nextState = FM10000_AN_STATE_ACK_DETECT;
    stt[FM10000_AN_STATE_TRANSMIT_DISABLE]
       [FM10000_AN_EVENT_ACK_DETECT_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_TRANSMIT_DISABLE]
       [FM10000_AN_EVENT_ACK_DETECT_IND].transitionCallback = NULL;

    /* transition for state=AN_STATE_TRANSMIT_DISABLE(9), event=AN_EVENT_COMPLETE_ACK_IND(7) */
    stt[FM10000_AN_STATE_TRANSMIT_DISABLE]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].used = TRUE;
    stt[FM10000_AN_STATE_TRANSMIT_DISABLE]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].nextState = FM10000_AN_STATE_COMPLETE_ACK;
    stt[FM10000_AN_STATE_TRANSMIT_DISABLE]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_TRANSMIT_DISABLE]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].transitionCallback = Clause73StateMachineS9E7Callback;

    /* transition for state=AN_STATE_ABILITY_DETECT(4), event=AN_EVENT_START_REQ(0) */
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_START_REQ].used = TRUE;
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_START_REQ].nextState = FM10000_AN_STATE_ENABLED;
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_START_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_START_REQ].transitionCallback = Clause73StateMachineS4E0Callback;

    /* transition for state=AN_STATE_ABILITY_DETECT(4), event=AN_EVENT_STOP_REQ(1) */
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_STOP_REQ].used = TRUE;
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_STOP_REQ].nextState = FM10000_AN_STATE_DISABLED;
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_STOP_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_STOP_REQ].transitionCallback = Clause73StateMachineS4E1Callback;

    /* transition for state=AN_STATE_ABILITY_DETECT(4), event=AN_EVENT_TRANSMIT_DISABLE_IND(11) */
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_TRANSMIT_DISABLE_IND].used = TRUE;
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_TRANSMIT_DISABLE_IND].nextState = FM10000_AN_STATE_TRANSMIT_DISABLE;
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_TRANSMIT_DISABLE_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_TRANSMIT_DISABLE_IND].transitionCallback = Clause73StateMachineS4E11Callback;

    /* transition for state=AN_STATE_ABILITY_DETECT(4), event=AN_EVENT_ACK_DETECT_IND(6) */
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_ACK_DETECT_IND].used = TRUE;
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_ACK_DETECT_IND].nextState = FM10000_AN_STATE_ACK_DETECT;
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_ACK_DETECT_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_ACK_DETECT_IND].transitionCallback = NULL;

    /* transition for state=AN_STATE_ABILITY_DETECT(4), event=AN_EVENT_COMPLETE_ACK_IND(7) */
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].used = TRUE;
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].nextState = FM10000_AN_STATE_COMPLETE_ACK;
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].transitionCallback = Clause73StateMachineS4E7Callback;

    /* transition for state=AN_STATE_ACK_DETECT(5), event=AN_EVENT_START_REQ(0) */
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_START_REQ].used = TRUE;
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_START_REQ].nextState = FM10000_AN_STATE_ENABLED;
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_START_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_START_REQ].transitionCallback = Clause73StateMachineS5E0Callback;

    /* transition for state=AN_STATE_ACK_DETECT(5), event=AN_EVENT_STOP_REQ(1) */
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_STOP_REQ].used = TRUE;
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_STOP_REQ].nextState = FM10000_AN_STATE_DISABLED;
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_STOP_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_STOP_REQ].transitionCallback = Clause73StateMachineS5E1Callback;

    /* transition for state=AN_STATE_ACK_DETECT(5), event=AN_EVENT_TRANSMIT_DISABLE_IND(11) */
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_TRANSMIT_DISABLE_IND].used = TRUE;
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_TRANSMIT_DISABLE_IND].nextState = FM10000_AN_STATE_TRANSMIT_DISABLE;
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_TRANSMIT_DISABLE_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_TRANSMIT_DISABLE_IND].transitionCallback = Clause73StateMachineS5E11Callback;

    /* transition for state=AN_STATE_ACK_DETECT(5), event=AN_EVENT_COMPLETE_ACK_IND(7) */
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].used = TRUE;
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].nextState = FM10000_AN_STATE_COMPLETE_ACK;
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].transitionCallback = Clause73StateMachineS5E7Callback;

    /* transition for state=AN_STATE_COMPLETE_ACK(6), event=AN_EVENT_START_REQ(0) */
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_START_REQ].used = TRUE;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_START_REQ].nextState = FM10000_AN_STATE_ENABLED;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_START_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_START_REQ].transitionCallback = Clause73StateMachineS6E0Callback;

    /* transition for state=AN_STATE_COMPLETE_ACK(6), event=AN_EVENT_STOP_REQ(1) */
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_STOP_REQ].used = TRUE;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_STOP_REQ].nextState = FM10000_AN_STATE_DISABLED;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_STOP_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_STOP_REQ].transitionCallback = Clause73StateMachineS6E1Callback;

    /* transition for state=AN_STATE_COMPLETE_ACK(6), event=AN_EVENT_TRANSMIT_DISABLE_IND(11) */
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_TRANSMIT_DISABLE_IND].used = TRUE;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_TRANSMIT_DISABLE_IND].nextState = FM10000_AN_STATE_TRANSMIT_DISABLE;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_TRANSMIT_DISABLE_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_TRANSMIT_DISABLE_IND].transitionCallback = Clause73StateMachineS6E11Callback;

    /* transition for state=AN_STATE_COMPLETE_ACK(6), event=AN_EVENT_ACK_DETECT_IND(6) */
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_ACK_DETECT_IND].used = TRUE;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_ACK_DETECT_IND].nextState = FM10000_AN_STATE_ACK_DETECT;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_ACK_DETECT_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_ACK_DETECT_IND].transitionCallback = NULL;

    /* transition for state=AN_STATE_COMPLETE_ACK(6), event=AN_EVENT_NEXT_PAGE_WAIT_IND(8) */
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_NEXT_PAGE_WAIT_IND].used = TRUE;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_NEXT_PAGE_WAIT_IND].nextState = FM10000_AN_STATE_NEXT_PAGE_WAIT;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_NEXT_PAGE_WAIT_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_NEXT_PAGE_WAIT_IND].transitionCallback = NULL;

    /* transition for state=AN_STATE_COMPLETE_ACK(6), event=AN_EVENT_GOOD_CHECK_IND(12) */
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_GOOD_CHECK_IND].used = TRUE;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_GOOD_CHECK_IND].nextState = FM10000_AN_STATE_GOOD_CHECK;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_GOOD_CHECK_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_GOOD_CHECK_IND].transitionCallback = Clause73StateMachineS6E12Callback;

    /* transition for state=AN_STATE_NEXT_PAGE_WAIT(8), event=AN_EVENT_START_REQ(0) */
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_START_REQ].used = TRUE;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_START_REQ].nextState = FM10000_AN_STATE_ENABLED;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_START_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_START_REQ].transitionCallback = Clause73StateMachineS8E0Callback;

    /* transition for state=AN_STATE_NEXT_PAGE_WAIT(8), event=AN_EVENT_STOP_REQ(1) */
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_STOP_REQ].used = TRUE;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_STOP_REQ].nextState = FM10000_AN_STATE_DISABLED;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_STOP_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_STOP_REQ].transitionCallback = Clause73StateMachineS8E1Callback;

    /* transition for state=AN_STATE_NEXT_PAGE_WAIT(8), event=AN_EVENT_TRANSMIT_DISABLE_IND(11) */
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_TRANSMIT_DISABLE_IND].used = TRUE;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_TRANSMIT_DISABLE_IND].nextState = FM10000_AN_STATE_TRANSMIT_DISABLE;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_TRANSMIT_DISABLE_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_TRANSMIT_DISABLE_IND].transitionCallback = Clause73StateMachineS8E11Callback;

    /* transition for state=AN_STATE_NEXT_PAGE_WAIT(8), event=AN_EVENT_ACK_DETECT_IND(6) */
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_ACK_DETECT_IND].used = TRUE;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_ACK_DETECT_IND].nextState = FM10000_AN_STATE_ACK_DETECT;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_ACK_DETECT_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_ACK_DETECT_IND].transitionCallback = NULL;

    /* transition for state=AN_STATE_NEXT_PAGE_WAIT(8), event=AN_EVENT_COMPLETE_ACK_IND(7) */
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].used = TRUE;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].nextState = FM10000_AN_STATE_COMPLETE_ACK;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].transitionCallback = Clause73StateMachineS8E7Callback;

    /* transition for state=AN_STATE_NEXT_PAGE_WAIT(8), event=AN_EVENT_GOOD_CHECK_IND(12) */
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_GOOD_CHECK_IND].used = TRUE;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_GOOD_CHECK_IND].nextState = FM10000_AN_STATE_GOOD_CHECK;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_GOOD_CHECK_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_GOOD_CHECK_IND].transitionCallback = Clause73StateMachineS8E12Callback;

    /* transition for state=AN_STATE_GOOD_CHECK(10), event=AN_EVENT_START_REQ(0) */
    stt[FM10000_AN_STATE_GOOD_CHECK]
       [FM10000_AN_EVENT_START_REQ].used = TRUE;
    stt[FM10000_AN_STATE_GOOD_CHECK]
       [FM10000_AN_EVENT_START_REQ].nextState = FM10000_AN_STATE_ENABLED;
    stt[FM10000_AN_STATE_GOOD_CHECK]
       [FM10000_AN_EVENT_START_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_GOOD_CHECK]
       [FM10000_AN_EVENT_START_REQ].transitionCallback = Clause73StateMachineS10E0Callback;

    /* transition for state=AN_STATE_GOOD_CHECK(10), event=AN_EVENT_STOP_REQ(1) */
    stt[FM10000_AN_STATE_GOOD_CHECK]
       [FM10000_AN_EVENT_STOP_REQ].used = TRUE;
    stt[FM10000_AN_STATE_GOOD_CHECK]
       [FM10000_AN_EVENT_STOP_REQ].nextState = FM10000_AN_STATE_DISABLED;
    stt[FM10000_AN_STATE_GOOD_CHECK]
       [FM10000_AN_EVENT_STOP_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_GOOD_CHECK]
       [FM10000_AN_EVENT_STOP_REQ].transitionCallback = Clause73StateMachineS10E1Callback;

    /* transition for state=AN_STATE_GOOD_CHECK(10), event=AN_EVENT_TRANSMIT_DISABLE_IND(11) */
    stt[FM10000_AN_STATE_GOOD_CHECK]
       [FM10000_AN_EVENT_TRANSMIT_DISABLE_IND].used = TRUE;
    stt[FM10000_AN_STATE_GOOD_CHECK]
       [FM10000_AN_EVENT_TRANSMIT_DISABLE_IND].nextState = FM10000_AN_STATE_TRANSMIT_DISABLE;
    stt[FM10000_AN_STATE_GOOD_CHECK]
       [FM10000_AN_EVENT_TRANSMIT_DISABLE_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_GOOD_CHECK]
       [FM10000_AN_EVENT_TRANSMIT_DISABLE_IND].transitionCallback = Clause73StateMachineS10E11Callback;

    /* transition for state=AN_STATE_GOOD_CHECK(10), event=AN_EVENT_GOOD_IND(13) */
    stt[FM10000_AN_STATE_GOOD_CHECK]
       [FM10000_AN_EVENT_GOOD_IND].used = TRUE;
    stt[FM10000_AN_STATE_GOOD_CHECK]
       [FM10000_AN_EVENT_GOOD_IND].nextState = FM10000_AN_STATE_GOOD;
    stt[FM10000_AN_STATE_GOOD_CHECK]
       [FM10000_AN_EVENT_GOOD_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_GOOD_CHECK]
       [FM10000_AN_EVENT_GOOD_IND].transitionCallback = Clause73StateMachineS10E13Callback;

    /* transition for state=AN_STATE_GOOD(11), event=AN_EVENT_START_REQ(0) */
    stt[FM10000_AN_STATE_GOOD]
       [FM10000_AN_EVENT_START_REQ].used = TRUE;
    stt[FM10000_AN_STATE_GOOD]
       [FM10000_AN_EVENT_START_REQ].nextState = FM10000_AN_STATE_ENABLED;
    stt[FM10000_AN_STATE_GOOD]
       [FM10000_AN_EVENT_START_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_GOOD]
       [FM10000_AN_EVENT_START_REQ].transitionCallback = Clause73StateMachineS11E0Callback;

    /* transition for state=AN_STATE_GOOD(11), event=AN_EVENT_STOP_REQ(1) */
    stt[FM10000_AN_STATE_GOOD]
       [FM10000_AN_EVENT_STOP_REQ].used = TRUE;
    stt[FM10000_AN_STATE_GOOD]
       [FM10000_AN_EVENT_STOP_REQ].nextState = FM10000_AN_STATE_DISABLED;
    stt[FM10000_AN_STATE_GOOD]
       [FM10000_AN_EVENT_STOP_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_GOOD]
       [FM10000_AN_EVENT_STOP_REQ].transitionCallback = Clause73StateMachineS11E1Callback;

    /* transition for state=AN_STATE_GOOD(11), event=AN_EVENT_TRANSMIT_DISABLE_IND(11) */
    stt[FM10000_AN_STATE_GOOD]
       [FM10000_AN_EVENT_TRANSMIT_DISABLE_IND].used = TRUE;
    stt[FM10000_AN_STATE_GOOD]
       [FM10000_AN_EVENT_TRANSMIT_DISABLE_IND].nextState = FM10000_AN_STATE_TRANSMIT_DISABLE;
    stt[FM10000_AN_STATE_GOOD]
       [FM10000_AN_EVENT_TRANSMIT_DISABLE_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_GOOD]
       [FM10000_AN_EVENT_TRANSMIT_DISABLE_IND].transitionCallback = Clause73StateMachineS11E11Callback;

    /* fill out the state transition table for this state machine type */
    for (i = 0 ; i < FM10000_AN_STATE_MAX  ; i++)
    {
        dynstt[i] = &stt[i][0];
    }

    /* register this state machine type */
    status = fmRegisterStateTransitionTable( FM10000_CLAUSE73_AN_STATE_MACHINE,
                                             FM10000_AN_STATE_MAX,
                                             FM10000_AN_EVENT_MAX,
                                             dynstt,
                                             logCallback,
                                             TRUE ); 
    return status;

}   /* end  fm10000RegisterClause73AnStateMachine */


/*****************************************************************************/
/** fm10000RegisterClause37AnStateMachine
 * \ingroup intAnStateMachine
 *
 * \chips           FM10000
 *
 * \desc            This function registers with the Generic State Machine
 *                  Engine state machine type ''FM10000_CLAUSE37_AN_STATE_MACHINE''
 * 
 * \return          FM_OK if the state machine was created successfully
 * 
 * \return          FM_ERR_INVALID_ARGUMENT if one of the arguments is invalid
 *
 * \return          FM_ERR_NO_MEM if there was a memory allocation failure
 *                  while creating one of the state machine internal structures
 * 
 * \return          FM_ERR_STATE_MACHINE_TYPE if this state machine type is
 *                  already registered 
 *
 *****************************************************************************/
fm_status fm10000RegisterClause37AnStateMachine( void )
{
    fm_int      i;
    fm_status   status;
    fm_smTransitionEntry  stt[FM10000_AN_STATE_MAX][FM10000_AN_EVENT_MAX];
    fm_smTransitionEntry *dynstt[FM10000_AN_STATE_MAX];
    fm_smTransitionLogCallback logCallback;

    
    /* log callback for this type */
    logCallback = fm10000LogAnStateTransition;
    

    /* clear out the temporary state transition table */
    FM_MEMSET_S( stt, sizeof(stt), 0, sizeof(stt));

    /* transition for state=AN_STATE_DISABLED(0), event=AN_EVENT_START_REQ(0) */
    stt[FM10000_AN_STATE_DISABLED]
       [FM10000_AN_EVENT_START_REQ].used = TRUE;
    stt[FM10000_AN_STATE_DISABLED]
       [FM10000_AN_EVENT_START_REQ].nextState = FM10000_AN_STATE_ENABLED;
    stt[FM10000_AN_STATE_DISABLED]
       [FM10000_AN_EVENT_START_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_DISABLED]
       [FM10000_AN_EVENT_START_REQ].transitionCallback = Clause37StateMachineS0E0Callback;

    /* transition for state=AN_STATE_ENABLED(1), event=AN_EVENT_START_REQ(0) */
    stt[FM10000_AN_STATE_ENABLED]
       [FM10000_AN_EVENT_START_REQ].used = TRUE;
    stt[FM10000_AN_STATE_ENABLED]
       [FM10000_AN_EVENT_START_REQ].nextState = FM10000_AN_STATE_ENABLED;
    stt[FM10000_AN_STATE_ENABLED]
       [FM10000_AN_EVENT_START_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_ENABLED]
       [FM10000_AN_EVENT_START_REQ].transitionCallback = Clause37StateMachineS1E0Callback;

    /* transition for state=AN_STATE_ENABLED(1), event=AN_EVENT_STOP_REQ(1) */
    stt[FM10000_AN_STATE_ENABLED]
       [FM10000_AN_EVENT_STOP_REQ].used = TRUE;
    stt[FM10000_AN_STATE_ENABLED]
       [FM10000_AN_EVENT_STOP_REQ].nextState = FM10000_AN_STATE_DISABLED;
    stt[FM10000_AN_STATE_ENABLED]
       [FM10000_AN_EVENT_STOP_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_ENABLED]
       [FM10000_AN_EVENT_STOP_REQ].transitionCallback = Clause37StateMachineS1E1Callback;

    /* transition for state=AN_STATE_ENABLED(1), event=AN_EVENT_RESTART_IND(3) */
    stt[FM10000_AN_STATE_ENABLED]
       [FM10000_AN_EVENT_RESTART_IND].used = TRUE;
    stt[FM10000_AN_STATE_ENABLED]
       [FM10000_AN_EVENT_RESTART_IND].nextState = FM10000_AN_STATE_RESTART;
    stt[FM10000_AN_STATE_ENABLED]
       [FM10000_AN_EVENT_RESTART_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_ENABLED]
       [FM10000_AN_EVENT_RESTART_IND].transitionCallback = Clause37StateMachineS1E3Callback;

    /* transition for state=AN_STATE_ENABLED(1), event=AN_EVENT_DISABLE_LINK_OK_IND(4) */
    stt[FM10000_AN_STATE_ENABLED]
       [FM10000_AN_EVENT_DISABLE_LINK_OK_IND].used = TRUE;
    stt[FM10000_AN_STATE_ENABLED]
       [FM10000_AN_EVENT_DISABLE_LINK_OK_IND].nextState = FM10000_AN_STATE_DISABLE_LINK_OK;
    stt[FM10000_AN_STATE_ENABLED]
       [FM10000_AN_EVENT_DISABLE_LINK_OK_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_ENABLED]
       [FM10000_AN_EVENT_DISABLE_LINK_OK_IND].transitionCallback = NULL;

    /* transition for state=AN_STATE_RESTART(2), event=AN_EVENT_START_REQ(0) */
    stt[FM10000_AN_STATE_RESTART]
       [FM10000_AN_EVENT_START_REQ].used = TRUE;
    stt[FM10000_AN_STATE_RESTART]
       [FM10000_AN_EVENT_START_REQ].nextState = FM10000_AN_STATE_ENABLED;
    stt[FM10000_AN_STATE_RESTART]
       [FM10000_AN_EVENT_START_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_RESTART]
       [FM10000_AN_EVENT_START_REQ].transitionCallback = Clause37StateMachineS2E0Callback;

    /* transition for state=AN_STATE_RESTART(2), event=AN_EVENT_STOP_REQ(1) */
    stt[FM10000_AN_STATE_RESTART]
       [FM10000_AN_EVENT_STOP_REQ].used = TRUE;
    stt[FM10000_AN_STATE_RESTART]
       [FM10000_AN_EVENT_STOP_REQ].nextState = FM10000_AN_STATE_DISABLED;
    stt[FM10000_AN_STATE_RESTART]
       [FM10000_AN_EVENT_STOP_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_RESTART]
       [FM10000_AN_EVENT_STOP_REQ].transitionCallback = Clause37StateMachineS2E1Callback;

    /* transition for state=AN_STATE_RESTART(2), event=AN_EVENT_RESTART_IND(3) */
    stt[FM10000_AN_STATE_RESTART]
       [FM10000_AN_EVENT_RESTART_IND].used = TRUE;
    stt[FM10000_AN_STATE_RESTART]
       [FM10000_AN_EVENT_RESTART_IND].nextState = FM10000_AN_STATE_RESTART;
    stt[FM10000_AN_STATE_RESTART]
       [FM10000_AN_EVENT_RESTART_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_RESTART]
       [FM10000_AN_EVENT_RESTART_IND].transitionCallback = Clause37StateMachineS2E3Callback;

    /* transition for state=AN_STATE_RESTART(2), event=AN_EVENT_DISABLE_LINK_OK_IND(4) */
    stt[FM10000_AN_STATE_RESTART]
       [FM10000_AN_EVENT_DISABLE_LINK_OK_IND].used = TRUE;
    stt[FM10000_AN_STATE_RESTART]
       [FM10000_AN_EVENT_DISABLE_LINK_OK_IND].nextState = FM10000_AN_STATE_DISABLE_LINK_OK;
    stt[FM10000_AN_STATE_RESTART]
       [FM10000_AN_EVENT_DISABLE_LINK_OK_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_RESTART]
       [FM10000_AN_EVENT_DISABLE_LINK_OK_IND].transitionCallback = NULL;

    /* transition for state=AN_STATE_RESTART(2), event=AN_EVENT_ABILITY_DETECT_IND(5) */
    stt[FM10000_AN_STATE_RESTART]
       [FM10000_AN_EVENT_ABILITY_DETECT_IND].used = TRUE;
    stt[FM10000_AN_STATE_RESTART]
       [FM10000_AN_EVENT_ABILITY_DETECT_IND].nextState = FM10000_AN_STATE_ABILITY_DETECT;
    stt[FM10000_AN_STATE_RESTART]
       [FM10000_AN_EVENT_ABILITY_DETECT_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_RESTART]
       [FM10000_AN_EVENT_ABILITY_DETECT_IND].transitionCallback = NULL;

    /* transition for state=AN_STATE_RESTART(2), event=AN_EVENT_ACK_DETECT_IND(6) */
    stt[FM10000_AN_STATE_RESTART]
       [FM10000_AN_EVENT_ACK_DETECT_IND].used = TRUE;
    stt[FM10000_AN_STATE_RESTART]
       [FM10000_AN_EVENT_ACK_DETECT_IND].nextState = FM10000_AN_STATE_ACK_DETECT;
    stt[FM10000_AN_STATE_RESTART]
       [FM10000_AN_EVENT_ACK_DETECT_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_RESTART]
       [FM10000_AN_EVENT_ACK_DETECT_IND].transitionCallback = NULL;

    /* transition for state=AN_STATE_RESTART(2), event=AN_EVENT_COMPLETE_ACK_IND(7) */
    stt[FM10000_AN_STATE_RESTART]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].used = TRUE;
    stt[FM10000_AN_STATE_RESTART]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].nextState = FM10000_AN_STATE_COMPLETE_ACK;
    stt[FM10000_AN_STATE_RESTART]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_RESTART]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].transitionCallback = Clause37StateMachineS2E7Callback;

    /* transition for state=AN_STATE_DISABLE_LINK_OK(3), event=AN_EVENT_START_REQ(0) */
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_START_REQ].used = TRUE;
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_START_REQ].nextState = FM10000_AN_STATE_ENABLED;
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_START_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_START_REQ].transitionCallback = Clause37StateMachineS3E0Callback;

    /* transition for state=AN_STATE_DISABLE_LINK_OK(3), event=AN_EVENT_STOP_REQ(1) */
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_STOP_REQ].used = TRUE;
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_STOP_REQ].nextState = FM10000_AN_STATE_DISABLED;
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_STOP_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_STOP_REQ].transitionCallback = Clause37StateMachineS3E1Callback;

    /* transition for state=AN_STATE_DISABLE_LINK_OK(3), event=AN_EVENT_RESTART_IND(3) */
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_RESTART_IND].used = TRUE;
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_RESTART_IND].nextState = FM10000_AN_STATE_DISABLE_LINK_OK;
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_RESTART_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_RESTART_IND].transitionCallback = NULL;

    /* transition for state=AN_STATE_DISABLE_LINK_OK(3), event=AN_EVENT_ABILITY_DETECT_IND(5) */
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_ABILITY_DETECT_IND].used = TRUE;
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_ABILITY_DETECT_IND].nextState = FM10000_AN_STATE_DISABLE_LINK_OK;
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_ABILITY_DETECT_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_ABILITY_DETECT_IND].transitionCallback = NULL;

    /* transition for state=AN_STATE_DISABLE_LINK_OK(3), event=AN_EVENT_ACK_DETECT_IND(6) */
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_ACK_DETECT_IND].used = TRUE;
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_ACK_DETECT_IND].nextState = FM10000_AN_STATE_DISABLE_LINK_OK;
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_ACK_DETECT_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_ACK_DETECT_IND].transitionCallback = NULL;

    /* transition for state=AN_STATE_DISABLE_LINK_OK(3), event=AN_EVENT_COMPLETE_ACK_IND(7) */
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].used = TRUE;
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].nextState = FM10000_AN_STATE_DISABLE_LINK_OK;
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].transitionCallback = NULL;

    /* transition for state=AN_STATE_DISABLE_LINK_OK(3), event=AN_EVENT_NEXT_PAGE_WAIT_IND(8) */
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_NEXT_PAGE_WAIT_IND].used = TRUE;
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_NEXT_PAGE_WAIT_IND].nextState = FM10000_AN_STATE_DISABLE_LINK_OK;
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_NEXT_PAGE_WAIT_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_NEXT_PAGE_WAIT_IND].transitionCallback = NULL;

    /* transition for state=AN_STATE_DISABLE_LINK_OK(3), event=AN_EVENT_IDLE_DETECT_IND(9) */
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_IDLE_DETECT_IND].used = TRUE;
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_IDLE_DETECT_IND].nextState = FM10000_AN_STATE_DISABLE_LINK_OK;
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_IDLE_DETECT_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_IDLE_DETECT_IND].transitionCallback = NULL;

    /* transition for state=AN_STATE_DISABLE_LINK_OK(3), event=AN_EVENT_LINK_OK_IND(10) */
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_LINK_OK_IND].used = TRUE;
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_LINK_OK_IND].nextState = FM10000_AN_STATE_DISABLE_LINK_OK;
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_LINK_OK_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_DISABLE_LINK_OK]
       [FM10000_AN_EVENT_LINK_OK_IND].transitionCallback = NULL;

    /* transition for state=AN_STATE_ABILITY_DETECT(4), event=AN_EVENT_START_REQ(0) */
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_START_REQ].used = TRUE;
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_START_REQ].nextState = FM10000_AN_STATE_ENABLED;
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_START_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_START_REQ].transitionCallback = Clause37StateMachineS4E0Callback;

    /* transition for state=AN_STATE_ABILITY_DETECT(4), event=AN_EVENT_STOP_REQ(1) */
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_STOP_REQ].used = TRUE;
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_STOP_REQ].nextState = FM10000_AN_STATE_DISABLED;
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_STOP_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_STOP_REQ].transitionCallback = Clause37StateMachineS4E1Callback;

    /* transition for state=AN_STATE_ABILITY_DETECT(4), event=AN_EVENT_RESTART_IND(3) */
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_RESTART_IND].used = TRUE;
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_RESTART_IND].nextState = FM10000_AN_STATE_RESTART;
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_RESTART_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_RESTART_IND].transitionCallback = Clause37StateMachineS4E3Callback;

    /* transition for state=AN_STATE_ABILITY_DETECT(4), event=AN_EVENT_DISABLE_LINK_OK_IND(4) */
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_DISABLE_LINK_OK_IND].used = TRUE;
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_DISABLE_LINK_OK_IND].nextState = FM10000_AN_STATE_DISABLE_LINK_OK;
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_DISABLE_LINK_OK_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_DISABLE_LINK_OK_IND].transitionCallback = NULL;

    /* transition for state=AN_STATE_ABILITY_DETECT(4), event=AN_EVENT_ACK_DETECT_IND(6) */
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_ACK_DETECT_IND].used = TRUE;
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_ACK_DETECT_IND].nextState = FM10000_AN_STATE_ACK_DETECT;
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_ACK_DETECT_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_ACK_DETECT_IND].transitionCallback = NULL;

    /* transition for state=AN_STATE_ABILITY_DETECT(4), event=AN_EVENT_COMPLETE_ACK_IND(7) */
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].used = TRUE;
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].nextState = FM10000_AN_STATE_COMPLETE_ACK;
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_ABILITY_DETECT]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].transitionCallback = Clause37StateMachineS4E7Callback;

    /* transition for state=AN_STATE_ACK_DETECT(5), event=AN_EVENT_START_REQ(0) */
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_START_REQ].used = TRUE;
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_START_REQ].nextState = FM10000_AN_STATE_ENABLED;
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_START_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_START_REQ].transitionCallback = Clause37StateMachineS5E0Callback;

    /* transition for state=AN_STATE_ACK_DETECT(5), event=AN_EVENT_STOP_REQ(1) */
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_STOP_REQ].used = TRUE;
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_STOP_REQ].nextState = FM10000_AN_STATE_DISABLED;
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_STOP_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_STOP_REQ].transitionCallback = Clause37StateMachineS5E1Callback;

    /* transition for state=AN_STATE_ACK_DETECT(5), event=AN_EVENT_RESTART_IND(3) */
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_RESTART_IND].used = TRUE;
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_RESTART_IND].nextState = FM10000_AN_STATE_RESTART;
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_RESTART_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_RESTART_IND].transitionCallback = Clause37StateMachineS5E3Callback;

    /* transition for state=AN_STATE_ACK_DETECT(5), event=AN_EVENT_DISABLE_LINK_OK_IND(4) */
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_DISABLE_LINK_OK_IND].used = TRUE;
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_DISABLE_LINK_OK_IND].nextState = FM10000_AN_STATE_DISABLE_LINK_OK;
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_DISABLE_LINK_OK_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_DISABLE_LINK_OK_IND].transitionCallback = NULL;

    /* transition for state=AN_STATE_ACK_DETECT(5), event=AN_EVENT_COMPLETE_ACK_IND(7) */
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].used = TRUE;
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].nextState = FM10000_AN_STATE_COMPLETE_ACK;
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_ACK_DETECT]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].transitionCallback = Clause37StateMachineS5E7Callback;

    /* transition for state=AN_STATE_COMPLETE_ACK(6), event=AN_EVENT_START_REQ(0) */
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_START_REQ].used = TRUE;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_START_REQ].nextState = FM10000_AN_STATE_ENABLED;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_START_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_START_REQ].transitionCallback = Clause37StateMachineS6E0Callback;

    /* transition for state=AN_STATE_COMPLETE_ACK(6), event=AN_EVENT_STOP_REQ(1) */
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_STOP_REQ].used = TRUE;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_STOP_REQ].nextState = FM10000_AN_STATE_DISABLED;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_STOP_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_STOP_REQ].transitionCallback = Clause37StateMachineS6E1Callback;

    /* transition for state=AN_STATE_COMPLETE_ACK(6), event=AN_EVENT_RESTART_IND(3) */
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_RESTART_IND].used = TRUE;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_RESTART_IND].nextState = FM10000_AN_STATE_RESTART;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_RESTART_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_RESTART_IND].transitionCallback = Clause37StateMachineS6E3Callback;

    /* transition for state=AN_STATE_COMPLETE_ACK(6), event=AN_EVENT_DISABLE_LINK_OK_IND(4) */
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_DISABLE_LINK_OK_IND].used = TRUE;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_DISABLE_LINK_OK_IND].nextState = FM10000_AN_STATE_DISABLE_LINK_OK;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_DISABLE_LINK_OK_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_DISABLE_LINK_OK_IND].transitionCallback = NULL;

    /* transition for state=AN_STATE_COMPLETE_ACK(6), event=AN_EVENT_ACK_DETECT_IND(6) */
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_ACK_DETECT_IND].used = TRUE;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_ACK_DETECT_IND].nextState = FM10000_AN_STATE_ACK_DETECT;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_ACK_DETECT_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_ACK_DETECT_IND].transitionCallback = NULL;

    /* transition for state=AN_STATE_COMPLETE_ACK(6), event=AN_EVENT_NEXT_PAGE_WAIT_IND(8) */
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_NEXT_PAGE_WAIT_IND].used = TRUE;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_NEXT_PAGE_WAIT_IND].nextState = FM10000_AN_STATE_NEXT_PAGE_WAIT;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_NEXT_PAGE_WAIT_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_NEXT_PAGE_WAIT_IND].transitionCallback = NULL;

    /* transition for state=AN_STATE_COMPLETE_ACK(6), event=AN_EVENT_IDLE_DETECT_IND(9) */
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_IDLE_DETECT_IND].used = TRUE;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_IDLE_DETECT_IND].nextState = FM10000_AN_STATE_IDLE_DETECT;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_IDLE_DETECT_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_IDLE_DETECT_IND].transitionCallback = NULL;

    /* transition for state=AN_STATE_COMPLETE_ACK(6), event=AN_EVENT_LINK_OK_IND(10) */
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_LINK_OK_IND].used = TRUE;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_LINK_OK_IND].nextState = FM10000_AN_STATE_LINK_OK;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_LINK_OK_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_COMPLETE_ACK]
       [FM10000_AN_EVENT_LINK_OK_IND].transitionCallback = Clause37StateMachineS6E10Callback;

    /* transition for state=AN_STATE_NEXT_PAGE_WAIT(8), event=AN_EVENT_START_REQ(0) */
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_START_REQ].used = TRUE;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_START_REQ].nextState = FM10000_AN_STATE_ENABLED;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_START_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_START_REQ].transitionCallback = Clause37StateMachineS8E0Callback;

    /* transition for state=AN_STATE_NEXT_PAGE_WAIT(8), event=AN_EVENT_STOP_REQ(1) */
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_STOP_REQ].used = TRUE;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_STOP_REQ].nextState = FM10000_AN_STATE_DISABLED;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_STOP_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_STOP_REQ].transitionCallback = Clause37StateMachineS8E1Callback;

    /* transition for state=AN_STATE_NEXT_PAGE_WAIT(8), event=AN_EVENT_RESTART_IND(3) */
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_RESTART_IND].used = TRUE;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_RESTART_IND].nextState = FM10000_AN_STATE_RESTART;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_RESTART_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_RESTART_IND].transitionCallback = Clause37StateMachineS8E3Callback;

    /* transition for state=AN_STATE_NEXT_PAGE_WAIT(8), event=AN_EVENT_DISABLE_LINK_OK_IND(4) */
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_DISABLE_LINK_OK_IND].used = TRUE;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_DISABLE_LINK_OK_IND].nextState = FM10000_AN_STATE_DISABLE_LINK_OK;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_DISABLE_LINK_OK_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_DISABLE_LINK_OK_IND].transitionCallback = NULL;

    /* transition for state=AN_STATE_NEXT_PAGE_WAIT(8), event=AN_EVENT_ACK_DETECT_IND(6) */
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_ACK_DETECT_IND].used = TRUE;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_ACK_DETECT_IND].nextState = FM10000_AN_STATE_ACK_DETECT;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_ACK_DETECT_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_ACK_DETECT_IND].transitionCallback = NULL;

    /* transition for state=AN_STATE_NEXT_PAGE_WAIT(8), event=AN_EVENT_COMPLETE_ACK_IND(7) */
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].used = TRUE;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].nextState = FM10000_AN_STATE_COMPLETE_ACK;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_NEXT_PAGE_WAIT]
       [FM10000_AN_EVENT_COMPLETE_ACK_IND].transitionCallback = Clause37StateMachineS8E7Callback;

    /* transition for state=AN_STATE_IDLE_DETECT(7), event=AN_EVENT_START_REQ(0) */
    stt[FM10000_AN_STATE_IDLE_DETECT]
       [FM10000_AN_EVENT_START_REQ].used = TRUE;
    stt[FM10000_AN_STATE_IDLE_DETECT]
       [FM10000_AN_EVENT_START_REQ].nextState = FM10000_AN_STATE_ENABLED;
    stt[FM10000_AN_STATE_IDLE_DETECT]
       [FM10000_AN_EVENT_START_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_IDLE_DETECT]
       [FM10000_AN_EVENT_START_REQ].transitionCallback = Clause37StateMachineS7E0Callback;

    /* transition for state=AN_STATE_IDLE_DETECT(7), event=AN_EVENT_STOP_REQ(1) */
    stt[FM10000_AN_STATE_IDLE_DETECT]
       [FM10000_AN_EVENT_STOP_REQ].used = TRUE;
    stt[FM10000_AN_STATE_IDLE_DETECT]
       [FM10000_AN_EVENT_STOP_REQ].nextState = FM10000_AN_STATE_DISABLED;
    stt[FM10000_AN_STATE_IDLE_DETECT]
       [FM10000_AN_EVENT_STOP_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_IDLE_DETECT]
       [FM10000_AN_EVENT_STOP_REQ].transitionCallback = Clause37StateMachineS7E1Callback;

    /* transition for state=AN_STATE_IDLE_DETECT(7), event=AN_EVENT_RESTART_IND(3) */
    stt[FM10000_AN_STATE_IDLE_DETECT]
       [FM10000_AN_EVENT_RESTART_IND].used = TRUE;
    stt[FM10000_AN_STATE_IDLE_DETECT]
       [FM10000_AN_EVENT_RESTART_IND].nextState = FM10000_AN_STATE_RESTART;
    stt[FM10000_AN_STATE_IDLE_DETECT]
       [FM10000_AN_EVENT_RESTART_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_IDLE_DETECT]
       [FM10000_AN_EVENT_RESTART_IND].transitionCallback = Clause37StateMachineS7E3Callback;

    /* transition for state=AN_STATE_IDLE_DETECT(7), event=AN_EVENT_LINK_OK_IND(10) */
    stt[FM10000_AN_STATE_IDLE_DETECT]
       [FM10000_AN_EVENT_LINK_OK_IND].used = TRUE;
    stt[FM10000_AN_STATE_IDLE_DETECT]
       [FM10000_AN_EVENT_LINK_OK_IND].nextState = FM10000_AN_STATE_LINK_OK;
    stt[FM10000_AN_STATE_IDLE_DETECT]
       [FM10000_AN_EVENT_LINK_OK_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_IDLE_DETECT]
       [FM10000_AN_EVENT_LINK_OK_IND].transitionCallback = Clause37StateMachineS7E10Callback;

    /* transition for state=AN_STATE_LINK_OK(12), event=AN_EVENT_START_REQ(0) */
    stt[FM10000_AN_STATE_LINK_OK]
       [FM10000_AN_EVENT_START_REQ].used = TRUE;
    stt[FM10000_AN_STATE_LINK_OK]
       [FM10000_AN_EVENT_START_REQ].nextState = FM10000_AN_STATE_ENABLED;
    stt[FM10000_AN_STATE_LINK_OK]
       [FM10000_AN_EVENT_START_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_LINK_OK]
       [FM10000_AN_EVENT_START_REQ].transitionCallback = Clause37StateMachineS12E0Callback;

    /* transition for state=AN_STATE_LINK_OK(12), event=AN_EVENT_STOP_REQ(1) */
    stt[FM10000_AN_STATE_LINK_OK]
       [FM10000_AN_EVENT_STOP_REQ].used = TRUE;
    stt[FM10000_AN_STATE_LINK_OK]
       [FM10000_AN_EVENT_STOP_REQ].nextState = FM10000_AN_STATE_DISABLED;
    stt[FM10000_AN_STATE_LINK_OK]
       [FM10000_AN_EVENT_STOP_REQ].conditionCallback = NULL;
    stt[FM10000_AN_STATE_LINK_OK]
       [FM10000_AN_EVENT_STOP_REQ].transitionCallback = Clause37StateMachineS12E1Callback;

    /* transition for state=AN_STATE_LINK_OK(12), event=AN_EVENT_RESTART_IND(3) */
    stt[FM10000_AN_STATE_LINK_OK]
       [FM10000_AN_EVENT_RESTART_IND].used = TRUE;
    stt[FM10000_AN_STATE_LINK_OK]
       [FM10000_AN_EVENT_RESTART_IND].nextState = FM10000_AN_STATE_RESTART;
    stt[FM10000_AN_STATE_LINK_OK]
       [FM10000_AN_EVENT_RESTART_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_LINK_OK]
       [FM10000_AN_EVENT_RESTART_IND].transitionCallback = Clause37StateMachineS12E3Callback;

    /* transition for state=AN_STATE_LINK_OK(12), event=AN_EVENT_DISABLE_LINK_OK_IND(4) */
    stt[FM10000_AN_STATE_LINK_OK]
       [FM10000_AN_EVENT_DISABLE_LINK_OK_IND].used = TRUE;
    stt[FM10000_AN_STATE_LINK_OK]
       [FM10000_AN_EVENT_DISABLE_LINK_OK_IND].nextState = FM10000_AN_STATE_DISABLE_LINK_OK;
    stt[FM10000_AN_STATE_LINK_OK]
       [FM10000_AN_EVENT_DISABLE_LINK_OK_IND].conditionCallback = NULL;
    stt[FM10000_AN_STATE_LINK_OK]
       [FM10000_AN_EVENT_DISABLE_LINK_OK_IND].transitionCallback = NULL;

    /* fill out the state transition table for this state machine type */
    for (i = 0 ; i < FM10000_AN_STATE_MAX  ; i++)
    {
        dynstt[i] = &stt[i][0];
    }

    /* register this state machine type */
    status = fmRegisterStateTransitionTable( FM10000_CLAUSE37_AN_STATE_MACHINE,
                                             FM10000_AN_STATE_MAX,
                                             FM10000_AN_EVENT_MAX,
                                             dynstt,
                                             logCallback,
                                             TRUE ); 
    return status;

}   /* end  fm10000RegisterClause37AnStateMachine */



